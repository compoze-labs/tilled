/* tslint:disable */
/* eslint-disable */
/**
 * Tilled API
 * The Tilled API is organized around [REST](http://en.wikipedia.org/wiki/Representational_State_Transfer). Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  You can use the Tilled API in test mode, which does not affect your live data or interact with the banking networks. The API key you use to authenticate the request determines whether the request is live mode or test mode. Before your account is activated you will only be able to interact with test mode.  Authentication uses a standard web token schema.  **Notice**: The Tilled API treats HTTP status `401` to mean `Unauthenticated` and not the HTTP standard name of `Unauthorized`. Requests made for materials the requester does not have permission to access, the API will respond with `403: Forbidden`.  # Authentication  The tilled API uses API keys to authenticate requests. You can view and manage your API keys in the Tilled Dashboard.  Test mode secret keys have the prefix sk*test* and live mode secret keys have the prefix sk*live*. Alternatively, you can use restricted API keys for granular permissions.  Your API keys carry many privileges, so be sure to keep them secure! Do not share your secret API keys in publicly accessible areas such as GitHub, client-side code, and so forth.  Authentication to the API is performed via custom HTTP Header `tilled-api-key`. Provide your API key as the value.  All API requests must be made over HTTPS. Calls made over plain HTTP will fail. API requests without authentication will also fail.  <!-- ReDoc-Inject: <security-definitions> -->  # Errors  Tilled uses conventional HTTP response codes to indicate the success or failure of an API request. In general: Codes in the `2xx` range indicate success. Codes in the `4xx` range indicate an error that failed given the information provided (e.g., a required parameter was omitted, a charge failed, etc.). Codes in the `5xx` range indicate an error with Tilled\'s servers (these are rare).  Some `4xx` errors that could be handled programmatically (e.g., a card is declined) include an error code that briefly explains the error reported.  # Request IDs  Each API request has an associated request identifier. You can find this value in the response headers, under `request-id`. If you need to contact us about a specific request, providing the request identifier will ensure the fastest possible resolution.  # Metadata  Updateable Tilled objects—including [Account](#tag/Accounts), [Customer](#tag/Customers), [PaymentIntent](#tag/PaymentIntents), [Refund](#tag/Refunds), and [Subscription](#tag/Subscriptions)—have a `metadata` parameter. You can use this parameter to attach key-value data to these Tilled objects.  You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long.  Metadata is useful for storing additional, structured information on an object. As an example, you could store your user\'s full name and corresponding unique identifier from your system on a Tilled [Customer](#tag/Customers) object. Metadata is not used by Tilled—for example, not used to authorize or decline a charge—and won\'t be seen by your users unless you choose to show it to them. Do not store any sensitive information (bank account numbers, card details, etc.) as metadata.  # Apple Pay  Tilled supports Apple Pay through the Tilled.js [`NativePaymentRequest`](#section/Tilled.js/Tilled.NativePaymentRequest) object.  In order to start accepting payments with Apple Pay, you will first need to validate the domains you plan to host the Apple Pay Button on by:  - Hosting Tilled\'s Apple Domain Verification File on the domain - Use the Tilled API to register the domain  ## Domain Verification File  Domains hosting an Apple Pay Button must be secured with HTTPS (TLS 1.2 or later) and have a valid SSL certificate.  Before [registering your domain](#operation/CreateApplePayDomain) with the Tilled API, you need to host Tilled\'s [Apple Domain Verification File](/apple-developer-merchantid-domain-association) on the domain at the path: `/.well-known/apple-developer-merchantid-domain-association`  # Tilled.js  Tilled.js is the easiest way to get started collecting payments. It allows you to embed a payments form in your application and stores credit card information securely on remote servers instead of passing through your network.  ## Installation  Add the following HTML snippet to your web page, preferably in the `<head>` tag of your web page:  ```html <script src=\"https://js.tilled.com/v1\"></script> ```  **Note**: To be PCI compliant, you must load Tilled.js directly from `https://js.tilled.com`. You cannot include it in a bundle or host it yourself.  ## Initialize  Instantiate an instance of `Tilled` by providing it with your Publishable API key and the Tilled account id of the account to perform the action on behalf of:  ```javascript const tilled = new Tilled(\'pk_…\', \'acct_…\'); ```  Use `Tilled(publishableKey, tilledAccount, options?)` to create an instance of the `Tilled` object. The `Tilled` object provides access to the rest of the Tilled.js SDK. Your Tilled publishable API key is required when calling this function, replace the sample API key above with your actual API key. You can retrieve your API key by accessing https://app.tilled.com/.  ### Sandbox Environment  For the sandbox environment, retrieve your API key from https://sandbox-api.tilled.com and instantiate an instance of `Tilled` with the following options:  ```javascript const tilled = new Tilled(\'pk_…\', \'acct_…\', { sandbox: true }); ```  ## Collecting Payment  The `tilled.Form` object can be used to collect credit card or bank ACH payment information securely.  The `tilled.NativePaymentRequest` object can be used to collect payment information using Apple Pay on supported browers and devices.  See below for more details.  ## Tilled.Form  ### Credit Card Form Example  ```javascript const form = tilled.form({   payment_method_type: \'card\', });  const fieldOptions = {   styles: {     base: {       fontFamily: \'Flexo, Muli, Helvetica Neue, Arial, sans-serif\',       color: \'#304166\',       fontWeight: \'400\',       fontSize: \'16px\',     },     invalid: {       \':hover\': {         textDecoration: \'underline dotted red\',       },     },     valid: {       color: \'#00BDA5\',     },   }, };  form.createField(\'cardNumber\', fieldOptions).inject(\'#card-number-element\'); form   .createField(\'cardExpiry\', { ...fieldOptions, placeholder: \'MM/YY\' })   .inject(\'#card-expiration-element\'); form.createField(\'cardCvv\', fieldOptions).inject(\'#card-cvv-element\'); form.build();  // submitButton is not defined, but imagine the form has a submit button the user would click submitButton.on(\'click\', () => {   tilled     .confirmPayment(payment_intent_client_secret, {       payment_method: {         form: form,         billing_details: {           name: \'John Doe\', // required           address: {             country: \'US\', // required             zip: \'12345\', // required             state: \'ST\',             city: \'City\',             street: \'123 ABC Lane\',           },           email: null,         },       },     })     .then(       (payment) => {         // payment is successful, payment will be an instance of PaymentIntent containing information about the transaction that was craeted       },       (err) => {         // show the error to the customer       },     ); }); ```  ```html <label   >Card Number   <div id=\"card-number-element\"></div> </label> <label   >Card Expiration   <div id=\"card-expiration-element\"></div> </label> <label   >Card CVV   <div id=\"card-cvv-element\"></div> </label> ```  ### ACH Bank Account Form Example  ```javascript const form = tilled.form({   payment_method_type: \'ach_debit\', });  form.createField(\'bankRoutingNumber\').inject(\'#bank-routing-number-element\'); form.createField(\'bankAccountNumber\').inject(\'#bank-account-number-element\'); form.build();  // submitButton is not defined, but imagine the form has a submit button the user would click submitButton.on(\'click\', () => {   tilled     .confirmPayment(payment_intent_client_secret, {       payment_method: {         form: form,         billing_details: {           name: \'John Doe\', // required           address: {             country: \'US\', // required             zip: \'12345\', // required             state: \'ST\', // required             city: \'City\', // required             street: \'123 ABC Lane\', // required           },           email: null, // optional         },         ach_debit: {           // required           account_type: \'checking\', // or \'savings\'         },       },     })     .then(       (payment) => {         // payment is successful, payment will be an instance of PaymentIntent containing information about the transaction that was craeted       },       (err) => {         // show the error to the customer       },     ); }); ```  ```html <label   >Bank Routing Number   <div id=\"bank-routing-number-element\"></div> </label> <label   >Bank Account Number   <div id=\"bank-account-number-element\"></div> </label> <!-- Also collect account type (\'checking\' or \'savings\'), and billing --> <!-- details to pass to the `confirmPayment` method. --> ```  ### tilled.form(options?)  This method creates a `Form` instance, which manages a set of inputs.  The `options` can contain the following properties:  - `payment_method_type` The payment method type being created by this form (`card` or `ach_debit`), defaults to `card`.  ### form.createField(inputType, options?)  This method creates a `FormField` instance  `inputType` can be one of the following values:  For Cards:  - `cardNumber` - `cardExpiry` - `cardCvv`  For ACH Debit:  - `bankRoutingNumber` - `bankAccountNumber`  `options` can contain the following properties:  - `disabled` The disabled state for the `FormField`. Default is `false`. - `autocomplete` The browser autocomplete state for the `FormField`. Default is `true`. - `styles` This option enables you to specify several CSS styles for your fields.  ### formField Styles  `FormField` objects are styled using a `Style` object, which consists of CSS properties nested under objects for any of the following variants:  - `base`, base variant—all other variants inherit from these styles - `valid`, applied when the FormField has valid input - `invalid`, applied when the FormField has invalid input  The following pseudo-classes can also be styled using a nested object inside of a variant:  - `:hover` - `:focus`  The following CSS properties are supported:  - `color` _string_ : The [color](https://developer.mozilla.org/en-US/docs/Web/CSS/color) CSS property. - `opacity` _string_ : The [opacity](https://developer.mozilla.org/en-US/docs/Web/CSS/opacity) CSS property. - `letterSpacing` _string_ : The [leter-spacing](https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing) CSS property. - `textAlign` _string_ : The [text-align](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align) CSS property. - `textIndent` _string_ : The [text-indent](https://developer.mozilla.org/en-US/docs/Web/CSS/text-indent) CSS property. - `textDecoration` _string_ : The [text-decoration](https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration) CSS property. - `textShadow` _string_ : The [text-shadow](https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow) CSS property. - `font` _string_ : The [font](https://developer.mozilla.org/en-US/docs/Web/CSS/font) CSS property. - `fontFamily` _string_ : The [font-family](https://developer.mozilla.org/en-US/docs/Web/CSS/font-family) CSS property. - `fontSize` _string_ : The [font-size](https://developer.mozilla.org/en-US/docs/Web/CSS/font-size) CSS property. - `fontStyle` _string_ : The [font-style](https://developer.mozilla.org/en-US/docs/Web/CSS/font-style) CSS property. - `fontWeight` _string_ : The [font-weight](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight) CSS property. - `lineWeight` _string_ : The [line-weight](https://developer.mozilla.org/en-US/docs/Web/CSS/line-weight) CSS property. - `transition` _string_ : The [transition](https://developer.mozilla.org/en-US/docs/Web/CSS/transition) CSS property.  Note: `FormField` styles are are currently available for the `cardNumber`, `cardExpiry`, `cardCvv` types.  Example:  ```javascript const fieldOptions = {   styles: {     base: {       fontFamily: \'Flexo, Muli, Helvetica Neue, Arial, sans-serif\',       color: \'#304166\',       fontWeight: \'400\',       fontSize: \'16px\',     },     invalid: {       \':hover\': {         textDecoration: \'underline dotted red\',       },     },     valid: {       color: \'#00BDA5\',     },   }, };  form.createField(\'cardNumber\', fieldOptions).inject(\'#card-number-element\'); ```  ### formField.inject(\'#card-element\')  The `formField.inject` method attaches your `FormField` to the DOM. `formField.inject` accepts either a [DOMString](https://developer.mozilla.org/en-US/docs/Web/API/DOMString) or a DOM element.  You need to create a container DOM element to mount a FormField. If the container DOM element has a label, the FormField is automatically focused when its label is clicked. There are two ways to do this:  - Mount the instance within a `<label>`. - Create a `<label>` with a for attribute, referencing the ID of your container.  ### formField.on(\'change\', handler)  The change event is triggered when the `FormField`\'s value changes. When a change occurs, your `handler` function will be called with an `event` payload containing the following properties:  - `empty` true if the value is empty - `complete` if the value appears valid  ### form.build()  Call this method after you have defined your form to build and inject all the fields.  ## Tilled.NativePaymentRequest  ### NativePaymentRequest Button Example  ```javascript const form = tilled.form({   payment_method_type: \'card\', });  const nativePaymentRequest = this.tilled.nativePaymentRequest(null, {   total: {     label: \'Red Widgets\',     amount: \'$10\',   }, });  nativePaymentRequest.canMakePayment().then((result) => {   if (result) {     nativePaymentRequest.inject(\'#native-payment-element\');   } });  nativePaymentRequest.on(\'paymentmethod\', (ev: any) => {   let paymentMethod = ev.detail.paymentMethod;   this.tilled     .confirmPayment(payment_intent_client_secret, {       payment_method: paymentMethod.id,     })     .then((paymentIntent: PaymentIntent) => {       if (!paymentIntent) {         //failure         ev.detail.complete(\'fail\');       } else {         //success         ev.detail.complete(\'success\');       }     }); }); ```  ```html <label   ><!--Apple Pay Button Container-->   <div id=\"native-payment-element\"></div> </label> ```  ## Processing Payments Overview  Prior to displaying your checkout form and confirming the payment, your backend server will need to make an API call to Tilled to create a payment intent with the payment amount. You will pass the intent\'s client_secret to your front end. Use the `tilled.confirmPayment(client_secret, data)` method to process a payment with either the `ID` of an existing Tilled [[`PaymentMethod`]](#tag/PaymentMethod) or a [[`PaymentMethod`]](#section/Tilled.js/Payment-Method-Input) object.  ## Confirm The Payment Intent  ### `tilled.confirmPayment(client_secret, data)`  The `client_secret` is the `payment_intent.client_secret` generated from your backend server before displaying the payment form.  The `data` parameter can be one of the following:  - A string with the ID of an existing Tilled [`PaymentMethod`](#tag/PaymentMethods) (`\'pm_...\'`) - A [[`PaymentMethod`]](#section/Tilled.js/Payment-Method-Input)  #### Returns  `tilled.confirmPayment` returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) which will resolve with a `PaymentIntent` object. See [`Payment`](https://developer.tilled.com/#operation--customers--customer--payment-charges-post) for more information. You can find the id of a newly created PaymentMethod by inspecting the `payment_intent.payment_method.id`. Consider passing it to your backend for persistence and re-use.  ## Payment Method Input  When Confirming Payments or Creating Payment Methods, the PaymentMethod object can contain:  - `form` [`Tilled.Form`] - `billingDetails`   - `name` the card holder\'s full name   - `address` an object representing the card holder\'s billing address   - `email` the email address of the card holder - `ach_debit` (for ACH Debit payments)   - `account_type` the ACH Debit Account type  ## Creating Payment Methods  If you just want to create a new payment method without processing a payment, use the `tilled.createPaymentMethod(paymentMethod)` method to securely pass collected payment information to Tilled\'s API.  **Note**: In most cases, this method is not necessary, because `tilled.confirmPayment` automatically creates a `PaymentMethod` and returns it on the `PaymentIntent` object.  #### Returns  `tilled.createPaymentMethod` returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) which will resolve with a `PaymentMethod` object. See [`PaymentMethod`](https://developer.tilled.com/#operation--customers--customer--payment-methods-post) for more information.  [tilled-form]: #Collecting-Payment-Information  ## Styling  You can apply a CSS class to the DOM element container you are injecting a Tilled.js Form or NativePaymentRequest element into and the styles will be applied to the resulting injected elements.  ```html <div class=\"myCustomCss\" id=\"card-number-element\"></div> ```  # Webhooks  ## Receive event notifications with webhooks  Listen for events on your Tilled account so your integration can automatically trigger reactions.  Tilled uses webhooks to notify your application when an event happens in your account. Webhooks are particularly useful for asynchronous events like when a customer’s bank confirms a payment, a customer disputes a charge, or a recurring payment succeeds.  Begin using webhooks with your Tilled integration in just a couple steps:  - Create a webhook endpoint on your server. - Register the endpoint with Tilled to go live.  Not all Tilled integrations require webhooks. Keep reading to learn more about what webhooks are and when you should use them.  ### What are webhooks  _Webhooks_ refers to a combination of elements that collectively create a notification and reaction system within a larger integration.  Metaphorically, webhooks are like a phone number that Tilled calls to notify you of activity in your Tilled account. The activity could be the creation of a new customer or the payout of funds to your bank account. The webhook endpoint is the person answering that call who takes actions based upon the specific information it receives.  Non-metaphorically, the webhook endpoint is just more code on your server, which could be written in Ruby, PHP, Node.js, or whatever. The webhook endpoint has an associated URL (e.g., https://example.com/webhooks). The Tilled notifications are Event objects. This Event object contains all the relevant information about what just happened, including the type of event and the data associated with that event. The webhook endpoint uses the event details to take any required actions, such as indicating that an order should be fulfilled.  ### When to use webhooks  Many events that occur within a Tilled account have synchronous results–immediate and direct–to an executed request. For example, a successful request to create a customer immediately returns a Customer object. Such requests don’t require webhooks, as the key information is already available.  Other events that occur within a Tilled account are asynchronous: happening at a later time and not directly in response to your code’s execution. Most commonly these involve:  - The [Payment Intents API](#tag/PaymentIntents)  With these and similar APIs, Tilled needs to notify your integration about changes to the status of an object so your integration can take subsequent steps.  The specific actions your webhook endpoint may take differs based upon the event. Some examples include:  - Updating a customer’s membership record in your database when a subscription payment succeeds - Logging an accounting entry when a transfer is paid - Indicating that an order can be fulfilled (i.e., boxed and shipped)  ## Verifying signatures manually  The `tilled-signature` header included in each signed event contains a timestamp and one or more signatures. The timestamp is prefixed by `t=`, and each signature is prefixed by a `scheme`. Schemes start with `v`, followed by an integer. Currently, the only valid live signature scheme is `v1`.  ``` tilled-signature:t=1614049713663,v1=8981f5902896f479fa9079eec71fca01e9a065c5b59a96b221544023ce994b02 ```  Tilled generates signatures using a hash-based message authentication code ([HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code)) with [SHA-256](https://en.wikipedia.org/wiki/SHA-2). You should ignore all schemes that are not `v1`.  You can verify the webhook event signature by following these steps.  ### Step 1: Extract the timestamp and signatures from the header  Split the header, using the `,` character as the separator, to get a list of elements. Then split each element, using the `=` character as the separator, to get a prefix and value pair.  The value for the prefix `t` corresponds to the timestamp, and `v1` corresponds to the signature (or signatures). You can discard all other elements.  ### Step 2: Prepare the signed_payload string  The `signed_payload` string is created by concatenating:  - The timestamp (as a string) - The character `.` - The actual JSON payload (i.e., the request body)  ### Step 3: Determine the expected signature  Compute an HMAC with the SHA256 hash function. Use the endpoint’s signing secret as the key, and use the `signed_payload` string as the message.  ### Step 4: Compare the signatures  Compare the signature (or signatures) in the header to the expected signature. For an equality match, compute the difference between the current timestamp and the received timestamp, then decide if the difference is within your tolerance.  To protect against timing attacks, use a constant-time string comparison to compare the expected signature to each of the received signatures. 
 *
 * The version of the OpenAPI document: 1.0
 * Contact: integrations@tilled.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessTokenRefreshParams
 */
export interface AccessTokenRefreshParams {
    /**
     * The bcrypted refresh token data.
     * @type {string}
     * @memberof AccessTokenRefreshParams
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof Account
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof Account
     */
    'created_at': string;
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof Account
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * The Tilled account type. Can be `partner` or `merchant`.
     * @type {string}
     * @memberof Account
     */
    'type': AccountTypeEnum;
    /**
     * The business name or individual name.
     * @type {string}
     * @memberof Account
     */
    'name'?: string;
    /**
     * The primary user\'s email address.
     * @type {string}
     * @memberof Account
     */
    'email'?: string;
    /**
     * Capabilities represent the assigned product codes to a given merchant account and their status.
     * @type {Array<AccountCapability>}
     * @memberof Account
     */
    'capabilities'?: Array<AccountCapability>;
    /**
     * Bank accounts attached to this account. Primarily used for payouts.
     * @type {Array<BankAccount>}
     * @memberof Account
     */
    'bank_accounts': Array<BankAccount>;
    /**
     * Terminal Readers attached to this account.
     * @type {Array<TerminalReader>}
     * @memberof Account
     */
    'terminal_readers': Array<TerminalReader>;
    /**
     * 
     * @type {AccountBusinessProfile}
     * @memberof Account
     */
    'business_profile'?: AccountBusinessProfile;
    /**
     * 
     * @type {AccountSettings}
     * @memberof Account
     */
    'settings'?: AccountSettings;
    /**
     * The `partner` white label domain.
     * @type {string}
     * @memberof Account
     */
    'white_label_domain'?: string;
}

export const AccountTypeEnum = {
    Partner: 'partner',
    Merchant: 'merchant'
} as const;

export type AccountTypeEnum = typeof AccountTypeEnum[keyof typeof AccountTypeEnum];

/**
 * The Business Profile for this account.
 * @export
 * @interface AccountBusinessProfile
 */
export interface AccountBusinessProfile {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof AccountBusinessProfile
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof AccountBusinessProfile
     */
    'created_at': string;
    /**
     * 
     * @type {BusinessProfileAddress}
     * @memberof AccountBusinessProfile
     */
    'address': BusinessProfileAddress;
    /**
     * MCC category.
     * @type {string}
     * @memberof AccountBusinessProfile
     */
    'category': AccountBusinessProfileCategoryEnum;
    /**
     * The legal name for the business.
     * @type {string}
     * @memberof AccountBusinessProfile
     */
    'legal_name': string;
    /**
     * The locale for the business.
     * @type {string}
     * @memberof AccountBusinessProfile
     */
    'locale': AccountBusinessProfileLocaleEnum;
    /**
     * The business\'s phone number.
     * @type {string}
     * @memberof AccountBusinessProfile
     */
    'phone': string;
    /**
     * The region where the business is located.
     * @type {string}
     * @memberof AccountBusinessProfile
     */
    'region': AccountBusinessProfileRegionEnum;
    /**
     * The structure of the business (LLC, Corp, etc.).
     * @type {string}
     * @memberof AccountBusinessProfile
     */
    'structure': AccountBusinessProfileStructureEnum;
    /**
     * Tax identification number.
     * @type {string}
     * @memberof AccountBusinessProfile
     */
    'tax_identification_number': string;
    /**
     * The website of the business.
     * @type {string}
     * @memberof AccountBusinessProfile
     */
    'website'?: string;
    /**
     * A list of Representatives included in the onboarding application.
     * @type {Array<BusinessRepresentative>}
     * @memberof AccountBusinessProfile
     */
    'representatives': Array<BusinessRepresentative>;
}

export const AccountBusinessProfileCategoryEnum = {
    Acct: 'ACCT',
    Art: 'ART',
    Beauty: 'BEAUTY',
    Catering: 'CATERING',
    Charity: 'CHARITY',
    Cleaning: 'CLEANING',
    Consultant: 'CONSULTANT',
    Contractor: 'CONTRACTOR',
    Dentist: 'DENTIST',
    Edu: 'EDU',
    Food: 'FOOD',
    Landscaping: 'LANDSCAPING',
    Legal: 'LEGAL',
    MedicalPract: 'MEDICAL_PRACT',
    MedicalServ: 'MEDICAL_SERV',
    Membership: 'MEMBERSHIP',
    MiscFoodStores: 'MISC_FOOD_STORES',
    MiscMerch: 'MISC_MERCH',
    MiscServ: 'MISC_SERV',
    Music: 'MUSIC',
    Pc: 'PC',
    PhotoFilm: 'PHOTO_FILM',
    ProfServ: 'PROF_SERV',
    RealEstate: 'REAL_ESTATE',
    Recreation: 'RECREATION',
    Repair: 'REPAIR',
    Resto: 'RESTO',
    Retail: 'RETAIL',
    Taxi: 'TAXI',
    Vet: 'VET',
    WebDev: 'WEB_DEV',
    WebHosting: 'WEB_HOSTING'
} as const;

export type AccountBusinessProfileCategoryEnum = typeof AccountBusinessProfileCategoryEnum[keyof typeof AccountBusinessProfileCategoryEnum];
export const AccountBusinessProfileLocaleEnum = {
    EnUs: 'en_US',
    EnCa: 'en_CA',
    FrCa: 'fr_CA',
    EnGb: 'en_GB'
} as const;

export type AccountBusinessProfileLocaleEnum = typeof AccountBusinessProfileLocaleEnum[keyof typeof AccountBusinessProfileLocaleEnum];
export const AccountBusinessProfileRegionEnum = {
    Us: 'US',
    Ca: 'CA'
} as const;

export type AccountBusinessProfileRegionEnum = typeof AccountBusinessProfileRegionEnum[keyof typeof AccountBusinessProfileRegionEnum];
export const AccountBusinessProfileStructureEnum = {
    Charity: 'CHARITY',
    Cic: 'CIC',
    Corp: 'CORP',
    Ltd: 'LTD',
    Llc: 'LLC',
    Llp: 'LLP',
    Npcorp: 'NPCORP',
    Partnership: 'PARTNERSHIP',
    Plc: 'PLC',
    Gov: 'GOV',
    Soleprop: 'SOLEPROP',
    Trust: 'TRUST'
} as const;

export type AccountBusinessProfileStructureEnum = typeof AccountBusinessProfileStructureEnum[keyof typeof AccountBusinessProfileStructureEnum];

/**
 * 
 * @export
 * @interface AccountCapability
 */
export interface AccountCapability {
    /**
     * Status of the associated product code as part of the onboarding process. Only the `active` status represents that payments can be handled by this account for this given product code.  `created` The capability has been created but no further action taken. Generally, this is the state of all capabilities when a merchant has been created but the onboarding process has not yet started.  `started` The onboarding process has been started but not yet submitted.  `submitted` The onboarding process for this product code has been submitted.  `active` This associated product code is active for payments on this account.  `disabled` This associated product code is not valid for payments on this account.
     * @type {string}
     * @memberof AccountCapability
     */
    'status': AccountCapabilityStatusEnum;
    /**
     * 
     * @type {AccountCapabilityProductCode}
     * @memberof AccountCapability
     */
    'product_code': AccountCapabilityProductCode;
    /**
     * The fields that need to be collected again because validation failed for some reason.
     * @type {Array<AccountRequirementsError>}
     * @memberof AccountCapability
     */
    'requirements_errors': Array<AccountRequirementsError>;
    /**
     * The percentage of required fields completed in the onboarding application.
     * @type {number}
     * @memberof AccountCapability
     */
    'onboarding_application_progress': number;
    /**
     * The URL for the merchant\'s onboarding application.
     * @type {string}
     * @memberof AccountCapability
     */
    'onboarding_application_url'?: string;
}

export const AccountCapabilityStatusEnum = {
    Created: 'created',
    Started: 'started',
    Submitted: 'submitted',
    Active: 'active',
    Disabled: 'disabled',
    InReview: 'in_review',
    Rejected: 'rejected',
    Withdrawn: 'withdrawn'
} as const;

export type AccountCapabilityStatusEnum = typeof AccountCapabilityStatusEnum[keyof typeof AccountCapabilityStatusEnum];

/**
 * The product code applied to/associated with this account.
 * @export
 * @interface AccountCapabilityProductCode
 */
export interface AccountCapabilityProductCode {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof AccountCapabilityProductCode
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof AccountCapabilityProductCode
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof AccountCapabilityProductCode
     */
    'id': string;
    /**
     * The user friendly description. Example: *2.90% | $0.30 TXN | $10 CHBK/Reversals/Retrievals | $0 Monthly*
     * @type {string}
     * @memberof AccountCapabilityProductCode
     */
    'description': string;
    /**
     * The payment method type that this product code is valid for.
     * @type {string}
     * @memberof AccountCapabilityProductCode
     */
    'payment_method_type': AccountCapabilityProductCodePaymentMethodTypeEnum;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof AccountCapabilityProductCode
     */
    'currency': AccountCapabilityProductCodeCurrencyEnum;
    /**
     * The Region in which the product code is usable
     * @type {string}
     * @memberof AccountCapabilityProductCode
     */
    'region'?: AccountCapabilityProductCodeRegionEnum;
}

export const AccountCapabilityProductCodePaymentMethodTypeEnum = {
    Card: 'card',
    AchDebit: 'ach_debit',
    CardPresent: 'card_present',
    EftDebit: 'eft_debit'
} as const;

export type AccountCapabilityProductCodePaymentMethodTypeEnum = typeof AccountCapabilityProductCodePaymentMethodTypeEnum[keyof typeof AccountCapabilityProductCodePaymentMethodTypeEnum];
export const AccountCapabilityProductCodeCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type AccountCapabilityProductCodeCurrencyEnum = typeof AccountCapabilityProductCodeCurrencyEnum[keyof typeof AccountCapabilityProductCodeCurrencyEnum];
export const AccountCapabilityProductCodeRegionEnum = {
    Us: 'US',
    Ca: 'CA'
} as const;

export type AccountCapabilityProductCodeRegionEnum = typeof AccountCapabilityProductCodeRegionEnum[keyof typeof AccountCapabilityProductCodeRegionEnum];

/**
 * 
 * @export
 * @interface AccountCreateParams
 */
export interface AccountCreateParams {
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value (i.e. `\'\'` or `null`) to them. All keys can be unset by posting an empty value (i.e. `{}` or `null`) to `metadata`.
     * @type {{ [key: string]: string; }}
     * @memberof AccountCreateParams
     */
    'metadata'?: { [key: string]: string; };
    /**
     * The business name or individual name.
     * @type {string}
     * @memberof AccountCreateParams
     */
    'name'?: string;
    /**
     * The primary user\'s email address.
     * @type {string}
     * @memberof AccountCreateParams
     */
    'email': string;
    /**
     * An array of ProductCode ids to associate with the `merchant` account. This is ignored for `partner` accounts. Only 1 product code per `payment_method_type` is allowed. For example, only 1 `card` and 1 `ach_debit` may be submitted for a given merchant. You cannot specify 2 product codes of type `card` for a single merchant. You should create a separate merchant account in that case.  *Note: If your account contains multiple product codes for a given payment method type, then you must explicitly specify the one you want to use. If your account only contains a single product code per payment method type then those values will be the default. If your account is enabled to process in both the United States and Canada, new merchant accounts will be configured with US product codes if no value is specified for `product_code_ids`.*
     * @type {Array<string>}
     * @memberof AccountCreateParams
     */
    'product_code_ids'?: Array<string>;
    /**
     * 
     * @type {AccountCreateParamsBankAccount}
     * @memberof AccountCreateParams
     */
    'bank_account'?: AccountCreateParamsBankAccount;
    /**
     * 
     * @type {AccountCreateParamsSettings}
     * @memberof AccountCreateParams
     */
    'settings'?: AccountCreateParamsSettings;
}
/**
 * A bank account to attach to this account for receiving payouts. (Note: currently this is only used for `partner` account payouts)  By default, providing a bank account sets it as the new default bank account for its currency.
 * @export
 * @interface AccountCreateParamsBankAccount
 */
export interface AccountCreateParamsBankAccount {
    /**
     * The bank account type
     * @type {string}
     * @memberof AccountCreateParamsBankAccount
     */
    'type': AccountCreateParamsBankAccountTypeEnum;
    /**
     * The US bank account routing number.
     * @type {string}
     * @memberof AccountCreateParamsBankAccount
     */
    'routing_number': string;
    /**
     * The account number for the bank account, in string form.
     * @type {string}
     * @memberof AccountCreateParamsBankAccount
     */
    'account_number': string;
    /**
     * The name of the person or business that owns the bank account.
     * @type {string}
     * @memberof AccountCreateParamsBankAccount
     */
    'account_holder_name': string;
    /**
     * The currency the bank account is in. Three-letter ISO currency code, in lowercase.
     * @type {string}
     * @memberof AccountCreateParamsBankAccount
     */
    'currency': AccountCreateParamsBankAccountCurrencyEnum;
    /**
     * Name of the financial institution.
     * @type {string}
     * @memberof AccountCreateParamsBankAccount
     */
    'bank_name'?: string;
    /**
     * Phone number for the financial institution
     * @type {string}
     * @memberof AccountCreateParamsBankAccount
     */
    'phone'?: string;
}

export const AccountCreateParamsBankAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings'
} as const;

export type AccountCreateParamsBankAccountTypeEnum = typeof AccountCreateParamsBankAccountTypeEnum[keyof typeof AccountCreateParamsBankAccountTypeEnum];
export const AccountCreateParamsBankAccountCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type AccountCreateParamsBankAccountCurrencyEnum = typeof AccountCreateParamsBankAccountCurrencyEnum[keyof typeof AccountCreateParamsBankAccountCurrencyEnum];

/**
 * Account Settings
 * @export
 * @interface AccountCreateParamsSettings
 */
export interface AccountCreateParamsSettings {
    /**
     * 
     * @type {AccountSettingsCreateParamsBranding}
     * @memberof AccountCreateParamsSettings
     */
    'branding'?: AccountSettingsCreateParamsBranding;
}
/**
 * 
 * @export
 * @interface AccountRequirementsError
 */
export interface AccountRequirementsError {
    /**
     * The informative message that indicates the error type and additional details about the error.
     * @type {string}
     * @memberof AccountRequirementsError
     */
    'reason': string;
    /**
     * The specific account onboarding requirement field that needs to be resolved.
     * @type {string}
     * @memberof AccountRequirementsError
     */
    'requirement': string;
}
/**
 * The account settings object.
 * @export
 * @interface AccountSettings
 */
export interface AccountSettings {
    /**
     * 
     * @type {AccountSettingsBranding}
     * @memberof AccountSettings
     */
    'branding'?: AccountSettingsBranding;
}
/**
 * The account branding settings.
 * @export
 * @interface AccountSettingsBranding
 */
export interface AccountSettingsBranding {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof AccountSettingsBranding
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof AccountSettingsBranding
     */
    'created_at': string;
    /**
     * 
     * @type {any}
     * @memberof AccountSettingsBranding
     */
    'logo': any;
    /**
     * The primary hexadecimal color value.
     * @type {string}
     * @memberof AccountSettingsBranding
     */
    'primary_color'?: string;
    /**
     * The secondary hexadecimal color value.
     * @type {string}
     * @memberof AccountSettingsBranding
     */
    'secondary_color'?: string;
}
/**
 * 
 * @export
 * @interface AccountSettingsBrandingCreateParams
 */
export interface AccountSettingsBrandingCreateParams {
    /**
     * The File ID of an uploaded [File](#tag/Files) of type `logo`
     * @type {string}
     * @memberof AccountSettingsBrandingCreateParams
     */
    'logo_file_id'?: string;
    /**
     * A string indicating a hexadecimal color.
     * @type {string}
     * @memberof AccountSettingsBrandingCreateParams
     */
    'primary_color'?: string;
    /**
     * A string indicating a hexadecimal color.
     * @type {string}
     * @memberof AccountSettingsBrandingCreateParams
     */
    'secondary_color'?: string;
}
/**
 * 
 * @export
 * @interface AccountSettingsCreateParams
 */
export interface AccountSettingsCreateParams {
    /**
     * 
     * @type {AccountSettingsCreateParamsBranding}
     * @memberof AccountSettingsCreateParams
     */
    'branding'?: AccountSettingsCreateParamsBranding;
}
/**
 * The account branding settings.
 * @export
 * @interface AccountSettingsCreateParamsBranding
 */
export interface AccountSettingsCreateParamsBranding {
    /**
     * The File ID of an uploaded [File](#tag/Files) of type `logo`
     * @type {string}
     * @memberof AccountSettingsCreateParamsBranding
     */
    'logo_file_id'?: string;
    /**
     * A string indicating a hexadecimal color.
     * @type {string}
     * @memberof AccountSettingsCreateParamsBranding
     */
    'primary_color'?: string;
    /**
     * A string indicating a hexadecimal color.
     * @type {string}
     * @memberof AccountSettingsCreateParamsBranding
     */
    'secondary_color'?: string;
}
/**
 * 
 * @export
 * @interface AccountUpdateParams
 */
export interface AccountUpdateParams {
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value (i.e. `\'\'` or `null`) to them. All keys can be unset by posting an empty value (i.e. `{}` or `null`) to `metadata`.
     * @type {{ [key: string]: string; }}
     * @memberof AccountUpdateParams
     */
    'metadata'?: { [key: string]: string; };
    /**
     * The custom domain the `partner` chooses to reflect on all of its `merchant` accounts as part of the white label settings. It requires `paymentsonline.io` to be appended to the string to be accepted as a valid URL (i.e. `https://customdomain.paymentsonline.io`).  *Note: This feature is only available to `Partner` accounts.*
     * @type {string}
     * @memberof AccountUpdateParams
     */
    'white_label_domain'?: string;
    /**
     * The business name or individual name.
     * @type {string}
     * @memberof AccountUpdateParams
     */
    'name'?: string;
    /**
     * The primary user\'s email address.
     * @type {string}
     * @memberof AccountUpdateParams
     */
    'email'?: string;
    /**
     * An array of ProductCode ids to associate with the `merchant` account. This is ignored for `partner` accounts. Only 1 product code per `payment_method_type` is allowed. For example, only 1 `card` and 1 `ach_debit` may be submitted for a given merchant. You cannot specify 2 product codes of type `card` for a single merchant. You should create a separate merchant account in that case.  *Note: If your account contains multiple product codes for a given payment method type, then you must explicitly specify the one you want to use. If your account only contains a single product code per payment method type then those values will be the default. If your account is enabled to process in both the United States and Canada, new merchant accounts will be configured with US product codes if no value is specified for `product_code_ids`.*
     * @type {Array<string>}
     * @memberof AccountUpdateParams
     */
    'product_code_ids'?: Array<string>;
    /**
     * 
     * @type {AccountCreateParamsBankAccount}
     * @memberof AccountUpdateParams
     */
    'bank_account'?: AccountCreateParamsBankAccount;
    /**
     * 
     * @type {AccountCreateParamsSettings}
     * @memberof AccountUpdateParams
     */
    'settings'?: AccountCreateParamsSettings;
}
/**
 * 
 * @export
 * @interface AchDebitDetails
 */
export interface AchDebitDetails {
    /**
     * Name of the bank associated to this Ach Debit.
     * @type {string}
     * @memberof AchDebitDetails
     */
    'bank_name'?: string;
    /**
     * The last 2 digits of the bank acount number.
     * @type {string}
     * @memberof AchDebitDetails
     */
    'last2'?: string;
    /**
     * Nine-digit code that identifies specific financial institution in the US.
     * @type {string}
     * @memberof AchDebitDetails
     */
    'routing_number'?: string;
    /**
     * Account type
     * @type {string}
     * @memberof AchDebitDetails
     */
    'account_type'?: AchDebitDetailsAccountTypeEnum;
}

export const AchDebitDetailsAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings',
    Unknown: 'unknown'
} as const;

export type AchDebitDetailsAccountTypeEnum = typeof AchDebitDetailsAccountTypeEnum[keyof typeof AchDebitDetailsAccountTypeEnum];

/**
 * 
 * @export
 * @interface AchDebitSingleUseToken
 */
export interface AchDebitSingleUseToken {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof AchDebitSingleUseToken
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof AchDebitSingleUseToken
     */
    'created_at': string;
    /**
     * 
     * @type {AchDebitSingleUseTokenDetails}
     * @memberof AchDebitSingleUseToken
     */
    'details'?: AchDebitSingleUseTokenDetails;
    /**
     * The single-use token that is capable of being used to generate an `ach_debit` Payment Method. It represents bank account details.
     * @type {string}
     * @memberof AchDebitSingleUseToken
     */
    'payment_token': string;
    /**
     * The time at which the token expires and is no longer available.
     * @type {string}
     * @memberof AchDebitSingleUseToken
     */
    'expires_at': string;
}
/**
 * This hash contains details about the ACH Debit bank account.
 * @export
 * @interface AchDebitSingleUseTokenDetails
 */
export interface AchDebitSingleUseTokenDetails {
    /**
     * Name of the bank associated to this Ach Debit.
     * @type {string}
     * @memberof AchDebitSingleUseTokenDetails
     */
    'bank_name'?: string;
    /**
     * The last 2 digits of the bank acount number.
     * @type {string}
     * @memberof AchDebitSingleUseTokenDetails
     */
    'last2'?: string;
    /**
     * Nine-digit code that identifies specific financial institution in the US.
     * @type {string}
     * @memberof AchDebitSingleUseTokenDetails
     */
    'routing_number'?: string;
    /**
     * Account type
     * @type {string}
     * @memberof AchDebitSingleUseTokenDetails
     */
    'account_type'?: AchDebitSingleUseTokenDetailsAccountTypeEnum;
}

export const AchDebitSingleUseTokenDetailsAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings',
    Unknown: 'unknown'
} as const;

export type AchDebitSingleUseTokenDetailsAccountTypeEnum = typeof AchDebitSingleUseTokenDetailsAccountTypeEnum[keyof typeof AchDebitSingleUseTokenDetailsAccountTypeEnum];

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof Address
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof Address
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof Address
     */
    'id': string;
    /**
     * Address line 1 (e.g., street, PO Box, or company name).
     * @type {string}
     * @memberof Address
     */
    'street'?: string;
    /**
     * Address line 2 (e.g., apartment, suite, unit, or building).
     * @type {string}
     * @memberof Address
     */
    'street2'?: string;
    /**
     * City, district, suburb, town, or village.
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * ZIP or postal code.
     * @type {string}
     * @memberof Address
     */
    'postal_code'?: string;
    /**
     * State or province.
     * @type {string}
     * @memberof Address
     */
    'state'?: string;
    /**
     * Country.
     * @type {string}
     * @memberof Address
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof ApiKey
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof ApiKey
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof ApiKey
     */
    'id': string;
    /**
     * The actual value of the API key to be included in the `tilled-api-key` header for authentication. `secret` keys will have a redacted value except when initially created.
     * @type {string}
     * @memberof ApiKey
     */
    'value': string;
    /**
     * The string that you assign to describe the resource. It defaults to \'`type` Key\' (e.g. \'Secret Key\' and \'Publishable Key\')
     * @type {string}
     * @memberof ApiKey
     */
    'name': string;
    /**
     * The type of API key.  `secret` can be used to authenticate all endpoints. `publishable` is used in your frontend application and can only access a handful of endpoints (e.g. confirm a Payment Intent).
     * @type {string}
     * @memberof ApiKey
     */
    'type': ApiKeyTypeEnum;
    /**
     * The id of the associated account.
     * @type {string}
     * @memberof ApiKey
     */
    'account_id': string;
    /**
     * Time at which the key was last used to authenticate with the API.
     * @type {string}
     * @memberof ApiKey
     */
    'last_used'?: string;
    /**
     * The list of scopes to define the access for this key. You may specify `[\'*\']` to enable all scopes, except those that require explicit selection.
     * @type {Array<string>}
     * @memberof ApiKey
     */
    'scopes': Array<ApiKeyScopesEnum>;
}

export const ApiKeyTypeEnum = {
    Publishable: 'publishable',
    Secret: 'secret'
} as const;

export type ApiKeyTypeEnum = typeof ApiKeyTypeEnum[keyof typeof ApiKeyTypeEnum];
export const ApiKeyScopesEnum = {
    Star: '*',
    Accountsread: 'accounts:read',
    Accountswrite: 'accounts:write',
    ApiKeysread: 'api_keys:read',
    ApiKeyswrite: 'api_keys:write',
    BalanceTransactionsread: 'balance_transactions:read',
    Chargesread: 'charges:read',
    Customersread: 'customers:read',
    Customerswrite: 'customers:write',
    Eventsread: 'events:read',
    PaymentIntentsread: 'payment_intents:read',
    PaymentIntentswrite: 'payment_intents:write',
    PaymentMethodsread: 'payment_methods:read',
    PaymentMethodswrite: 'payment_methods:write',
    Payoutsread: 'payouts:read',
    Payoutswrite: 'payouts:write',
    PlatformFeesread: 'platform_fees:read',
    ProductCodesread: 'product_codes:read',
    Refundsread: 'refunds:read',
    Refundswrite: 'refunds:write',
    Usersread: 'users:read',
    Userswrite: 'users:write',
    WebhookEndpointsread: 'webhook_endpoints:read',
    WebhookEndpointswrite: 'webhook_endpoints:write',
    ApplePayDomainsread: 'apple_pay_domains:read',
    ApplePayDomainswrite: 'apple_pay_domains:write',
    BankAccountsread: 'bank_accounts:read',
    BankAccountswrite: 'bank_accounts:write',
    Filesread: 'files:read',
    Fileswrite: 'files:write',
    UserInvitationsread: 'user_invitations:read',
    UserInvitationswrite: 'user_invitations:write',
    Subscriptionsread: 'subscriptions:read',
    Subscriptionswrite: 'subscriptions:write',
    Disputesread: 'disputes:read',
    PricingTemplatesread: 'pricing_templates:read',
    PricingTemplateswrite: 'pricing_templates:write'
} as const;

export type ApiKeyScopesEnum = typeof ApiKeyScopesEnum[keyof typeof ApiKeyScopesEnum];

/**
 * 
 * @export
 * @interface ApiKeyCreateParams
 */
export interface ApiKeyCreateParams {
    /**
     * The list of scopes to define the access for this key. You may specify `[\'*\']` (default) to enable all scopes, except those that require explicit selection. Scopes are ignored for keys of type `publishable`.
     * @type {Array<string>}
     * @memberof ApiKeyCreateParams
     */
    'scopes'?: Array<ApiKeyCreateParamsScopesEnum>;
    /**
     * `secret` Must be kept secret at all times.  `publishable` A publishable key is only used for creating payment tokens on your public facing website or integration.
     * @type {string}
     * @memberof ApiKeyCreateParams
     */
    'type': ApiKeyCreateParamsTypeEnum;
    /**
     * A brief name or description of the API that will help you remember what it is used for.
     * @type {string}
     * @memberof ApiKeyCreateParams
     */
    'name'?: string;
}

export const ApiKeyCreateParamsScopesEnum = {
    Star: '*',
    Accountsread: 'accounts:read',
    Accountswrite: 'accounts:write',
    ApiKeysread: 'api_keys:read',
    ApiKeyswrite: 'api_keys:write',
    BalanceTransactionsread: 'balance_transactions:read',
    Chargesread: 'charges:read',
    Customersread: 'customers:read',
    Customerswrite: 'customers:write',
    Eventsread: 'events:read',
    PaymentIntentsread: 'payment_intents:read',
    PaymentIntentswrite: 'payment_intents:write',
    PaymentMethodsread: 'payment_methods:read',
    PaymentMethodswrite: 'payment_methods:write',
    Payoutsread: 'payouts:read',
    Payoutswrite: 'payouts:write',
    PlatformFeesread: 'platform_fees:read',
    ProductCodesread: 'product_codes:read',
    Refundsread: 'refunds:read',
    Refundswrite: 'refunds:write',
    Usersread: 'users:read',
    Userswrite: 'users:write',
    WebhookEndpointsread: 'webhook_endpoints:read',
    WebhookEndpointswrite: 'webhook_endpoints:write',
    ApplePayDomainsread: 'apple_pay_domains:read',
    ApplePayDomainswrite: 'apple_pay_domains:write',
    BankAccountsread: 'bank_accounts:read',
    BankAccountswrite: 'bank_accounts:write',
    Filesread: 'files:read',
    Fileswrite: 'files:write',
    UserInvitationsread: 'user_invitations:read',
    UserInvitationswrite: 'user_invitations:write',
    Subscriptionsread: 'subscriptions:read',
    Subscriptionswrite: 'subscriptions:write',
    Disputesread: 'disputes:read',
    PricingTemplatesread: 'pricing_templates:read',
    PricingTemplateswrite: 'pricing_templates:write'
} as const;

export type ApiKeyCreateParamsScopesEnum = typeof ApiKeyCreateParamsScopesEnum[keyof typeof ApiKeyCreateParamsScopesEnum];
export const ApiKeyCreateParamsTypeEnum = {
    Publishable: 'publishable',
    Secret: 'secret'
} as const;

export type ApiKeyCreateParamsTypeEnum = typeof ApiKeyCreateParamsTypeEnum[keyof typeof ApiKeyCreateParamsTypeEnum];

/**
 * 
 * @export
 * @interface ApiKeyUpdateParams
 */
export interface ApiKeyUpdateParams {
    /**
     * The list of scopes to define the access for this key. You may specify `[\'*\']` (default) to enable all scopes, except those that require explicit selection. Scopes are ignored for keys of type `publishable`.
     * @type {Array<string>}
     * @memberof ApiKeyUpdateParams
     */
    'scopes'?: Array<ApiKeyUpdateParamsScopesEnum>;
    /**
     * A brief name or description of the API that will help you remember what it is used for.
     * @type {string}
     * @memberof ApiKeyUpdateParams
     */
    'name'?: string;
}

export const ApiKeyUpdateParamsScopesEnum = {
    Star: '*',
    Accountsread: 'accounts:read',
    Accountswrite: 'accounts:write',
    ApiKeysread: 'api_keys:read',
    ApiKeyswrite: 'api_keys:write',
    BalanceTransactionsread: 'balance_transactions:read',
    Chargesread: 'charges:read',
    Customersread: 'customers:read',
    Customerswrite: 'customers:write',
    Eventsread: 'events:read',
    PaymentIntentsread: 'payment_intents:read',
    PaymentIntentswrite: 'payment_intents:write',
    PaymentMethodsread: 'payment_methods:read',
    PaymentMethodswrite: 'payment_methods:write',
    Payoutsread: 'payouts:read',
    Payoutswrite: 'payouts:write',
    PlatformFeesread: 'platform_fees:read',
    ProductCodesread: 'product_codes:read',
    Refundsread: 'refunds:read',
    Refundswrite: 'refunds:write',
    Usersread: 'users:read',
    Userswrite: 'users:write',
    WebhookEndpointsread: 'webhook_endpoints:read',
    WebhookEndpointswrite: 'webhook_endpoints:write',
    ApplePayDomainsread: 'apple_pay_domains:read',
    ApplePayDomainswrite: 'apple_pay_domains:write',
    BankAccountsread: 'bank_accounts:read',
    BankAccountswrite: 'bank_accounts:write',
    Filesread: 'files:read',
    Fileswrite: 'files:write',
    UserInvitationsread: 'user_invitations:read',
    UserInvitationswrite: 'user_invitations:write',
    Subscriptionsread: 'subscriptions:read',
    Subscriptionswrite: 'subscriptions:write',
    Disputesread: 'disputes:read',
    PricingTemplatesread: 'pricing_templates:read',
    PricingTemplateswrite: 'pricing_templates:write'
} as const;

export type ApiKeyUpdateParamsScopesEnum = typeof ApiKeyUpdateParamsScopesEnum[keyof typeof ApiKeyUpdateParamsScopesEnum];

/**
 * 
 * @export
 * @interface ApplePayDomain
 */
export interface ApplePayDomain {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof ApplePayDomain
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof ApplePayDomain
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof ApplePayDomain
     */
    'id': string;
    /**
     * The apple pay domain hostname.
     * @type {string}
     * @memberof ApplePayDomain
     */
    'hostname': string;
    /**
     * The ID of the Account associated with the domain.
     * @type {string}
     * @memberof ApplePayDomain
     */
    'account_id': string;
}
/**
 * 
 * @export
 * @interface ApplePayDomainCreateParams
 */
export interface ApplePayDomainCreateParams {
    /**
     * The domain hostname. Requires \'https\' protocol (e.g. \'https://example.com\')
     * @type {string}
     * @memberof ApplePayDomainCreateParams
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface BLEBankAccount
 */
export interface BLEBankAccount {
    /**
     * This is the bank account number
     * @type {string}
     * @memberof BLEBankAccount
     */
    'account_number': string;
    /**
     * The routing number, sort code, or other country-appropriate institution number for the bank account. For US bank accounts, this is required and should be the 9-digit ACH routing number, not the wire routing number. For CA bank accounts, combine the transit and institution numbers to create a full routing number (for example,  if `transit = 12345` and `institution = 678`, then `routing_number = 12345678`).
     * @type {string}
     * @memberof BLEBankAccount
     */
    'routing_number': string;
}
/**
 * 
 * @export
 * @interface BalanceTransaction
 */
export interface BalanceTransaction {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof BalanceTransaction
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof BalanceTransaction
     */
    'created_at': string;
    /**
     * Detailed breakdown of the fees paid for this transaction.
     * @type {Array<BalanceTransactionFeeDetail>}
     * @memberof BalanceTransaction
     */
    'fee_details': Array<BalanceTransactionFeeDetail>;
    /**
     * If the transaction’s net funds are available in the Tilled balance yet. Either `available` or `pending`.
     * @type {string}
     * @memberof BalanceTransaction
     */
    'status': BalanceTransactionStatusEnum;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof BalanceTransaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BalanceTransaction
     */
    'account_id': string;
    /**
     * Gross amount of the transaction, in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). Can be negative for certain transaction types (e.g. `payout`, `refund`).
     * @type {number}
     * @memberof BalanceTransaction
     */
    'amount': number;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof BalanceTransaction
     */
    'currency': BalanceTransactionCurrencyEnum;
    /**
     * An arbitrary string attached to the object. Often useful for displaying to users.
     * @type {string}
     * @memberof BalanceTransaction
     */
    'description'?: string;
    /**
     * Fees (in smallest currency unit) paid for this transaction.
     * @type {number}
     * @memberof BalanceTransaction
     */
    'fee': number;
    /**
     * Net amount of the transaction, in smallest currency unit.
     * @type {number}
     * @memberof BalanceTransaction
     */
    'net': number;
    /**
     * Tilled id to which this transaction is related
     * @type {string}
     * @memberof BalanceTransaction
     */
    'source_id': string;
    /**
     * Transaction type.
     * @type {string}
     * @memberof BalanceTransaction
     */
    'type': BalanceTransactionTypeEnum;
    /**
     * The date the transaction\'s net funds will become avaiable in the Tilled balance.
     * @type {string}
     * @memberof BalanceTransaction
     */
    'available_on': string;
}

export const BalanceTransactionStatusEnum = {
    Available: 'available',
    Pending: 'pending'
} as const;

export type BalanceTransactionStatusEnum = typeof BalanceTransactionStatusEnum[keyof typeof BalanceTransactionStatusEnum];
export const BalanceTransactionCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type BalanceTransactionCurrencyEnum = typeof BalanceTransactionCurrencyEnum[keyof typeof BalanceTransactionCurrencyEnum];
export const BalanceTransactionTypeEnum = {
    Charge: 'charge',
    ChargeFee: 'charge_fee',
    ChargeFailureRefund: 'charge_failure_refund',
    Dispute: 'dispute',
    DisputeWon: 'dispute_won',
    Refund: 'refund',
    RefundFee: 'refund_fee',
    RefundFailure: 'refund_failure',
    PlatformFee: 'platform_fee',
    PlatformFeeRefund: 'platform_fee_refund',
    TilledFee: 'tilled_fee',
    AccountFee: 'account_fee',
    PaymentMethodFee: 'payment_method_fee',
    Adjustment: 'adjustment',
    Commission: 'commission',
    Payout: 'payout',
    PayoutCancel: 'payout_cancel',
    PayoutFailure: 'payout_failure'
} as const;

export type BalanceTransactionTypeEnum = typeof BalanceTransactionTypeEnum[keyof typeof BalanceTransactionTypeEnum];

/**
 * 
 * @export
 * @interface BalanceTransactionFeeDetail
 */
export interface BalanceTransactionFeeDetail {
    /**
     * Amount of the fee, in currency minor units.
     * @type {number}
     * @memberof BalanceTransactionFeeDetail
     */
    'amount': number;
    /**
     * ID of the `partner` account that earned the fee, if any.
     * @type {string}
     * @memberof BalanceTransactionFeeDetail
     */
    'account_id'?: string;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof BalanceTransactionFeeDetail
     */
    'currency': BalanceTransactionFeeDetailCurrencyEnum;
    /**
     * An arbitrary string attached to the object. Often useful for displaying to users.
     * @type {string}
     * @memberof BalanceTransactionFeeDetail
     */
    'description'?: string;
    /**
     * Type of the fee, one of: `platform_fee`, `tilled_fee` or `tax`.
     * @type {string}
     * @memberof BalanceTransactionFeeDetail
     */
    'type': BalanceTransactionFeeDetailTypeEnum;
}

export const BalanceTransactionFeeDetailCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type BalanceTransactionFeeDetailCurrencyEnum = typeof BalanceTransactionFeeDetailCurrencyEnum[keyof typeof BalanceTransactionFeeDetailCurrencyEnum];
export const BalanceTransactionFeeDetailTypeEnum = {
    PlatformFee: 'platform_fee',
    TilledFee: 'tilled_fee',
    Tax: 'tax',
    ChargebackFee: 'chargeback_fee'
} as const;

export type BalanceTransactionFeeDetailTypeEnum = typeof BalanceTransactionFeeDetailTypeEnum[keyof typeof BalanceTransactionFeeDetailTypeEnum];

/**
 * 
 * @export
 * @interface BalanceTransactionTypeSummaries
 */
export interface BalanceTransactionTypeSummaries {
    /**
     * String indicating the unit of time to aggregate the summary of data.
     * @type {string}
     * @memberof BalanceTransactionTypeSummaries
     */
    'time_unit': BalanceTransactionTypeSummariesTimeUnitEnum;
    /**
     * All `balance_transaction.created_at` values included in this summary are greater than or equal to this value.
     * @type {string}
     * @memberof BalanceTransactionTypeSummaries
     */
    'start_time': string;
    /**
     * All `balance_transaction.created_at` values included in this summary are less than this value.
     * @type {string}
     * @memberof BalanceTransactionTypeSummaries
     */
    'end_time': string;
    /**
     * 
     * @type {Array<BalanceTransactionTypeSummary>}
     * @memberof BalanceTransactionTypeSummaries
     */
    'summary': Array<BalanceTransactionTypeSummary>;
}

export const BalanceTransactionTypeSummariesTimeUnitEnum = {
    Day: 'day',
    Month: 'month'
} as const;

export type BalanceTransactionTypeSummariesTimeUnitEnum = typeof BalanceTransactionTypeSummariesTimeUnitEnum[keyof typeof BalanceTransactionTypeSummariesTimeUnitEnum];

/**
 * 
 * @export
 * @interface BalanceTransactionTypeSummary
 */
export interface BalanceTransactionTypeSummary {
    /**
     * The transaction type of each of the balance transactions grouped in this summary.
     * @type {string}
     * @memberof BalanceTransactionTypeSummary
     */
    'type': BalanceTransactionTypeSummaryTypeEnum;
    /**
     * The currency of each of the balance transactions grouped in this summary.
     * @type {string}
     * @memberof BalanceTransactionTypeSummary
     */
    'currency': BalanceTransactionTypeSummaryCurrencyEnum;
    /**
     * The sum of the `amount` value on the balance transactions grouped in this summary.
     * @type {number}
     * @memberof BalanceTransactionTypeSummary
     */
    'amount': number;
    /**
     * The sum of the `fee` value on the balance transactions grouped in this summary.
     * @type {number}
     * @memberof BalanceTransactionTypeSummary
     */
    'fee': number;
    /**
     * The sum of the `net` value on the balance transactions grouped in this summary.
     * @type {number}
     * @memberof BalanceTransactionTypeSummary
     */
    'net': number;
    /**
     * Total number of balance transactions grouped in this summary.
     * @type {number}
     * @memberof BalanceTransactionTypeSummary
     */
    'count': number;
}

export const BalanceTransactionTypeSummaryTypeEnum = {
    Charge: 'charge',
    ChargeFee: 'charge_fee',
    ChargeFailureRefund: 'charge_failure_refund',
    Dispute: 'dispute',
    DisputeWon: 'dispute_won',
    Refund: 'refund',
    RefundFee: 'refund_fee',
    RefundFailure: 'refund_failure',
    PlatformFee: 'platform_fee',
    PlatformFeeRefund: 'platform_fee_refund',
    TilledFee: 'tilled_fee',
    AccountFee: 'account_fee',
    PaymentMethodFee: 'payment_method_fee',
    Adjustment: 'adjustment',
    Commission: 'commission',
    Payout: 'payout',
    PayoutCancel: 'payout_cancel',
    PayoutFailure: 'payout_failure'
} as const;

export type BalanceTransactionTypeSummaryTypeEnum = typeof BalanceTransactionTypeSummaryTypeEnum[keyof typeof BalanceTransactionTypeSummaryTypeEnum];
export const BalanceTransactionTypeSummaryCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type BalanceTransactionTypeSummaryCurrencyEnum = typeof BalanceTransactionTypeSummaryCurrencyEnum[keyof typeof BalanceTransactionTypeSummaryCurrencyEnum];

/**
 * 
 * @export
 * @interface BalanceTransactionsSummary
 */
export interface BalanceTransactionsSummary {
    /**
     * 
     * @type {BalanceTransactionsSummaryParameters}
     * @memberof BalanceTransactionsSummary
     */
    'parameters': BalanceTransactionsSummaryParameters;
    /**
     * The list of aggregate balance transaction data, grouped by unit of time, type, and currency.
     * @type {Array<BalanceTransactionTypeSummaries>}
     * @memberof BalanceTransactionsSummary
     */
    'data': Array<BalanceTransactionTypeSummaries>;
}
/**
 * The query parameters used to fetch these results, including default parameters.
 * @export
 * @interface BalanceTransactionsSummaryParameters
 */
export interface BalanceTransactionsSummaryParameters {
    /**
     * String indicating the unit of time to aggregate the summary of data.
     * @type {string}
     * @memberof BalanceTransactionsSummaryParameters
     */
    'time_unit'?: BalanceTransactionsSummaryParametersTimeUnitEnum;
    /**
     * Time Zone by which to aggregate the results.
     * @type {string}
     * @memberof BalanceTransactionsSummaryParameters
     */
    'time_zone'?: BalanceTransactionsSummaryParametersTimeZoneEnum;
    /**
     * Minimum `created_at` value to filter by (inclusive). Defaults to the beginning of the current month.
     * @type {string}
     * @memberof BalanceTransactionsSummaryParameters
     */
    'created_at_gte'?: string;
    /**
     * Maximum `created_at` value to filter by (inclusive). Defaults to midnight tonight.
     * @type {string}
     * @memberof BalanceTransactionsSummaryParameters
     */
    'created_at_lte'?: string;
    /**
     * An array containing specific balance transaction types. The data will be filtered to include only transactions with a matching type property.
     * @type {Array<string>}
     * @memberof BalanceTransactionsSummaryParameters
     */
    'types'?: Array<BalanceTransactionsSummaryParametersTypesEnum>;
    /**
     * Whether or not to include the results from any connected accounts.
     * @type {boolean}
     * @memberof BalanceTransactionsSummaryParameters
     */
    'include_connected_accounts'?: boolean;
}

export const BalanceTransactionsSummaryParametersTimeUnitEnum = {
    Day: 'day',
    Month: 'month'
} as const;

export type BalanceTransactionsSummaryParametersTimeUnitEnum = typeof BalanceTransactionsSummaryParametersTimeUnitEnum[keyof typeof BalanceTransactionsSummaryParametersTimeUnitEnum];
export const BalanceTransactionsSummaryParametersTimeZoneEnum = {
    AfricaAbidjan: 'Africa/Abidjan',
    AfricaAccra: 'Africa/Accra',
    AfricaAddisAbaba: 'Africa/Addis_Ababa',
    AfricaAlgiers: 'Africa/Algiers',
    AfricaAsmara: 'Africa/Asmara',
    AfricaAsmera: 'Africa/Asmera',
    AfricaBamako: 'Africa/Bamako',
    AfricaBangui: 'Africa/Bangui',
    AfricaBanjul: 'Africa/Banjul',
    AfricaBissau: 'Africa/Bissau',
    AfricaBlantyre: 'Africa/Blantyre',
    AfricaBrazzaville: 'Africa/Brazzaville',
    AfricaBujumbura: 'Africa/Bujumbura',
    AfricaCairo: 'Africa/Cairo',
    AfricaCasablanca: 'Africa/Casablanca',
    AfricaCeuta: 'Africa/Ceuta',
    AfricaConakry: 'Africa/Conakry',
    AfricaDakar: 'Africa/Dakar',
    AfricaDarEsSalaam: 'Africa/Dar_es_Salaam',
    AfricaDjibouti: 'Africa/Djibouti',
    AfricaDouala: 'Africa/Douala',
    AfricaElAaiun: 'Africa/El_Aaiun',
    AfricaFreetown: 'Africa/Freetown',
    AfricaGaborone: 'Africa/Gaborone',
    AfricaHarare: 'Africa/Harare',
    AfricaJohannesburg: 'Africa/Johannesburg',
    AfricaJuba: 'Africa/Juba',
    AfricaKampala: 'Africa/Kampala',
    AfricaKhartoum: 'Africa/Khartoum',
    AfricaKigali: 'Africa/Kigali',
    AfricaKinshasa: 'Africa/Kinshasa',
    AfricaLagos: 'Africa/Lagos',
    AfricaLibreville: 'Africa/Libreville',
    AfricaLome: 'Africa/Lome',
    AfricaLuanda: 'Africa/Luanda',
    AfricaLubumbashi: 'Africa/Lubumbashi',
    AfricaLusaka: 'Africa/Lusaka',
    AfricaMalabo: 'Africa/Malabo',
    AfricaMaputo: 'Africa/Maputo',
    AfricaMaseru: 'Africa/Maseru',
    AfricaMbabane: 'Africa/Mbabane',
    AfricaMogadishu: 'Africa/Mogadishu',
    AfricaMonrovia: 'Africa/Monrovia',
    AfricaNairobi: 'Africa/Nairobi',
    AfricaNdjamena: 'Africa/Ndjamena',
    AfricaNiamey: 'Africa/Niamey',
    AfricaNouakchott: 'Africa/Nouakchott',
    AfricaOuagadougou: 'Africa/Ouagadougou',
    AfricaPortoNovo: 'Africa/Porto-Novo',
    AfricaSaoTome: 'Africa/Sao_Tome',
    AfricaTimbuktu: 'Africa/Timbuktu',
    AfricaTripoli: 'Africa/Tripoli',
    AfricaTunis: 'Africa/Tunis',
    AfricaWindhoek: 'Africa/Windhoek',
    AmericaAdak: 'America/Adak',
    AmericaAnchorage: 'America/Anchorage',
    AmericaAnguilla: 'America/Anguilla',
    AmericaAntigua: 'America/Antigua',
    AmericaAraguaina: 'America/Araguaina',
    AmericaArgentinaBuenosAires: 'America/Argentina/Buenos_Aires',
    AmericaArgentinaCatamarca: 'America/Argentina/Catamarca',
    AmericaArgentinaComodRivadavia: 'America/Argentina/ComodRivadavia',
    AmericaArgentinaCordoba: 'America/Argentina/Cordoba',
    AmericaArgentinaJujuy: 'America/Argentina/Jujuy',
    AmericaArgentinaLaRioja: 'America/Argentina/La_Rioja',
    AmericaArgentinaMendoza: 'America/Argentina/Mendoza',
    AmericaArgentinaRioGallegos: 'America/Argentina/Rio_Gallegos',
    AmericaArgentinaSalta: 'America/Argentina/Salta',
    AmericaArgentinaSanJuan: 'America/Argentina/San_Juan',
    AmericaArgentinaSanLuis: 'America/Argentina/San_Luis',
    AmericaArgentinaTucuman: 'America/Argentina/Tucuman',
    AmericaArgentinaUshuaia: 'America/Argentina/Ushuaia',
    AmericaAruba: 'America/Aruba',
    AmericaAsuncion: 'America/Asuncion',
    AmericaAtikokan: 'America/Atikokan',
    AmericaAtka: 'America/Atka',
    AmericaBahia: 'America/Bahia',
    AmericaBahiaBanderas: 'America/Bahia_Banderas',
    AmericaBarbados: 'America/Barbados',
    AmericaBelem: 'America/Belem',
    AmericaBelize: 'America/Belize',
    AmericaBlancSablon: 'America/Blanc-Sablon',
    AmericaBoaVista: 'America/Boa_Vista',
    AmericaBogota: 'America/Bogota',
    AmericaBoise: 'America/Boise',
    AmericaBuenosAires: 'America/Buenos_Aires',
    AmericaCambridgeBay: 'America/Cambridge_Bay',
    AmericaCampoGrande: 'America/Campo_Grande',
    AmericaCancun: 'America/Cancun',
    AmericaCaracas: 'America/Caracas',
    AmericaCatamarca: 'America/Catamarca',
    AmericaCayenne: 'America/Cayenne',
    AmericaCayman: 'America/Cayman',
    AmericaChicago: 'America/Chicago',
    AmericaChihuahua: 'America/Chihuahua',
    AmericaCoralHarbour: 'America/Coral_Harbour',
    AmericaCordoba: 'America/Cordoba',
    AmericaCostaRica: 'America/Costa_Rica',
    AmericaCreston: 'America/Creston',
    AmericaCuiaba: 'America/Cuiaba',
    AmericaCuracao: 'America/Curacao',
    AmericaDanmarkshavn: 'America/Danmarkshavn',
    AmericaDawson: 'America/Dawson',
    AmericaDawsonCreek: 'America/Dawson_Creek',
    AmericaDenver: 'America/Denver',
    AmericaDetroit: 'America/Detroit',
    AmericaDominica: 'America/Dominica',
    AmericaEdmonton: 'America/Edmonton',
    AmericaEirunepe: 'America/Eirunepe',
    AmericaElSalvador: 'America/El_Salvador',
    AmericaEnsenada: 'America/Ensenada',
    AmericaFortWayne: 'America/Fort_Wayne',
    AmericaFortaleza: 'America/Fortaleza',
    AmericaGlaceBay: 'America/Glace_Bay',
    AmericaGodthab: 'America/Godthab',
    AmericaGooseBay: 'America/Goose_Bay',
    AmericaGrandTurk: 'America/Grand_Turk',
    AmericaGrenada: 'America/Grenada',
    AmericaGuadeloupe: 'America/Guadeloupe',
    AmericaGuatemala: 'America/Guatemala',
    AmericaGuayaquil: 'America/Guayaquil',
    AmericaGuyana: 'America/Guyana',
    AmericaHalifax: 'America/Halifax',
    AmericaHavana: 'America/Havana',
    AmericaHermosillo: 'America/Hermosillo',
    AmericaIndianaIndianapolis: 'America/Indiana/Indianapolis',
    AmericaIndianaKnox: 'America/Indiana/Knox',
    AmericaIndianaMarengo: 'America/Indiana/Marengo',
    AmericaIndianaPetersburg: 'America/Indiana/Petersburg',
    AmericaIndianaTellCity: 'America/Indiana/Tell_City',
    AmericaIndianaVevay: 'America/Indiana/Vevay',
    AmericaIndianaVincennes: 'America/Indiana/Vincennes',
    AmericaIndianaWinamac: 'America/Indiana/Winamac',
    AmericaIndianapolis: 'America/Indianapolis',
    AmericaInuvik: 'America/Inuvik',
    AmericaIqaluit: 'America/Iqaluit',
    AmericaJamaica: 'America/Jamaica',
    AmericaJujuy: 'America/Jujuy',
    AmericaJuneau: 'America/Juneau',
    AmericaKentuckyLouisville: 'America/Kentucky/Louisville',
    AmericaKentuckyMonticello: 'America/Kentucky/Monticello',
    AmericaKnoxIn: 'America/Knox_IN',
    AmericaKralendijk: 'America/Kralendijk',
    AmericaLaPaz: 'America/La_Paz',
    AmericaLima: 'America/Lima',
    AmericaLosAngeles: 'America/Los_Angeles',
    AmericaLouisville: 'America/Louisville',
    AmericaLowerPrinces: 'America/Lower_Princes',
    AmericaMaceio: 'America/Maceio',
    AmericaManagua: 'America/Managua',
    AmericaManaus: 'America/Manaus',
    AmericaMarigot: 'America/Marigot',
    AmericaMartinique: 'America/Martinique',
    AmericaMatamoros: 'America/Matamoros',
    AmericaMazatlan: 'America/Mazatlan',
    AmericaMendoza: 'America/Mendoza',
    AmericaMenominee: 'America/Menominee',
    AmericaMerida: 'America/Merida',
    AmericaMetlakatla: 'America/Metlakatla',
    AmericaMexicoCity: 'America/Mexico_City',
    AmericaMiquelon: 'America/Miquelon',
    AmericaMoncton: 'America/Moncton',
    AmericaMonterrey: 'America/Monterrey',
    AmericaMontevideo: 'America/Montevideo',
    AmericaMontreal: 'America/Montreal',
    AmericaMontserrat: 'America/Montserrat',
    AmericaNassau: 'America/Nassau',
    AmericaNewYork: 'America/New_York',
    AmericaNipigon: 'America/Nipigon',
    AmericaNome: 'America/Nome',
    AmericaNoronha: 'America/Noronha',
    AmericaNorthDakotaBeulah: 'America/North_Dakota/Beulah',
    AmericaNorthDakotaCenter: 'America/North_Dakota/Center',
    AmericaNorthDakotaNewSalem: 'America/North_Dakota/New_Salem',
    AmericaOjinaga: 'America/Ojinaga',
    AmericaPanama: 'America/Panama',
    AmericaPangnirtung: 'America/Pangnirtung',
    AmericaParamaribo: 'America/Paramaribo',
    AmericaPhoenix: 'America/Phoenix',
    AmericaPortAuPrince: 'America/Port-au-Prince',
    AmericaPortOfSpain: 'America/Port_of_Spain',
    AmericaPortoAcre: 'America/Porto_Acre',
    AmericaPortoVelho: 'America/Porto_Velho',
    AmericaPuertoRico: 'America/Puerto_Rico',
    AmericaRainyRiver: 'America/Rainy_River',
    AmericaRankinInlet: 'America/Rankin_Inlet',
    AmericaRecife: 'America/Recife',
    AmericaRegina: 'America/Regina',
    AmericaResolute: 'America/Resolute',
    AmericaRioBranco: 'America/Rio_Branco',
    AmericaRosario: 'America/Rosario',
    AmericaSantaIsabel: 'America/Santa_Isabel',
    AmericaSantarem: 'America/Santarem',
    AmericaSantiago: 'America/Santiago',
    AmericaSantoDomingo: 'America/Santo_Domingo',
    AmericaSaoPaulo: 'America/Sao_Paulo',
    AmericaScoresbysund: 'America/Scoresbysund',
    AmericaShiprock: 'America/Shiprock',
    AmericaSitka: 'America/Sitka',
    AmericaStBarthelemy: 'America/St_Barthelemy',
    AmericaStJohns: 'America/St_Johns',
    AmericaStKitts: 'America/St_Kitts',
    AmericaStLucia: 'America/St_Lucia',
    AmericaStThomas: 'America/St_Thomas',
    AmericaStVincent: 'America/St_Vincent',
    AmericaSwiftCurrent: 'America/Swift_Current',
    AmericaTegucigalpa: 'America/Tegucigalpa',
    AmericaThule: 'America/Thule',
    AmericaThunderBay: 'America/Thunder_Bay',
    AmericaTijuana: 'America/Tijuana',
    AmericaToronto: 'America/Toronto',
    AmericaTortola: 'America/Tortola',
    AmericaVancouver: 'America/Vancouver',
    AmericaVirgin: 'America/Virgin',
    AmericaWhitehorse: 'America/Whitehorse',
    AmericaWinnipeg: 'America/Winnipeg',
    AmericaYakutat: 'America/Yakutat',
    AmericaYellowknife: 'America/Yellowknife',
    AntarcticaCasey: 'Antarctica/Casey',
    AntarcticaDavis: 'Antarctica/Davis',
    AntarcticaDumontDUrville: 'Antarctica/DumontDUrville',
    AntarcticaMacquarie: 'Antarctica/Macquarie',
    AntarcticaMawson: 'Antarctica/Mawson',
    AntarcticaMcMurdo: 'Antarctica/McMurdo',
    AntarcticaPalmer: 'Antarctica/Palmer',
    AntarcticaRothera: 'Antarctica/Rothera',
    AntarcticaSouthPole: 'Antarctica/South_Pole',
    AntarcticaSyowa: 'Antarctica/Syowa',
    AntarcticaTroll: 'Antarctica/Troll',
    AntarcticaVostok: 'Antarctica/Vostok',
    ArcticLongyearbyen: 'Arctic/Longyearbyen',
    AsiaAden: 'Asia/Aden',
    AsiaAlmaty: 'Asia/Almaty',
    AsiaAmman: 'Asia/Amman',
    AsiaAnadyr: 'Asia/Anadyr',
    AsiaAqtau: 'Asia/Aqtau',
    AsiaAqtobe: 'Asia/Aqtobe',
    AsiaAshgabat: 'Asia/Ashgabat',
    AsiaAshkhabad: 'Asia/Ashkhabad',
    AsiaBaghdad: 'Asia/Baghdad',
    AsiaBahrain: 'Asia/Bahrain',
    AsiaBaku: 'Asia/Baku',
    AsiaBangkok: 'Asia/Bangkok',
    AsiaBeirut: 'Asia/Beirut',
    AsiaBishkek: 'Asia/Bishkek',
    AsiaBrunei: 'Asia/Brunei',
    AsiaCalcutta: 'Asia/Calcutta',
    AsiaChita: 'Asia/Chita',
    AsiaChoibalsan: 'Asia/Choibalsan',
    AsiaChongqing: 'Asia/Chongqing',
    AsiaChungking: 'Asia/Chungking',
    AsiaColombo: 'Asia/Colombo',
    AsiaDacca: 'Asia/Dacca',
    AsiaDamascus: 'Asia/Damascus',
    AsiaDhaka: 'Asia/Dhaka',
    AsiaDili: 'Asia/Dili',
    AsiaDubai: 'Asia/Dubai',
    AsiaDushanbe: 'Asia/Dushanbe',
    AsiaGaza: 'Asia/Gaza',
    AsiaHarbin: 'Asia/Harbin',
    AsiaHebron: 'Asia/Hebron',
    AsiaHoChiMinh: 'Asia/Ho_Chi_Minh',
    AsiaHongKong: 'Asia/Hong_Kong',
    AsiaHovd: 'Asia/Hovd',
    AsiaIrkutsk: 'Asia/Irkutsk',
    AsiaIstanbul: 'Asia/Istanbul',
    AsiaJakarta: 'Asia/Jakarta',
    AsiaJayapura: 'Asia/Jayapura',
    AsiaJerusalem: 'Asia/Jerusalem',
    AsiaKabul: 'Asia/Kabul',
    AsiaKamchatka: 'Asia/Kamchatka',
    AsiaKarachi: 'Asia/Karachi',
    AsiaKashgar: 'Asia/Kashgar',
    AsiaKathmandu: 'Asia/Kathmandu',
    AsiaKatmandu: 'Asia/Katmandu',
    AsiaKhandyga: 'Asia/Khandyga',
    AsiaKolkata: 'Asia/Kolkata',
    AsiaKrasnoyarsk: 'Asia/Krasnoyarsk',
    AsiaKualaLumpur: 'Asia/Kuala_Lumpur',
    AsiaKuching: 'Asia/Kuching',
    AsiaKuwait: 'Asia/Kuwait',
    AsiaMacao: 'Asia/Macao',
    AsiaMacau: 'Asia/Macau',
    AsiaMagadan: 'Asia/Magadan',
    AsiaMakassar: 'Asia/Makassar',
    AsiaManila: 'Asia/Manila',
    AsiaMuscat: 'Asia/Muscat',
    AsiaNicosia: 'Asia/Nicosia',
    AsiaNovokuznetsk: 'Asia/Novokuznetsk',
    AsiaNovosibirsk: 'Asia/Novosibirsk',
    AsiaOmsk: 'Asia/Omsk',
    AsiaOral: 'Asia/Oral',
    AsiaPhnomPenh: 'Asia/Phnom_Penh',
    AsiaPontianak: 'Asia/Pontianak',
    AsiaPyongyang: 'Asia/Pyongyang',
    AsiaQatar: 'Asia/Qatar',
    AsiaQyzylorda: 'Asia/Qyzylorda',
    AsiaRangoon: 'Asia/Rangoon',
    AsiaRiyadh: 'Asia/Riyadh',
    AsiaSaigon: 'Asia/Saigon',
    AsiaSakhalin: 'Asia/Sakhalin',
    AsiaSamarkand: 'Asia/Samarkand',
    AsiaSeoul: 'Asia/Seoul',
    AsiaShanghai: 'Asia/Shanghai',
    AsiaSingapore: 'Asia/Singapore',
    AsiaSrednekolymsk: 'Asia/Srednekolymsk',
    AsiaTaipei: 'Asia/Taipei',
    AsiaTashkent: 'Asia/Tashkent',
    AsiaTbilisi: 'Asia/Tbilisi',
    AsiaTehran: 'Asia/Tehran',
    AsiaTelAviv: 'Asia/Tel_Aviv',
    AsiaThimbu: 'Asia/Thimbu',
    AsiaThimphu: 'Asia/Thimphu',
    AsiaTokyo: 'Asia/Tokyo',
    AsiaUjungPandang: 'Asia/Ujung_Pandang',
    AsiaUlaanbaatar: 'Asia/Ulaanbaatar',
    AsiaUlanBator: 'Asia/Ulan_Bator',
    AsiaUrumqi: 'Asia/Urumqi',
    AsiaUstNera: 'Asia/Ust-Nera',
    AsiaVientiane: 'Asia/Vientiane',
    AsiaVladivostok: 'Asia/Vladivostok',
    AsiaYakutsk: 'Asia/Yakutsk',
    AsiaYekaterinburg: 'Asia/Yekaterinburg',
    AsiaYerevan: 'Asia/Yerevan',
    AtlanticAzores: 'Atlantic/Azores',
    AtlanticBermuda: 'Atlantic/Bermuda',
    AtlanticCanary: 'Atlantic/Canary',
    AtlanticCapeVerde: 'Atlantic/Cape_Verde',
    AtlanticFaeroe: 'Atlantic/Faeroe',
    AtlanticFaroe: 'Atlantic/Faroe',
    AtlanticJanMayen: 'Atlantic/Jan_Mayen',
    AtlanticMadeira: 'Atlantic/Madeira',
    AtlanticReykjavik: 'Atlantic/Reykjavik',
    AtlanticSouthGeorgia: 'Atlantic/South_Georgia',
    AtlanticStHelena: 'Atlantic/St_Helena',
    AtlanticStanley: 'Atlantic/Stanley',
    AustraliaAct: 'Australia/ACT',
    AustraliaAdelaide: 'Australia/Adelaide',
    AustraliaBrisbane: 'Australia/Brisbane',
    AustraliaBrokenHill: 'Australia/Broken_Hill',
    AustraliaCanberra: 'Australia/Canberra',
    AustraliaCurrie: 'Australia/Currie',
    AustraliaDarwin: 'Australia/Darwin',
    AustraliaEucla: 'Australia/Eucla',
    AustraliaHobart: 'Australia/Hobart',
    AustraliaLhi: 'Australia/LHI',
    AustraliaLindeman: 'Australia/Lindeman',
    AustraliaLordHowe: 'Australia/Lord_Howe',
    AustraliaMelbourne: 'Australia/Melbourne',
    AustraliaNsw: 'Australia/NSW',
    AustraliaNorth: 'Australia/North',
    AustraliaPerth: 'Australia/Perth',
    AustraliaQueensland: 'Australia/Queensland',
    AustraliaSouth: 'Australia/South',
    AustraliaSydney: 'Australia/Sydney',
    AustraliaTasmania: 'Australia/Tasmania',
    AustraliaVictoria: 'Australia/Victoria',
    AustraliaWest: 'Australia/West',
    AustraliaYancowinna: 'Australia/Yancowinna',
    BrazilAcre: 'Brazil/Acre',
    BrazilDeNoronha: 'Brazil/DeNoronha',
    BrazilEast: 'Brazil/East',
    BrazilWest: 'Brazil/West',
    CanadaAtlantic: 'Canada/Atlantic',
    CanadaCentral: 'Canada/Central',
    CanadaEastSaskatchewan: 'Canada/East-Saskatchewan',
    CanadaEastern: 'Canada/Eastern',
    CanadaMountain: 'Canada/Mountain',
    CanadaNewfoundland: 'Canada/Newfoundland',
    CanadaPacific: 'Canada/Pacific',
    CanadaSaskatchewan: 'Canada/Saskatchewan',
    CanadaYukon: 'Canada/Yukon',
    ChileContinental: 'Chile/Continental',
    ChileEasterIsland: 'Chile/EasterIsland',
    EtcGmt: 'Etc/GMT',
    EtcGmt0: 'Etc/GMT+0',
    EtcGmt1: 'Etc/GMT+1',
    EtcGmt10: 'Etc/GMT+10',
    EtcGmt11: 'Etc/GMT+11',
    EtcGmt12: 'Etc/GMT+12',
    EtcGmt2: 'Etc/GMT+2',
    EtcGmt3: 'Etc/GMT+3',
    EtcGmt4: 'Etc/GMT+4',
    EtcGmt5: 'Etc/GMT+5',
    EtcGmt6: 'Etc/GMT+6',
    EtcGmt7: 'Etc/GMT+7',
    EtcGmt8: 'Etc/GMT+8',
    EtcGmt9: 'Etc/GMT+9',
    EtcGmt13: 'Etc/GMT-13',
    EtcGmt14: 'Etc/GMT-14',
    EtcGreenwich: 'Etc/Greenwich',
    EtcUct: 'Etc/UCT',
    EtcUtc: 'Etc/UTC',
    EtcUniversal: 'Etc/Universal',
    EtcZulu: 'Etc/Zulu',
    EuropeAmsterdam: 'Europe/Amsterdam',
    EuropeAndorra: 'Europe/Andorra',
    EuropeAthens: 'Europe/Athens',
    EuropeBelfast: 'Europe/Belfast',
    EuropeBelgrade: 'Europe/Belgrade',
    EuropeBerlin: 'Europe/Berlin',
    EuropeBratislava: 'Europe/Bratislava',
    EuropeBrussels: 'Europe/Brussels',
    EuropeBucharest: 'Europe/Bucharest',
    EuropeBudapest: 'Europe/Budapest',
    EuropeBusingen: 'Europe/Busingen',
    EuropeChisinau: 'Europe/Chisinau',
    EuropeCopenhagen: 'Europe/Copenhagen',
    EuropeDublin: 'Europe/Dublin',
    EuropeGibraltar: 'Europe/Gibraltar',
    EuropeGuernsey: 'Europe/Guernsey',
    EuropeHelsinki: 'Europe/Helsinki',
    EuropeIsleOfMan: 'Europe/Isle_of_Man',
    EuropeIstanbul: 'Europe/Istanbul',
    EuropeJersey: 'Europe/Jersey',
    EuropeKaliningrad: 'Europe/Kaliningrad',
    EuropeKiev: 'Europe/Kiev',
    EuropeLisbon: 'Europe/Lisbon',
    EuropeLjubljana: 'Europe/Ljubljana',
    EuropeLondon: 'Europe/London',
    EuropeLuxembourg: 'Europe/Luxembourg',
    EuropeMadrid: 'Europe/Madrid',
    EuropeMalta: 'Europe/Malta',
    EuropeMariehamn: 'Europe/Mariehamn',
    EuropeMinsk: 'Europe/Minsk',
    EuropeMonaco: 'Europe/Monaco',
    EuropeMoscow: 'Europe/Moscow',
    EuropeNicosia: 'Europe/Nicosia',
    EuropeOslo: 'Europe/Oslo',
    EuropeParis: 'Europe/Paris',
    EuropePodgorica: 'Europe/Podgorica',
    EuropePrague: 'Europe/Prague',
    EuropeRiga: 'Europe/Riga',
    EuropeRome: 'Europe/Rome',
    EuropeSamara: 'Europe/Samara',
    EuropeSanMarino: 'Europe/San_Marino',
    EuropeSarajevo: 'Europe/Sarajevo',
    EuropeSimferopol: 'Europe/Simferopol',
    EuropeSkopje: 'Europe/Skopje',
    EuropeSofia: 'Europe/Sofia',
    EuropeStockholm: 'Europe/Stockholm',
    EuropeTallinn: 'Europe/Tallinn',
    EuropeTirane: 'Europe/Tirane',
    EuropeTiraspol: 'Europe/Tiraspol',
    EuropeUzhgorod: 'Europe/Uzhgorod',
    EuropeVaduz: 'Europe/Vaduz',
    EuropeVatican: 'Europe/Vatican',
    EuropeVienna: 'Europe/Vienna',
    EuropeVilnius: 'Europe/Vilnius',
    EuropeVolgograd: 'Europe/Volgograd',
    EuropeWarsaw: 'Europe/Warsaw',
    EuropeZagreb: 'Europe/Zagreb',
    EuropeZaporozhye: 'Europe/Zaporozhye',
    EuropeZurich: 'Europe/Zurich',
    IndianAntananarivo: 'Indian/Antananarivo',
    IndianChagos: 'Indian/Chagos',
    IndianChristmas: 'Indian/Christmas',
    IndianCocos: 'Indian/Cocos',
    IndianComoro: 'Indian/Comoro',
    IndianKerguelen: 'Indian/Kerguelen',
    IndianMahe: 'Indian/Mahe',
    IndianMaldives: 'Indian/Maldives',
    IndianMauritius: 'Indian/Mauritius',
    IndianMayotte: 'Indian/Mayotte',
    IndianReunion: 'Indian/Reunion',
    MexicoBajaNorte: 'Mexico/BajaNorte',
    MexicoBajaSur: 'Mexico/BajaSur',
    MexicoGeneral: 'Mexico/General',
    PacificApia: 'Pacific/Apia',
    PacificAuckland: 'Pacific/Auckland',
    PacificChatham: 'Pacific/Chatham',
    PacificChuuk: 'Pacific/Chuuk',
    PacificEaster: 'Pacific/Easter',
    PacificEfate: 'Pacific/Efate',
    PacificEnderbury: 'Pacific/Enderbury',
    PacificFakaofo: 'Pacific/Fakaofo',
    PacificFiji: 'Pacific/Fiji',
    PacificFunafuti: 'Pacific/Funafuti',
    PacificGalapagos: 'Pacific/Galapagos',
    PacificGambier: 'Pacific/Gambier',
    PacificGuadalcanal: 'Pacific/Guadalcanal',
    PacificGuam: 'Pacific/Guam',
    PacificHonolulu: 'Pacific/Honolulu',
    PacificJohnston: 'Pacific/Johnston',
    PacificKiritimati: 'Pacific/Kiritimati',
    PacificKosrae: 'Pacific/Kosrae',
    PacificKwajalein: 'Pacific/Kwajalein',
    PacificMajuro: 'Pacific/Majuro',
    PacificMarquesas: 'Pacific/Marquesas',
    PacificMidway: 'Pacific/Midway',
    PacificNauru: 'Pacific/Nauru',
    PacificNiue: 'Pacific/Niue',
    PacificNorfolk: 'Pacific/Norfolk',
    PacificNoumea: 'Pacific/Noumea',
    PacificPagoPago: 'Pacific/Pago_Pago',
    PacificPalau: 'Pacific/Palau',
    PacificPitcairn: 'Pacific/Pitcairn',
    PacificPohnpei: 'Pacific/Pohnpei',
    PacificPonape: 'Pacific/Ponape',
    PacificPortMoresby: 'Pacific/Port_Moresby',
    PacificRarotonga: 'Pacific/Rarotonga',
    PacificSaipan: 'Pacific/Saipan',
    PacificSamoa: 'Pacific/Samoa',
    PacificTahiti: 'Pacific/Tahiti',
    PacificTarawa: 'Pacific/Tarawa',
    PacificTongatapu: 'Pacific/Tongatapu',
    PacificTruk: 'Pacific/Truk',
    PacificWake: 'Pacific/Wake',
    PacificWallis: 'Pacific/Wallis',
    PacificYap: 'Pacific/Yap'
} as const;

export type BalanceTransactionsSummaryParametersTimeZoneEnum = typeof BalanceTransactionsSummaryParametersTimeZoneEnum[keyof typeof BalanceTransactionsSummaryParametersTimeZoneEnum];
export const BalanceTransactionsSummaryParametersTypesEnum = {
    Charge: 'charge',
    ChargeFee: 'charge_fee',
    ChargeFailureRefund: 'charge_failure_refund',
    Dispute: 'dispute',
    DisputeWon: 'dispute_won',
    Refund: 'refund',
    RefundFee: 'refund_fee',
    RefundFailure: 'refund_failure',
    PlatformFee: 'platform_fee',
    PlatformFeeRefund: 'platform_fee_refund',
    TilledFee: 'tilled_fee',
    AccountFee: 'account_fee',
    PaymentMethodFee: 'payment_method_fee',
    Adjustment: 'adjustment',
    Commission: 'commission',
    Payout: 'payout',
    PayoutCancel: 'payout_cancel',
    PayoutFailure: 'payout_failure'
} as const;

export type BalanceTransactionsSummaryParametersTypesEnum = typeof BalanceTransactionsSummaryParametersTypesEnum[keyof typeof BalanceTransactionsSummaryParametersTypesEnum];

/**
 * 
 * @export
 * @interface BalanceTransactionsSummaryQueryParams
 */
export interface BalanceTransactionsSummaryQueryParams {
    /**
     * String indicating the unit of time to aggregate the summary of data.
     * @type {string}
     * @memberof BalanceTransactionsSummaryQueryParams
     */
    'time_unit'?: BalanceTransactionsSummaryQueryParamsTimeUnitEnum;
    /**
     * Time Zone by which to aggregate the results.
     * @type {string}
     * @memberof BalanceTransactionsSummaryQueryParams
     */
    'time_zone'?: BalanceTransactionsSummaryQueryParamsTimeZoneEnum;
    /**
     * Minimum `created_at` value to filter by (inclusive). Defaults to the beginning of the current month.
     * @type {string}
     * @memberof BalanceTransactionsSummaryQueryParams
     */
    'created_at_gte'?: string;
    /**
     * Maximum `created_at` value to filter by (inclusive). Defaults to midnight tonight.
     * @type {string}
     * @memberof BalanceTransactionsSummaryQueryParams
     */
    'created_at_lte'?: string;
    /**
     * An array containing specific balance transaction types. The data will be filtered to include only transactions with a matching type property.
     * @type {Array<string>}
     * @memberof BalanceTransactionsSummaryQueryParams
     */
    'types'?: Array<BalanceTransactionsSummaryQueryParamsTypesEnum>;
    /**
     * Whether or not to include the results from any connected accounts.
     * @type {boolean}
     * @memberof BalanceTransactionsSummaryQueryParams
     */
    'include_connected_accounts'?: boolean;
}

export const BalanceTransactionsSummaryQueryParamsTimeUnitEnum = {
    Day: 'day',
    Month: 'month'
} as const;

export type BalanceTransactionsSummaryQueryParamsTimeUnitEnum = typeof BalanceTransactionsSummaryQueryParamsTimeUnitEnum[keyof typeof BalanceTransactionsSummaryQueryParamsTimeUnitEnum];
export const BalanceTransactionsSummaryQueryParamsTimeZoneEnum = {
    AfricaAbidjan: 'Africa/Abidjan',
    AfricaAccra: 'Africa/Accra',
    AfricaAddisAbaba: 'Africa/Addis_Ababa',
    AfricaAlgiers: 'Africa/Algiers',
    AfricaAsmara: 'Africa/Asmara',
    AfricaAsmera: 'Africa/Asmera',
    AfricaBamako: 'Africa/Bamako',
    AfricaBangui: 'Africa/Bangui',
    AfricaBanjul: 'Africa/Banjul',
    AfricaBissau: 'Africa/Bissau',
    AfricaBlantyre: 'Africa/Blantyre',
    AfricaBrazzaville: 'Africa/Brazzaville',
    AfricaBujumbura: 'Africa/Bujumbura',
    AfricaCairo: 'Africa/Cairo',
    AfricaCasablanca: 'Africa/Casablanca',
    AfricaCeuta: 'Africa/Ceuta',
    AfricaConakry: 'Africa/Conakry',
    AfricaDakar: 'Africa/Dakar',
    AfricaDarEsSalaam: 'Africa/Dar_es_Salaam',
    AfricaDjibouti: 'Africa/Djibouti',
    AfricaDouala: 'Africa/Douala',
    AfricaElAaiun: 'Africa/El_Aaiun',
    AfricaFreetown: 'Africa/Freetown',
    AfricaGaborone: 'Africa/Gaborone',
    AfricaHarare: 'Africa/Harare',
    AfricaJohannesburg: 'Africa/Johannesburg',
    AfricaJuba: 'Africa/Juba',
    AfricaKampala: 'Africa/Kampala',
    AfricaKhartoum: 'Africa/Khartoum',
    AfricaKigali: 'Africa/Kigali',
    AfricaKinshasa: 'Africa/Kinshasa',
    AfricaLagos: 'Africa/Lagos',
    AfricaLibreville: 'Africa/Libreville',
    AfricaLome: 'Africa/Lome',
    AfricaLuanda: 'Africa/Luanda',
    AfricaLubumbashi: 'Africa/Lubumbashi',
    AfricaLusaka: 'Africa/Lusaka',
    AfricaMalabo: 'Africa/Malabo',
    AfricaMaputo: 'Africa/Maputo',
    AfricaMaseru: 'Africa/Maseru',
    AfricaMbabane: 'Africa/Mbabane',
    AfricaMogadishu: 'Africa/Mogadishu',
    AfricaMonrovia: 'Africa/Monrovia',
    AfricaNairobi: 'Africa/Nairobi',
    AfricaNdjamena: 'Africa/Ndjamena',
    AfricaNiamey: 'Africa/Niamey',
    AfricaNouakchott: 'Africa/Nouakchott',
    AfricaOuagadougou: 'Africa/Ouagadougou',
    AfricaPortoNovo: 'Africa/Porto-Novo',
    AfricaSaoTome: 'Africa/Sao_Tome',
    AfricaTimbuktu: 'Africa/Timbuktu',
    AfricaTripoli: 'Africa/Tripoli',
    AfricaTunis: 'Africa/Tunis',
    AfricaWindhoek: 'Africa/Windhoek',
    AmericaAdak: 'America/Adak',
    AmericaAnchorage: 'America/Anchorage',
    AmericaAnguilla: 'America/Anguilla',
    AmericaAntigua: 'America/Antigua',
    AmericaAraguaina: 'America/Araguaina',
    AmericaArgentinaBuenosAires: 'America/Argentina/Buenos_Aires',
    AmericaArgentinaCatamarca: 'America/Argentina/Catamarca',
    AmericaArgentinaComodRivadavia: 'America/Argentina/ComodRivadavia',
    AmericaArgentinaCordoba: 'America/Argentina/Cordoba',
    AmericaArgentinaJujuy: 'America/Argentina/Jujuy',
    AmericaArgentinaLaRioja: 'America/Argentina/La_Rioja',
    AmericaArgentinaMendoza: 'America/Argentina/Mendoza',
    AmericaArgentinaRioGallegos: 'America/Argentina/Rio_Gallegos',
    AmericaArgentinaSalta: 'America/Argentina/Salta',
    AmericaArgentinaSanJuan: 'America/Argentina/San_Juan',
    AmericaArgentinaSanLuis: 'America/Argentina/San_Luis',
    AmericaArgentinaTucuman: 'America/Argentina/Tucuman',
    AmericaArgentinaUshuaia: 'America/Argentina/Ushuaia',
    AmericaAruba: 'America/Aruba',
    AmericaAsuncion: 'America/Asuncion',
    AmericaAtikokan: 'America/Atikokan',
    AmericaAtka: 'America/Atka',
    AmericaBahia: 'America/Bahia',
    AmericaBahiaBanderas: 'America/Bahia_Banderas',
    AmericaBarbados: 'America/Barbados',
    AmericaBelem: 'America/Belem',
    AmericaBelize: 'America/Belize',
    AmericaBlancSablon: 'America/Blanc-Sablon',
    AmericaBoaVista: 'America/Boa_Vista',
    AmericaBogota: 'America/Bogota',
    AmericaBoise: 'America/Boise',
    AmericaBuenosAires: 'America/Buenos_Aires',
    AmericaCambridgeBay: 'America/Cambridge_Bay',
    AmericaCampoGrande: 'America/Campo_Grande',
    AmericaCancun: 'America/Cancun',
    AmericaCaracas: 'America/Caracas',
    AmericaCatamarca: 'America/Catamarca',
    AmericaCayenne: 'America/Cayenne',
    AmericaCayman: 'America/Cayman',
    AmericaChicago: 'America/Chicago',
    AmericaChihuahua: 'America/Chihuahua',
    AmericaCoralHarbour: 'America/Coral_Harbour',
    AmericaCordoba: 'America/Cordoba',
    AmericaCostaRica: 'America/Costa_Rica',
    AmericaCreston: 'America/Creston',
    AmericaCuiaba: 'America/Cuiaba',
    AmericaCuracao: 'America/Curacao',
    AmericaDanmarkshavn: 'America/Danmarkshavn',
    AmericaDawson: 'America/Dawson',
    AmericaDawsonCreek: 'America/Dawson_Creek',
    AmericaDenver: 'America/Denver',
    AmericaDetroit: 'America/Detroit',
    AmericaDominica: 'America/Dominica',
    AmericaEdmonton: 'America/Edmonton',
    AmericaEirunepe: 'America/Eirunepe',
    AmericaElSalvador: 'America/El_Salvador',
    AmericaEnsenada: 'America/Ensenada',
    AmericaFortWayne: 'America/Fort_Wayne',
    AmericaFortaleza: 'America/Fortaleza',
    AmericaGlaceBay: 'America/Glace_Bay',
    AmericaGodthab: 'America/Godthab',
    AmericaGooseBay: 'America/Goose_Bay',
    AmericaGrandTurk: 'America/Grand_Turk',
    AmericaGrenada: 'America/Grenada',
    AmericaGuadeloupe: 'America/Guadeloupe',
    AmericaGuatemala: 'America/Guatemala',
    AmericaGuayaquil: 'America/Guayaquil',
    AmericaGuyana: 'America/Guyana',
    AmericaHalifax: 'America/Halifax',
    AmericaHavana: 'America/Havana',
    AmericaHermosillo: 'America/Hermosillo',
    AmericaIndianaIndianapolis: 'America/Indiana/Indianapolis',
    AmericaIndianaKnox: 'America/Indiana/Knox',
    AmericaIndianaMarengo: 'America/Indiana/Marengo',
    AmericaIndianaPetersburg: 'America/Indiana/Petersburg',
    AmericaIndianaTellCity: 'America/Indiana/Tell_City',
    AmericaIndianaVevay: 'America/Indiana/Vevay',
    AmericaIndianaVincennes: 'America/Indiana/Vincennes',
    AmericaIndianaWinamac: 'America/Indiana/Winamac',
    AmericaIndianapolis: 'America/Indianapolis',
    AmericaInuvik: 'America/Inuvik',
    AmericaIqaluit: 'America/Iqaluit',
    AmericaJamaica: 'America/Jamaica',
    AmericaJujuy: 'America/Jujuy',
    AmericaJuneau: 'America/Juneau',
    AmericaKentuckyLouisville: 'America/Kentucky/Louisville',
    AmericaKentuckyMonticello: 'America/Kentucky/Monticello',
    AmericaKnoxIn: 'America/Knox_IN',
    AmericaKralendijk: 'America/Kralendijk',
    AmericaLaPaz: 'America/La_Paz',
    AmericaLima: 'America/Lima',
    AmericaLosAngeles: 'America/Los_Angeles',
    AmericaLouisville: 'America/Louisville',
    AmericaLowerPrinces: 'America/Lower_Princes',
    AmericaMaceio: 'America/Maceio',
    AmericaManagua: 'America/Managua',
    AmericaManaus: 'America/Manaus',
    AmericaMarigot: 'America/Marigot',
    AmericaMartinique: 'America/Martinique',
    AmericaMatamoros: 'America/Matamoros',
    AmericaMazatlan: 'America/Mazatlan',
    AmericaMendoza: 'America/Mendoza',
    AmericaMenominee: 'America/Menominee',
    AmericaMerida: 'America/Merida',
    AmericaMetlakatla: 'America/Metlakatla',
    AmericaMexicoCity: 'America/Mexico_City',
    AmericaMiquelon: 'America/Miquelon',
    AmericaMoncton: 'America/Moncton',
    AmericaMonterrey: 'America/Monterrey',
    AmericaMontevideo: 'America/Montevideo',
    AmericaMontreal: 'America/Montreal',
    AmericaMontserrat: 'America/Montserrat',
    AmericaNassau: 'America/Nassau',
    AmericaNewYork: 'America/New_York',
    AmericaNipigon: 'America/Nipigon',
    AmericaNome: 'America/Nome',
    AmericaNoronha: 'America/Noronha',
    AmericaNorthDakotaBeulah: 'America/North_Dakota/Beulah',
    AmericaNorthDakotaCenter: 'America/North_Dakota/Center',
    AmericaNorthDakotaNewSalem: 'America/North_Dakota/New_Salem',
    AmericaOjinaga: 'America/Ojinaga',
    AmericaPanama: 'America/Panama',
    AmericaPangnirtung: 'America/Pangnirtung',
    AmericaParamaribo: 'America/Paramaribo',
    AmericaPhoenix: 'America/Phoenix',
    AmericaPortAuPrince: 'America/Port-au-Prince',
    AmericaPortOfSpain: 'America/Port_of_Spain',
    AmericaPortoAcre: 'America/Porto_Acre',
    AmericaPortoVelho: 'America/Porto_Velho',
    AmericaPuertoRico: 'America/Puerto_Rico',
    AmericaRainyRiver: 'America/Rainy_River',
    AmericaRankinInlet: 'America/Rankin_Inlet',
    AmericaRecife: 'America/Recife',
    AmericaRegina: 'America/Regina',
    AmericaResolute: 'America/Resolute',
    AmericaRioBranco: 'America/Rio_Branco',
    AmericaRosario: 'America/Rosario',
    AmericaSantaIsabel: 'America/Santa_Isabel',
    AmericaSantarem: 'America/Santarem',
    AmericaSantiago: 'America/Santiago',
    AmericaSantoDomingo: 'America/Santo_Domingo',
    AmericaSaoPaulo: 'America/Sao_Paulo',
    AmericaScoresbysund: 'America/Scoresbysund',
    AmericaShiprock: 'America/Shiprock',
    AmericaSitka: 'America/Sitka',
    AmericaStBarthelemy: 'America/St_Barthelemy',
    AmericaStJohns: 'America/St_Johns',
    AmericaStKitts: 'America/St_Kitts',
    AmericaStLucia: 'America/St_Lucia',
    AmericaStThomas: 'America/St_Thomas',
    AmericaStVincent: 'America/St_Vincent',
    AmericaSwiftCurrent: 'America/Swift_Current',
    AmericaTegucigalpa: 'America/Tegucigalpa',
    AmericaThule: 'America/Thule',
    AmericaThunderBay: 'America/Thunder_Bay',
    AmericaTijuana: 'America/Tijuana',
    AmericaToronto: 'America/Toronto',
    AmericaTortola: 'America/Tortola',
    AmericaVancouver: 'America/Vancouver',
    AmericaVirgin: 'America/Virgin',
    AmericaWhitehorse: 'America/Whitehorse',
    AmericaWinnipeg: 'America/Winnipeg',
    AmericaYakutat: 'America/Yakutat',
    AmericaYellowknife: 'America/Yellowknife',
    AntarcticaCasey: 'Antarctica/Casey',
    AntarcticaDavis: 'Antarctica/Davis',
    AntarcticaDumontDUrville: 'Antarctica/DumontDUrville',
    AntarcticaMacquarie: 'Antarctica/Macquarie',
    AntarcticaMawson: 'Antarctica/Mawson',
    AntarcticaMcMurdo: 'Antarctica/McMurdo',
    AntarcticaPalmer: 'Antarctica/Palmer',
    AntarcticaRothera: 'Antarctica/Rothera',
    AntarcticaSouthPole: 'Antarctica/South_Pole',
    AntarcticaSyowa: 'Antarctica/Syowa',
    AntarcticaTroll: 'Antarctica/Troll',
    AntarcticaVostok: 'Antarctica/Vostok',
    ArcticLongyearbyen: 'Arctic/Longyearbyen',
    AsiaAden: 'Asia/Aden',
    AsiaAlmaty: 'Asia/Almaty',
    AsiaAmman: 'Asia/Amman',
    AsiaAnadyr: 'Asia/Anadyr',
    AsiaAqtau: 'Asia/Aqtau',
    AsiaAqtobe: 'Asia/Aqtobe',
    AsiaAshgabat: 'Asia/Ashgabat',
    AsiaAshkhabad: 'Asia/Ashkhabad',
    AsiaBaghdad: 'Asia/Baghdad',
    AsiaBahrain: 'Asia/Bahrain',
    AsiaBaku: 'Asia/Baku',
    AsiaBangkok: 'Asia/Bangkok',
    AsiaBeirut: 'Asia/Beirut',
    AsiaBishkek: 'Asia/Bishkek',
    AsiaBrunei: 'Asia/Brunei',
    AsiaCalcutta: 'Asia/Calcutta',
    AsiaChita: 'Asia/Chita',
    AsiaChoibalsan: 'Asia/Choibalsan',
    AsiaChongqing: 'Asia/Chongqing',
    AsiaChungking: 'Asia/Chungking',
    AsiaColombo: 'Asia/Colombo',
    AsiaDacca: 'Asia/Dacca',
    AsiaDamascus: 'Asia/Damascus',
    AsiaDhaka: 'Asia/Dhaka',
    AsiaDili: 'Asia/Dili',
    AsiaDubai: 'Asia/Dubai',
    AsiaDushanbe: 'Asia/Dushanbe',
    AsiaGaza: 'Asia/Gaza',
    AsiaHarbin: 'Asia/Harbin',
    AsiaHebron: 'Asia/Hebron',
    AsiaHoChiMinh: 'Asia/Ho_Chi_Minh',
    AsiaHongKong: 'Asia/Hong_Kong',
    AsiaHovd: 'Asia/Hovd',
    AsiaIrkutsk: 'Asia/Irkutsk',
    AsiaIstanbul: 'Asia/Istanbul',
    AsiaJakarta: 'Asia/Jakarta',
    AsiaJayapura: 'Asia/Jayapura',
    AsiaJerusalem: 'Asia/Jerusalem',
    AsiaKabul: 'Asia/Kabul',
    AsiaKamchatka: 'Asia/Kamchatka',
    AsiaKarachi: 'Asia/Karachi',
    AsiaKashgar: 'Asia/Kashgar',
    AsiaKathmandu: 'Asia/Kathmandu',
    AsiaKatmandu: 'Asia/Katmandu',
    AsiaKhandyga: 'Asia/Khandyga',
    AsiaKolkata: 'Asia/Kolkata',
    AsiaKrasnoyarsk: 'Asia/Krasnoyarsk',
    AsiaKualaLumpur: 'Asia/Kuala_Lumpur',
    AsiaKuching: 'Asia/Kuching',
    AsiaKuwait: 'Asia/Kuwait',
    AsiaMacao: 'Asia/Macao',
    AsiaMacau: 'Asia/Macau',
    AsiaMagadan: 'Asia/Magadan',
    AsiaMakassar: 'Asia/Makassar',
    AsiaManila: 'Asia/Manila',
    AsiaMuscat: 'Asia/Muscat',
    AsiaNicosia: 'Asia/Nicosia',
    AsiaNovokuznetsk: 'Asia/Novokuznetsk',
    AsiaNovosibirsk: 'Asia/Novosibirsk',
    AsiaOmsk: 'Asia/Omsk',
    AsiaOral: 'Asia/Oral',
    AsiaPhnomPenh: 'Asia/Phnom_Penh',
    AsiaPontianak: 'Asia/Pontianak',
    AsiaPyongyang: 'Asia/Pyongyang',
    AsiaQatar: 'Asia/Qatar',
    AsiaQyzylorda: 'Asia/Qyzylorda',
    AsiaRangoon: 'Asia/Rangoon',
    AsiaRiyadh: 'Asia/Riyadh',
    AsiaSaigon: 'Asia/Saigon',
    AsiaSakhalin: 'Asia/Sakhalin',
    AsiaSamarkand: 'Asia/Samarkand',
    AsiaSeoul: 'Asia/Seoul',
    AsiaShanghai: 'Asia/Shanghai',
    AsiaSingapore: 'Asia/Singapore',
    AsiaSrednekolymsk: 'Asia/Srednekolymsk',
    AsiaTaipei: 'Asia/Taipei',
    AsiaTashkent: 'Asia/Tashkent',
    AsiaTbilisi: 'Asia/Tbilisi',
    AsiaTehran: 'Asia/Tehran',
    AsiaTelAviv: 'Asia/Tel_Aviv',
    AsiaThimbu: 'Asia/Thimbu',
    AsiaThimphu: 'Asia/Thimphu',
    AsiaTokyo: 'Asia/Tokyo',
    AsiaUjungPandang: 'Asia/Ujung_Pandang',
    AsiaUlaanbaatar: 'Asia/Ulaanbaatar',
    AsiaUlanBator: 'Asia/Ulan_Bator',
    AsiaUrumqi: 'Asia/Urumqi',
    AsiaUstNera: 'Asia/Ust-Nera',
    AsiaVientiane: 'Asia/Vientiane',
    AsiaVladivostok: 'Asia/Vladivostok',
    AsiaYakutsk: 'Asia/Yakutsk',
    AsiaYekaterinburg: 'Asia/Yekaterinburg',
    AsiaYerevan: 'Asia/Yerevan',
    AtlanticAzores: 'Atlantic/Azores',
    AtlanticBermuda: 'Atlantic/Bermuda',
    AtlanticCanary: 'Atlantic/Canary',
    AtlanticCapeVerde: 'Atlantic/Cape_Verde',
    AtlanticFaeroe: 'Atlantic/Faeroe',
    AtlanticFaroe: 'Atlantic/Faroe',
    AtlanticJanMayen: 'Atlantic/Jan_Mayen',
    AtlanticMadeira: 'Atlantic/Madeira',
    AtlanticReykjavik: 'Atlantic/Reykjavik',
    AtlanticSouthGeorgia: 'Atlantic/South_Georgia',
    AtlanticStHelena: 'Atlantic/St_Helena',
    AtlanticStanley: 'Atlantic/Stanley',
    AustraliaAct: 'Australia/ACT',
    AustraliaAdelaide: 'Australia/Adelaide',
    AustraliaBrisbane: 'Australia/Brisbane',
    AustraliaBrokenHill: 'Australia/Broken_Hill',
    AustraliaCanberra: 'Australia/Canberra',
    AustraliaCurrie: 'Australia/Currie',
    AustraliaDarwin: 'Australia/Darwin',
    AustraliaEucla: 'Australia/Eucla',
    AustraliaHobart: 'Australia/Hobart',
    AustraliaLhi: 'Australia/LHI',
    AustraliaLindeman: 'Australia/Lindeman',
    AustraliaLordHowe: 'Australia/Lord_Howe',
    AustraliaMelbourne: 'Australia/Melbourne',
    AustraliaNsw: 'Australia/NSW',
    AustraliaNorth: 'Australia/North',
    AustraliaPerth: 'Australia/Perth',
    AustraliaQueensland: 'Australia/Queensland',
    AustraliaSouth: 'Australia/South',
    AustraliaSydney: 'Australia/Sydney',
    AustraliaTasmania: 'Australia/Tasmania',
    AustraliaVictoria: 'Australia/Victoria',
    AustraliaWest: 'Australia/West',
    AustraliaYancowinna: 'Australia/Yancowinna',
    BrazilAcre: 'Brazil/Acre',
    BrazilDeNoronha: 'Brazil/DeNoronha',
    BrazilEast: 'Brazil/East',
    BrazilWest: 'Brazil/West',
    CanadaAtlantic: 'Canada/Atlantic',
    CanadaCentral: 'Canada/Central',
    CanadaEastSaskatchewan: 'Canada/East-Saskatchewan',
    CanadaEastern: 'Canada/Eastern',
    CanadaMountain: 'Canada/Mountain',
    CanadaNewfoundland: 'Canada/Newfoundland',
    CanadaPacific: 'Canada/Pacific',
    CanadaSaskatchewan: 'Canada/Saskatchewan',
    CanadaYukon: 'Canada/Yukon',
    ChileContinental: 'Chile/Continental',
    ChileEasterIsland: 'Chile/EasterIsland',
    EtcGmt: 'Etc/GMT',
    EtcGmt0: 'Etc/GMT+0',
    EtcGmt1: 'Etc/GMT+1',
    EtcGmt10: 'Etc/GMT+10',
    EtcGmt11: 'Etc/GMT+11',
    EtcGmt12: 'Etc/GMT+12',
    EtcGmt2: 'Etc/GMT+2',
    EtcGmt3: 'Etc/GMT+3',
    EtcGmt4: 'Etc/GMT+4',
    EtcGmt5: 'Etc/GMT+5',
    EtcGmt6: 'Etc/GMT+6',
    EtcGmt7: 'Etc/GMT+7',
    EtcGmt8: 'Etc/GMT+8',
    EtcGmt9: 'Etc/GMT+9',
    EtcGmt13: 'Etc/GMT-13',
    EtcGmt14: 'Etc/GMT-14',
    EtcGreenwich: 'Etc/Greenwich',
    EtcUct: 'Etc/UCT',
    EtcUtc: 'Etc/UTC',
    EtcUniversal: 'Etc/Universal',
    EtcZulu: 'Etc/Zulu',
    EuropeAmsterdam: 'Europe/Amsterdam',
    EuropeAndorra: 'Europe/Andorra',
    EuropeAthens: 'Europe/Athens',
    EuropeBelfast: 'Europe/Belfast',
    EuropeBelgrade: 'Europe/Belgrade',
    EuropeBerlin: 'Europe/Berlin',
    EuropeBratislava: 'Europe/Bratislava',
    EuropeBrussels: 'Europe/Brussels',
    EuropeBucharest: 'Europe/Bucharest',
    EuropeBudapest: 'Europe/Budapest',
    EuropeBusingen: 'Europe/Busingen',
    EuropeChisinau: 'Europe/Chisinau',
    EuropeCopenhagen: 'Europe/Copenhagen',
    EuropeDublin: 'Europe/Dublin',
    EuropeGibraltar: 'Europe/Gibraltar',
    EuropeGuernsey: 'Europe/Guernsey',
    EuropeHelsinki: 'Europe/Helsinki',
    EuropeIsleOfMan: 'Europe/Isle_of_Man',
    EuropeIstanbul: 'Europe/Istanbul',
    EuropeJersey: 'Europe/Jersey',
    EuropeKaliningrad: 'Europe/Kaliningrad',
    EuropeKiev: 'Europe/Kiev',
    EuropeLisbon: 'Europe/Lisbon',
    EuropeLjubljana: 'Europe/Ljubljana',
    EuropeLondon: 'Europe/London',
    EuropeLuxembourg: 'Europe/Luxembourg',
    EuropeMadrid: 'Europe/Madrid',
    EuropeMalta: 'Europe/Malta',
    EuropeMariehamn: 'Europe/Mariehamn',
    EuropeMinsk: 'Europe/Minsk',
    EuropeMonaco: 'Europe/Monaco',
    EuropeMoscow: 'Europe/Moscow',
    EuropeNicosia: 'Europe/Nicosia',
    EuropeOslo: 'Europe/Oslo',
    EuropeParis: 'Europe/Paris',
    EuropePodgorica: 'Europe/Podgorica',
    EuropePrague: 'Europe/Prague',
    EuropeRiga: 'Europe/Riga',
    EuropeRome: 'Europe/Rome',
    EuropeSamara: 'Europe/Samara',
    EuropeSanMarino: 'Europe/San_Marino',
    EuropeSarajevo: 'Europe/Sarajevo',
    EuropeSimferopol: 'Europe/Simferopol',
    EuropeSkopje: 'Europe/Skopje',
    EuropeSofia: 'Europe/Sofia',
    EuropeStockholm: 'Europe/Stockholm',
    EuropeTallinn: 'Europe/Tallinn',
    EuropeTirane: 'Europe/Tirane',
    EuropeTiraspol: 'Europe/Tiraspol',
    EuropeUzhgorod: 'Europe/Uzhgorod',
    EuropeVaduz: 'Europe/Vaduz',
    EuropeVatican: 'Europe/Vatican',
    EuropeVienna: 'Europe/Vienna',
    EuropeVilnius: 'Europe/Vilnius',
    EuropeVolgograd: 'Europe/Volgograd',
    EuropeWarsaw: 'Europe/Warsaw',
    EuropeZagreb: 'Europe/Zagreb',
    EuropeZaporozhye: 'Europe/Zaporozhye',
    EuropeZurich: 'Europe/Zurich',
    IndianAntananarivo: 'Indian/Antananarivo',
    IndianChagos: 'Indian/Chagos',
    IndianChristmas: 'Indian/Christmas',
    IndianCocos: 'Indian/Cocos',
    IndianComoro: 'Indian/Comoro',
    IndianKerguelen: 'Indian/Kerguelen',
    IndianMahe: 'Indian/Mahe',
    IndianMaldives: 'Indian/Maldives',
    IndianMauritius: 'Indian/Mauritius',
    IndianMayotte: 'Indian/Mayotte',
    IndianReunion: 'Indian/Reunion',
    MexicoBajaNorte: 'Mexico/BajaNorte',
    MexicoBajaSur: 'Mexico/BajaSur',
    MexicoGeneral: 'Mexico/General',
    PacificApia: 'Pacific/Apia',
    PacificAuckland: 'Pacific/Auckland',
    PacificChatham: 'Pacific/Chatham',
    PacificChuuk: 'Pacific/Chuuk',
    PacificEaster: 'Pacific/Easter',
    PacificEfate: 'Pacific/Efate',
    PacificEnderbury: 'Pacific/Enderbury',
    PacificFakaofo: 'Pacific/Fakaofo',
    PacificFiji: 'Pacific/Fiji',
    PacificFunafuti: 'Pacific/Funafuti',
    PacificGalapagos: 'Pacific/Galapagos',
    PacificGambier: 'Pacific/Gambier',
    PacificGuadalcanal: 'Pacific/Guadalcanal',
    PacificGuam: 'Pacific/Guam',
    PacificHonolulu: 'Pacific/Honolulu',
    PacificJohnston: 'Pacific/Johnston',
    PacificKiritimati: 'Pacific/Kiritimati',
    PacificKosrae: 'Pacific/Kosrae',
    PacificKwajalein: 'Pacific/Kwajalein',
    PacificMajuro: 'Pacific/Majuro',
    PacificMarquesas: 'Pacific/Marquesas',
    PacificMidway: 'Pacific/Midway',
    PacificNauru: 'Pacific/Nauru',
    PacificNiue: 'Pacific/Niue',
    PacificNorfolk: 'Pacific/Norfolk',
    PacificNoumea: 'Pacific/Noumea',
    PacificPagoPago: 'Pacific/Pago_Pago',
    PacificPalau: 'Pacific/Palau',
    PacificPitcairn: 'Pacific/Pitcairn',
    PacificPohnpei: 'Pacific/Pohnpei',
    PacificPonape: 'Pacific/Ponape',
    PacificPortMoresby: 'Pacific/Port_Moresby',
    PacificRarotonga: 'Pacific/Rarotonga',
    PacificSaipan: 'Pacific/Saipan',
    PacificSamoa: 'Pacific/Samoa',
    PacificTahiti: 'Pacific/Tahiti',
    PacificTarawa: 'Pacific/Tarawa',
    PacificTongatapu: 'Pacific/Tongatapu',
    PacificTruk: 'Pacific/Truk',
    PacificWake: 'Pacific/Wake',
    PacificWallis: 'Pacific/Wallis',
    PacificYap: 'Pacific/Yap'
} as const;

export type BalanceTransactionsSummaryQueryParamsTimeZoneEnum = typeof BalanceTransactionsSummaryQueryParamsTimeZoneEnum[keyof typeof BalanceTransactionsSummaryQueryParamsTimeZoneEnum];
export const BalanceTransactionsSummaryQueryParamsTypesEnum = {
    Charge: 'charge',
    ChargeFee: 'charge_fee',
    ChargeFailureRefund: 'charge_failure_refund',
    Dispute: 'dispute',
    DisputeWon: 'dispute_won',
    Refund: 'refund',
    RefundFee: 'refund_fee',
    RefundFailure: 'refund_failure',
    PlatformFee: 'platform_fee',
    PlatformFeeRefund: 'platform_fee_refund',
    TilledFee: 'tilled_fee',
    AccountFee: 'account_fee',
    PaymentMethodFee: 'payment_method_fee',
    Adjustment: 'adjustment',
    Commission: 'commission',
    Payout: 'payout',
    PayoutCancel: 'payout_cancel',
    PayoutFailure: 'payout_failure'
} as const;

export type BalanceTransactionsSummaryQueryParamsTypesEnum = typeof BalanceTransactionsSummaryQueryParamsTypesEnum[keyof typeof BalanceTransactionsSummaryQueryParamsTypesEnum];

/**
 * 
 * @export
 * @interface BankAccount
 */
export interface BankAccount {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof BankAccount
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof BankAccount
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof BankAccount
     */
    'id': string;
    /**
     * The bank account type
     * @type {string}
     * @memberof BankAccount
     */
    'type': BankAccountTypeEnum;
    /**
     * The US bank account routing number.
     * @type {string}
     * @memberof BankAccount
     */
    'routing_number': string;
    /**
     * Whether this bank account is the default account for its currency.
     * @type {boolean}
     * @memberof BankAccount
     */
    'default_for_currency': boolean;
    /**
     * The ID of the Account associated with the bank account.
     * @type {string}
     * @memberof BankAccount
     */
    'account_id': string;
    /**
     * Name of the bank associated with the routing number (e.g. `WELLS FARGO`).
     * @type {string}
     * @memberof BankAccount
     */
    'bank_name'?: string;
    /**
     * The last 4 digits of the bank account number.
     * @type {string}
     * @memberof BankAccount
     */
    'last4': string;
    /**
     * The name of the person or business that owns the bank account.
     * @type {string}
     * @memberof BankAccount
     */
    'account_holder_name': string;
    /**
     * The currency the bank account is in. Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof BankAccount
     */
    'currency': BankAccountCurrencyEnum;
    /**
     * Bank account status
     * @type {string}
     * @memberof BankAccount
     */
    'status': BankAccountStatusEnum;
}

export const BankAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings'
} as const;

export type BankAccountTypeEnum = typeof BankAccountTypeEnum[keyof typeof BankAccountTypeEnum];
export const BankAccountCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type BankAccountCurrencyEnum = typeof BankAccountCurrencyEnum[keyof typeof BankAccountCurrencyEnum];
export const BankAccountStatusEnum = {
    New: 'new',
    Validated: 'validated',
    Verified: 'verified',
    VerificationFailed: 'verification_failed',
    Errored: 'errored'
} as const;

export type BankAccountStatusEnum = typeof BankAccountStatusEnum[keyof typeof BankAccountStatusEnum];

/**
 * 
 * @export
 * @interface BankAccountCreateParams
 */
export interface BankAccountCreateParams {
    /**
     * The bank account type
     * @type {string}
     * @memberof BankAccountCreateParams
     */
    'type': BankAccountCreateParamsTypeEnum;
    /**
     * The US bank account routing number.
     * @type {string}
     * @memberof BankAccountCreateParams
     */
    'routing_number': string;
    /**
     * The account number for the bank account, in string form.
     * @type {string}
     * @memberof BankAccountCreateParams
     */
    'account_number': string;
    /**
     * The name of the person or business that owns the bank account.
     * @type {string}
     * @memberof BankAccountCreateParams
     */
    'account_holder_name': string;
    /**
     * The currency the bank account is in. Three-letter ISO currency code, in lowercase.
     * @type {string}
     * @memberof BankAccountCreateParams
     */
    'currency': BankAccountCreateParamsCurrencyEnum;
    /**
     * Name of the financial institution.
     * @type {string}
     * @memberof BankAccountCreateParams
     */
    'bank_name'?: string;
    /**
     * Phone number for the financial institution
     * @type {string}
     * @memberof BankAccountCreateParams
     */
    'phone'?: string;
}

export const BankAccountCreateParamsTypeEnum = {
    Checking: 'checking',
    Savings: 'savings'
} as const;

export type BankAccountCreateParamsTypeEnum = typeof BankAccountCreateParamsTypeEnum[keyof typeof BankAccountCreateParamsTypeEnum];
export const BankAccountCreateParamsCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type BankAccountCreateParamsCurrencyEnum = typeof BankAccountCreateParamsCurrencyEnum[keyof typeof BankAccountCreateParamsCurrencyEnum];

/**
 * 
 * @export
 * @interface BaseAddress
 */
export interface BaseAddress {
    /**
     * First line of the street address
     * @type {string}
     * @memberof BaseAddress
     */
    'street': string;
    /**
     * Second line of the street address, if required.
     * @type {string}
     * @memberof BaseAddress
     */
    'street2'?: string;
    /**
     * City where address is located.
     * @type {string}
     * @memberof BaseAddress
     */
    'city': string;
    /**
     * State/province/region of the address. For US and CA use 2-digit state/province codes (e.g. \'AL\', \'AK\', \'BC\', \'ON\', \'etc\'.)
     * @type {string}
     * @memberof BaseAddress
     */
    'state': string;
    /**
     * Zip code or postal code of the address. No special characters.
     * @type {string}
     * @memberof BaseAddress
     */
    'zip': string;
    /**
     * 2-digit Country code (e.g. \'US\', \'CA\') [See ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     * @type {string}
     * @memberof BaseAddress
     */
    'country': string;
}
/**
 * 
 * @export
 * @interface BusinessLegalEntity
 */
export interface BusinessLegalEntity {
    /**
     * 
     * @type {BusinessLegalEntityAchBankAccount}
     * @memberof BusinessLegalEntity
     * @deprecated
     */
    'ach_bank_account'?: BusinessLegalEntityAchBankAccount;
    /**
     * Type of business. * `CHARITY` = Charity * `CIC` = Community Interest Company * `CORP` = Corporation * `LTD` = Limited * `LLC` = Limited Liability Company * `LLP` = Limited Liability Partnership * `NPCORP` = Non-Profit * `PARTNERSHP` = Partnership * `PLC` = Public Limited Company * `GOV` = Public Sector/Governmental * `SOLEPROP` = Sole Proprietorship/Sole Trader * `TRUST` = Trust
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'type': BusinessLegalEntityTypeEnum;
    /**
     * The merchant name
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'name': string;
    /**
     * Registered business legal/trading name (e.g. \"ACME CA\")
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'legal_name': string;
    /**
     * Company\'s Tax Identification Number
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'tax_identification_number': string;
    /**
     * Company\'s business description
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'description'?: string;
    /**
     * 
     * @type {BusinessLegalEntityAddress}
     * @memberof BusinessLegalEntity
     */
    'address': BusinessLegalEntityAddress;
    /**
     * Email of the business.
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'company_email'?: string;
    /**
     * Category code of the business. * `ACCT` = Accounting * `ART` = Artist Supply and Craft Stores * `BEAUTY` = Barber & Beauty Shop * `CATERING` = Catering * `CHARITY` = Charity * `CLEANING` = Cleaning Services * `CONSULTANT` = Consultant * `CONTRACTOR` = Trade Contractor * `DENTIST` = Dentistry * `EDU` = Schools & Education * `FOOD` = Food/Grocery * `LANDSCAPING` = Landscaping * `LEGAL` = Legal Services * `MEDICAL_PRACT` = Medical Practitioner * `MEDICAL_SERV` = Health Services * `MEMBERSHIP` = Membership Org. * `MISC_FOOD_STORES` = Misc. Food Stores * `MISC_MERCH` = Misc General Merchandise * `MISC_SERV` = Services * `MUSIC` = Music/Entertainment * `PC` = Computer Services * `PHOTO_FILM` = Photo/FILM * `PROF_SERV` = Professional Services * `REAL_ESTATE` = Real Estate * `RECREATION` = Recreation Services * `REPAIR` = Repair Services * `RESTO` = Restaurant/Bar * `RETAIL` = Direct Marketing Retail (MOTO) * `TAXI` = Taxi/Limo * `VET` = Veterinary * `WEB_DEV` = Web Design * `WEB_HOSTING` = Web Hosting
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'category': BusinessLegalEntityCategoryEnum;
    /**
     * Customer support phone number of the business. Cannot contain special characters.
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'phone': string;
    /**
     * Single currency used for processing and settlement for this merchant account.
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'currency': BusinessLegalEntityCurrencyEnum;
    /**
     * Estimated yearly volume of transactions of the business. * `LOW` = 0-50k * `MEDIUM` = 50-100k * `HIGH` = 100-250k * `VERY_HIGH` = 250k+
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'yearly_volume_range': BusinessLegalEntityYearlyVolumeRangeEnum;
    /**
     * Average transaction amount, in minor units. (e.g. $100.00 = 10000 minor units)
     * @type {number}
     * @memberof BusinessLegalEntity
     */
    'average_transaction_amount': number;
    /**
     * Region for the merchant account
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'region': BusinessLegalEntityRegionEnum;
    /**
     * The locale value used for the merchant account. Values depend on the region.
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'locale': BusinessLegalEntityLocaleEnum;
    /**
     * Provides information about a payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 20 characters for the concatenated descriptor.
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'statement_descriptor': string;
    /**
     * 
     * @type {BusinessLegalEntityBankAccount}
     * @memberof BusinessLegalEntity
     */
    'bank_account'?: BusinessLegalEntityBankAccount;
    /**
     * Array of Principals (ie Business Owners).
     * @type {Array<Principal>}
     * @memberof BusinessLegalEntity
     */
    'principals': Array<Principal>;
    /**
     * Website of the business.
     * @type {string}
     * @memberof BusinessLegalEntity
     */
    'website'?: string;
}

export const BusinessLegalEntityTypeEnum = {
    Charity: 'CHARITY',
    Cic: 'CIC',
    Corp: 'CORP',
    Ltd: 'LTD',
    Llc: 'LLC',
    Llp: 'LLP',
    Npcorp: 'NPCORP',
    Partnership: 'PARTNERSHIP',
    Plc: 'PLC',
    Gov: 'GOV',
    Soleprop: 'SOLEPROP',
    Trust: 'TRUST'
} as const;

export type BusinessLegalEntityTypeEnum = typeof BusinessLegalEntityTypeEnum[keyof typeof BusinessLegalEntityTypeEnum];
export const BusinessLegalEntityCategoryEnum = {
    Acct: 'ACCT',
    Art: 'ART',
    Beauty: 'BEAUTY',
    Catering: 'CATERING',
    Charity: 'CHARITY',
    Cleaning: 'CLEANING',
    Consultant: 'CONSULTANT',
    Contractor: 'CONTRACTOR',
    Dentist: 'DENTIST',
    Edu: 'EDU',
    Food: 'FOOD',
    Landscaping: 'LANDSCAPING',
    Legal: 'LEGAL',
    MedicalPract: 'MEDICAL_PRACT',
    MedicalServ: 'MEDICAL_SERV',
    Membership: 'MEMBERSHIP',
    MiscFoodStores: 'MISC_FOOD_STORES',
    MiscMerch: 'MISC_MERCH',
    MiscServ: 'MISC_SERV',
    Music: 'MUSIC',
    Pc: 'PC',
    PhotoFilm: 'PHOTO_FILM',
    ProfServ: 'PROF_SERV',
    RealEstate: 'REAL_ESTATE',
    Recreation: 'RECREATION',
    Repair: 'REPAIR',
    Resto: 'RESTO',
    Retail: 'RETAIL',
    Taxi: 'TAXI',
    Vet: 'VET',
    WebDev: 'WEB_DEV',
    WebHosting: 'WEB_HOSTING'
} as const;

export type BusinessLegalEntityCategoryEnum = typeof BusinessLegalEntityCategoryEnum[keyof typeof BusinessLegalEntityCategoryEnum];
export const BusinessLegalEntityCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type BusinessLegalEntityCurrencyEnum = typeof BusinessLegalEntityCurrencyEnum[keyof typeof BusinessLegalEntityCurrencyEnum];
export const BusinessLegalEntityYearlyVolumeRangeEnum = {
    Low: 'LOW',
    Medium: 'MEDIUM',
    High: 'HIGH',
    VeryHigh: 'VERY_HIGH'
} as const;

export type BusinessLegalEntityYearlyVolumeRangeEnum = typeof BusinessLegalEntityYearlyVolumeRangeEnum[keyof typeof BusinessLegalEntityYearlyVolumeRangeEnum];
export const BusinessLegalEntityRegionEnum = {
    Us: 'US',
    Ca: 'CA'
} as const;

export type BusinessLegalEntityRegionEnum = typeof BusinessLegalEntityRegionEnum[keyof typeof BusinessLegalEntityRegionEnum];
export const BusinessLegalEntityLocaleEnum = {
    EnUs: 'en_US',
    EnCa: 'en_CA',
    FrCa: 'fr_CA',
    EnGb: 'en_GB'
} as const;

export type BusinessLegalEntityLocaleEnum = typeof BusinessLegalEntityLocaleEnum[keyof typeof BusinessLegalEntityLocaleEnum];

/**
 * Required for US merchant accounts (`region = US`). This field is deprecated. Please use `bank_account`.
 * @export
 * @interface BusinessLegalEntityAchBankAccount
 */
export interface BusinessLegalEntityAchBankAccount {
    /**
     * This is the bank account number
     * @type {string}
     * @memberof BusinessLegalEntityAchBankAccount
     */
    'account_number': string;
    /**
     * The routing number, sort code, or other country-appropriate institution number for the bank account. For US bank accounts, this is required and should be the 9-digit ACH routing number, not the wire routing number. For CA bank accounts, combine the transit and institution numbers to create a full routing number (for example,  if `transit = 12345` and `institution = 678`, then `routing_number = 12345678`).
     * @type {string}
     * @memberof BusinessLegalEntityAchBankAccount
     */
    'routing_number': string;
}
/**
 * Registered legal address of the business.
 * @export
 * @interface BusinessLegalEntityAddress
 */
export interface BusinessLegalEntityAddress {
    /**
     * First line of the street address
     * @type {string}
     * @memberof BusinessLegalEntityAddress
     */
    'street': string;
    /**
     * Second line of the street address, if required.
     * @type {string}
     * @memberof BusinessLegalEntityAddress
     */
    'street2'?: string;
    /**
     * City where address is located.
     * @type {string}
     * @memberof BusinessLegalEntityAddress
     */
    'city': string;
    /**
     * State/province/region of the address. For US and CA use 2-digit state/province codes (e.g. \'AL\', \'AK\', \'BC\', \'ON\', \'etc\'.)
     * @type {string}
     * @memberof BusinessLegalEntityAddress
     */
    'state': string;
    /**
     * Zip code or postal code of the address. No special characters.
     * @type {string}
     * @memberof BusinessLegalEntityAddress
     */
    'zip': string;
    /**
     * 2-digit Country code (e.g. \'US\', \'CA\') [See ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     * @type {string}
     * @memberof BusinessLegalEntityAddress
     */
    'country': string;
}
/**
 * Bank Account Information
 * @export
 * @interface BusinessLegalEntityBankAccount
 */
export interface BusinessLegalEntityBankAccount {
    /**
     * This is the bank account number
     * @type {string}
     * @memberof BusinessLegalEntityBankAccount
     */
    'account_number': string;
    /**
     * The routing number, sort code, or other country-appropriate institution number for the bank account. For US bank accounts, this is required and should be the 9-digit ACH routing number, not the wire routing number. For CA bank accounts, combine the transit and institution numbers to create a full routing number (for example,  if `transit = 12345` and `institution = 678`, then `routing_number = 12345678`).
     * @type {string}
     * @memberof BusinessLegalEntityBankAccount
     */
    'routing_number': string;
}
/**
 * 
 * @export
 * @interface BusinessProfile
 */
export interface BusinessProfile {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof BusinessProfile
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof BusinessProfile
     */
    'created_at': string;
    /**
     * 
     * @type {BusinessProfileAddress}
     * @memberof BusinessProfile
     */
    'address': BusinessProfileAddress;
    /**
     * MCC category.
     * @type {string}
     * @memberof BusinessProfile
     */
    'category': BusinessProfileCategoryEnum;
    /**
     * The legal name for the business.
     * @type {string}
     * @memberof BusinessProfile
     */
    'legal_name': string;
    /**
     * The locale for the business.
     * @type {string}
     * @memberof BusinessProfile
     */
    'locale': BusinessProfileLocaleEnum;
    /**
     * The business\'s phone number.
     * @type {string}
     * @memberof BusinessProfile
     */
    'phone': string;
    /**
     * The region where the business is located.
     * @type {string}
     * @memberof BusinessProfile
     */
    'region': BusinessProfileRegionEnum;
    /**
     * The structure of the business (LLC, Corp, etc.).
     * @type {string}
     * @memberof BusinessProfile
     */
    'structure': BusinessProfileStructureEnum;
    /**
     * Tax identification number.
     * @type {string}
     * @memberof BusinessProfile
     */
    'tax_identification_number': string;
    /**
     * The website of the business.
     * @type {string}
     * @memberof BusinessProfile
     */
    'website'?: string;
    /**
     * A list of Representatives included in the onboarding application.
     * @type {Array<BusinessRepresentative>}
     * @memberof BusinessProfile
     */
    'representatives': Array<BusinessRepresentative>;
}

export const BusinessProfileCategoryEnum = {
    Acct: 'ACCT',
    Art: 'ART',
    Beauty: 'BEAUTY',
    Catering: 'CATERING',
    Charity: 'CHARITY',
    Cleaning: 'CLEANING',
    Consultant: 'CONSULTANT',
    Contractor: 'CONTRACTOR',
    Dentist: 'DENTIST',
    Edu: 'EDU',
    Food: 'FOOD',
    Landscaping: 'LANDSCAPING',
    Legal: 'LEGAL',
    MedicalPract: 'MEDICAL_PRACT',
    MedicalServ: 'MEDICAL_SERV',
    Membership: 'MEMBERSHIP',
    MiscFoodStores: 'MISC_FOOD_STORES',
    MiscMerch: 'MISC_MERCH',
    MiscServ: 'MISC_SERV',
    Music: 'MUSIC',
    Pc: 'PC',
    PhotoFilm: 'PHOTO_FILM',
    ProfServ: 'PROF_SERV',
    RealEstate: 'REAL_ESTATE',
    Recreation: 'RECREATION',
    Repair: 'REPAIR',
    Resto: 'RESTO',
    Retail: 'RETAIL',
    Taxi: 'TAXI',
    Vet: 'VET',
    WebDev: 'WEB_DEV',
    WebHosting: 'WEB_HOSTING'
} as const;

export type BusinessProfileCategoryEnum = typeof BusinessProfileCategoryEnum[keyof typeof BusinessProfileCategoryEnum];
export const BusinessProfileLocaleEnum = {
    EnUs: 'en_US',
    EnCa: 'en_CA',
    FrCa: 'fr_CA',
    EnGb: 'en_GB'
} as const;

export type BusinessProfileLocaleEnum = typeof BusinessProfileLocaleEnum[keyof typeof BusinessProfileLocaleEnum];
export const BusinessProfileRegionEnum = {
    Us: 'US',
    Ca: 'CA'
} as const;

export type BusinessProfileRegionEnum = typeof BusinessProfileRegionEnum[keyof typeof BusinessProfileRegionEnum];
export const BusinessProfileStructureEnum = {
    Charity: 'CHARITY',
    Cic: 'CIC',
    Corp: 'CORP',
    Ltd: 'LTD',
    Llc: 'LLC',
    Llp: 'LLP',
    Npcorp: 'NPCORP',
    Partnership: 'PARTNERSHIP',
    Plc: 'PLC',
    Gov: 'GOV',
    Soleprop: 'SOLEPROP',
    Trust: 'TRUST'
} as const;

export type BusinessProfileStructureEnum = typeof BusinessProfileStructureEnum[keyof typeof BusinessProfileStructureEnum];

/**
 * The address for this business.
 * @export
 * @interface BusinessProfileAddress
 */
export interface BusinessProfileAddress {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof BusinessProfileAddress
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof BusinessProfileAddress
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof BusinessProfileAddress
     */
    'id': string;
    /**
     * Address line 1 (e.g., street, PO Box, or company name).
     * @type {string}
     * @memberof BusinessProfileAddress
     */
    'street'?: string;
    /**
     * Address line 2 (e.g., apartment, suite, unit, or building).
     * @type {string}
     * @memberof BusinessProfileAddress
     */
    'street2'?: string;
    /**
     * City, district, suburb, town, or village.
     * @type {string}
     * @memberof BusinessProfileAddress
     */
    'city'?: string;
    /**
     * ZIP or postal code.
     * @type {string}
     * @memberof BusinessProfileAddress
     */
    'postal_code'?: string;
    /**
     * State or province.
     * @type {string}
     * @memberof BusinessProfileAddress
     */
    'state'?: string;
    /**
     * Country.
     * @type {string}
     * @memberof BusinessProfileAddress
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface BusinessRepresentative
 */
export interface BusinessRepresentative {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof BusinessRepresentative
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof BusinessRepresentative
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof BusinessRepresentative
     */
    'id': string;
    /**
     * 
     * @type {Array<Address>}
     * @memberof BusinessRepresentative
     */
    'addresses': Array<Address>;
    /**
     * The representative\'s first name.
     * @type {string}
     * @memberof BusinessRepresentative
     */
    'first_name': string;
    /**
     * The representative\'s middle name.
     * @type {string}
     * @memberof BusinessRepresentative
     */
    'middle_name'?: string;
    /**
     * The representative\'s last name.
     * @type {string}
     * @memberof BusinessRepresentative
     */
    'last_name': string;
    /**
     * The representative\'s title at the company.
     * @type {string}
     * @memberof BusinessRepresentative
     */
    'title': string;
    /**
     * The phone number for the representative.
     * @type {string}
     * @memberof BusinessRepresentative
     */
    'phone': string;
    /**
     * The email address of the representative.
     * @type {string}
     * @memberof BusinessRepresentative
     */
    'email'?: string;
    /**
     * If this associate is the one completing the application.
     * @type {boolean}
     * @memberof BusinessRepresentative
     */
    'is_applicant': boolean;
    /**
     * If this associate has a controlling interest.
     * @type {boolean}
     * @memberof BusinessRepresentative
     */
    'is_control_prong': boolean;
}
/**
 * 
 * @export
 * @interface CardChecks
 */
export interface CardChecks {
    /**
     * If an address line1 was provided, results of the check, one of `pass`, `fail`, `unavailable`, or `unchecked`.
     * @type {string}
     * @memberof CardChecks
     */
    'address_line1_check'?: CardChecksAddressLine1CheckEnum;
    /**
     * If an address postal code was provided, results of the check, one of `pass`, `fail`, `unavailable`, or `unchecked`.
     * @type {string}
     * @memberof CardChecks
     */
    'address_postal_code_check'?: CardChecksAddressPostalCodeCheckEnum;
    /**
     * If a CVC was provided, results of the check, one of `pass`, `fail`, `unavailable`, or `unchecked`.
     * @type {string}
     * @memberof CardChecks
     */
    'cvc_check'?: CardChecksCvcCheckEnum;
}

export const CardChecksAddressLine1CheckEnum = {
    Pass: 'pass',
    Fail: 'fail',
    Unavailable: 'unavailable',
    Unchecked: 'unchecked'
} as const;

export type CardChecksAddressLine1CheckEnum = typeof CardChecksAddressLine1CheckEnum[keyof typeof CardChecksAddressLine1CheckEnum];
export const CardChecksAddressPostalCodeCheckEnum = {
    Pass: 'pass',
    Fail: 'fail',
    Unavailable: 'unavailable',
    Unchecked: 'unchecked'
} as const;

export type CardChecksAddressPostalCodeCheckEnum = typeof CardChecksAddressPostalCodeCheckEnum[keyof typeof CardChecksAddressPostalCodeCheckEnum];
export const CardChecksCvcCheckEnum = {
    Pass: 'pass',
    Fail: 'fail',
    Unavailable: 'unavailable',
    Unchecked: 'unchecked'
} as const;

export type CardChecksCvcCheckEnum = typeof CardChecksCvcCheckEnum[keyof typeof CardChecksCvcCheckEnum];

/**
 * 
 * @export
 * @interface CardDetails
 */
export interface CardDetails {
    /**
     * Type of card.
     * @type {string}
     * @memberof CardDetails
     */
    'brand'?: CardDetailsBrandEnum;
    /**
     * Last 4 digits of the card.
     * @type {string}
     * @memberof CardDetails
     */
    'last4'?: string;
    /**
     * Two-digit number representing the card\'s expiration month.
     * @type {number}
     * @memberof CardDetails
     */
    'exp_month'?: number;
    /**
     * Two- or four-digit number representing the card\'s expiration year.
     * @type {number}
     * @memberof CardDetails
     */
    'exp_year'?: number;
    /**
     * 
     * @type {CardDetailsChecks}
     * @memberof CardDetails
     */
    'checks'?: CardDetailsChecks;
    /**
     * The card holder\'s name.
     * @type {string}
     * @memberof CardDetails
     */
    'holder_name'?: string;
}

export const CardDetailsBrandEnum = {
    Amex: 'amex',
    Diners: 'diners',
    Discover: 'discover',
    Jcb: 'jcb',
    Maestro: 'maestro',
    Mastercard: 'mastercard',
    Solo: 'solo',
    Visa: 'visa',
    VisaDebit: 'visa_debit',
    VisaElectron: 'visa_electron',
    Unknown: 'unknown'
} as const;

export type CardDetailsBrandEnum = typeof CardDetailsBrandEnum[keyof typeof CardDetailsBrandEnum];

/**
 * Checks on Card address and CVC if provided.
 * @export
 * @interface CardDetailsChecks
 */
export interface CardDetailsChecks {
    /**
     * If an address line1 was provided, results of the check, one of `pass`, `fail`, `unavailable`, or `unchecked`.
     * @type {string}
     * @memberof CardDetailsChecks
     */
    'address_line1_check'?: CardDetailsChecksAddressLine1CheckEnum;
    /**
     * If an address postal code was provided, results of the check, one of `pass`, `fail`, `unavailable`, or `unchecked`.
     * @type {string}
     * @memberof CardDetailsChecks
     */
    'address_postal_code_check'?: CardDetailsChecksAddressPostalCodeCheckEnum;
    /**
     * If a CVC was provided, results of the check, one of `pass`, `fail`, `unavailable`, or `unchecked`.
     * @type {string}
     * @memberof CardDetailsChecks
     */
    'cvc_check'?: CardDetailsChecksCvcCheckEnum;
}

export const CardDetailsChecksAddressLine1CheckEnum = {
    Pass: 'pass',
    Fail: 'fail',
    Unavailable: 'unavailable',
    Unchecked: 'unchecked'
} as const;

export type CardDetailsChecksAddressLine1CheckEnum = typeof CardDetailsChecksAddressLine1CheckEnum[keyof typeof CardDetailsChecksAddressLine1CheckEnum];
export const CardDetailsChecksAddressPostalCodeCheckEnum = {
    Pass: 'pass',
    Fail: 'fail',
    Unavailable: 'unavailable',
    Unchecked: 'unchecked'
} as const;

export type CardDetailsChecksAddressPostalCodeCheckEnum = typeof CardDetailsChecksAddressPostalCodeCheckEnum[keyof typeof CardDetailsChecksAddressPostalCodeCheckEnum];
export const CardDetailsChecksCvcCheckEnum = {
    Pass: 'pass',
    Fail: 'fail',
    Unavailable: 'unavailable',
    Unchecked: 'unchecked'
} as const;

export type CardDetailsChecksCvcCheckEnum = typeof CardDetailsChecksCvcCheckEnum[keyof typeof CardDetailsChecksCvcCheckEnum];

/**
 * 
 * @export
 * @interface Charge
 */
export interface Charge {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof Charge
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof Charge
     */
    'created_at': string;
    /**
     * Error code explaining reason for charge failure.
     * @type {string}
     * @memberof Charge
     */
    'failure_code'?: ChargeFailureCodeEnum;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof Charge
     */
    'id': string;
    /**
     * The ID of the PaymentIntent associated with this charge.
     * @type {string}
     * @memberof Charge
     */
    'payment_intent_id': string;
    /**
     * The status of the payment.
     * @type {string}
     * @memberof Charge
     */
    'status': ChargeStatusEnum;
    /**
     * Amount (in the smallest currency unit) captured. Can be less than the `amount` on the PaymentIntent if a partial capture was made.
     * @type {number}
     * @memberof Charge
     */
    'amount_captured': number;
    /**
     * Amount (in the smallest currency unit) refunded. Can be less than the `amount` on the PaymentIntent if a partial refund was made.
     * @type {number}
     * @memberof Charge
     */
    'amount_refunded': number;
    /**
     * Time at which the charge was captured.
     * @type {string}
     * @memberof Charge
     */
    'captured_at'?: string;
    /**
     * If the charge was created without capturing, this Boolean represents whether it is still uncaptured or has since been captured.
     * @type {boolean}
     * @memberof Charge
     */
    'captured': boolean;
    /**
     * Whether the charge has been fully refunded. If the charge is only partially refunded, this attribute will be false.
     * @type {boolean}
     * @memberof Charge
     */
    'refunded': boolean;
    /**
     * A list of refunds that have been applied to the charge.
     * @type {Array<Refund>}
     * @memberof Charge
     */
    'refunds': Array<Refund>;
    /**
     * The id of the PaymentMethod at the time of the transaction.
     * @type {string}
     * @memberof Charge
     */
    'payment_method_id'?: string;
    /**
     * 
     * @type {ChargePlatformFee}
     * @memberof Charge
     */
    'platform_fee'?: ChargePlatformFee;
    /**
     * 
     * @type {ChargeBalanceTransaction}
     * @memberof Charge
     */
    'balance_transaction'?: ChargeBalanceTransaction;
    /**
     * Message to user further explaining the reason for the charge failure.
     * @type {string}
     * @memberof Charge
     */
    'failure_message'?: string;
}

export const ChargeFailureCodeEnum = {
    InsufficientFunds: 'insufficient_funds',
    AvsCheckFailed: 'avs_check_failed',
    GenericDecline: 'generic_decline',
    CallIssuer: 'call_issuer',
    ExpiredCard: 'expired_card',
    PickupCard: 'pickup_card',
    InvalidNumber: 'invalid_number',
    LimitExceeded: 'limit_exceeded',
    NotPermitted: 'not_permitted',
    IncorrectCvc: 'incorrect_cvc',
    ServiceNotAllowed: 'service_not_allowed',
    InvalidExpiry: 'invalid_expiry',
    CardNotSupported: 'card_not_supported',
    RestrictedCard: 'restricted_card',
    Fraudulent: 'fraudulent',
    ProcessingError: 'processing_error',
    BankAccountBlocked: 'bank_account_blocked',
    InternalError: 'internal_error'
} as const;

export type ChargeFailureCodeEnum = typeof ChargeFailureCodeEnum[keyof typeof ChargeFailureCodeEnum];
export const ChargeStatusEnum = {
    Succeeded: 'succeeded',
    Pending: 'pending',
    Failed: 'failed'
} as const;

export type ChargeStatusEnum = typeof ChargeStatusEnum[keyof typeof ChargeStatusEnum];

/**
 * The balance transaction that describes the impact of this charge on your account balance (not including refunds or disputes).
 * @export
 * @interface ChargeBalanceTransaction
 */
export interface ChargeBalanceTransaction {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof ChargeBalanceTransaction
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof ChargeBalanceTransaction
     */
    'created_at': string;
    /**
     * Detailed breakdown of the fees paid for this transaction.
     * @type {Array<BalanceTransactionFeeDetail>}
     * @memberof ChargeBalanceTransaction
     */
    'fee_details': Array<BalanceTransactionFeeDetail>;
    /**
     * If the transaction’s net funds are available in the Tilled balance yet. Either `available` or `pending`.
     * @type {string}
     * @memberof ChargeBalanceTransaction
     */
    'status': ChargeBalanceTransactionStatusEnum;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof ChargeBalanceTransaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChargeBalanceTransaction
     */
    'account_id': string;
    /**
     * Gross amount of the transaction, in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). Can be negative for certain transaction types (e.g. `payout`, `refund`).
     * @type {number}
     * @memberof ChargeBalanceTransaction
     */
    'amount': number;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof ChargeBalanceTransaction
     */
    'currency': ChargeBalanceTransactionCurrencyEnum;
    /**
     * An arbitrary string attached to the object. Often useful for displaying to users.
     * @type {string}
     * @memberof ChargeBalanceTransaction
     */
    'description'?: string;
    /**
     * Fees (in smallest currency unit) paid for this transaction.
     * @type {number}
     * @memberof ChargeBalanceTransaction
     */
    'fee': number;
    /**
     * Net amount of the transaction, in smallest currency unit.
     * @type {number}
     * @memberof ChargeBalanceTransaction
     */
    'net': number;
    /**
     * Tilled id to which this transaction is related
     * @type {string}
     * @memberof ChargeBalanceTransaction
     */
    'source_id': string;
    /**
     * Transaction type.
     * @type {string}
     * @memberof ChargeBalanceTransaction
     */
    'type': ChargeBalanceTransactionTypeEnum;
    /**
     * The date the transaction\'s net funds will become avaiable in the Tilled balance.
     * @type {string}
     * @memberof ChargeBalanceTransaction
     */
    'available_on': string;
}

export const ChargeBalanceTransactionStatusEnum = {
    Available: 'available',
    Pending: 'pending'
} as const;

export type ChargeBalanceTransactionStatusEnum = typeof ChargeBalanceTransactionStatusEnum[keyof typeof ChargeBalanceTransactionStatusEnum];
export const ChargeBalanceTransactionCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type ChargeBalanceTransactionCurrencyEnum = typeof ChargeBalanceTransactionCurrencyEnum[keyof typeof ChargeBalanceTransactionCurrencyEnum];
export const ChargeBalanceTransactionTypeEnum = {
    Charge: 'charge',
    ChargeFee: 'charge_fee',
    ChargeFailureRefund: 'charge_failure_refund',
    Dispute: 'dispute',
    DisputeWon: 'dispute_won',
    Refund: 'refund',
    RefundFee: 'refund_fee',
    RefundFailure: 'refund_failure',
    PlatformFee: 'platform_fee',
    PlatformFeeRefund: 'platform_fee_refund',
    TilledFee: 'tilled_fee',
    AccountFee: 'account_fee',
    PaymentMethodFee: 'payment_method_fee',
    Adjustment: 'adjustment',
    Commission: 'commission',
    Payout: 'payout',
    PayoutCancel: 'payout_cancel',
    PayoutFailure: 'payout_failure'
} as const;

export type ChargeBalanceTransactionTypeEnum = typeof ChargeBalanceTransactionTypeEnum[keyof typeof ChargeBalanceTransactionTypeEnum];

/**
 * The platform fee (if any) for the charge.
 * @export
 * @interface ChargePlatformFee
 */
export interface ChargePlatformFee {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof ChargePlatformFee
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof ChargePlatformFee
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof ChargePlatformFee
     */
    'id': string;
    /**
     * Id of the Tilled account that earned this fee. This is generally an account of `type` `partner`.
     * @type {string}
     * @memberof ChargePlatformFee
     */
    'payee_account_id': string;
    /**
     * Id of the Tilled account this fee was taken from. This is generally an account of `type` `merchant`.
     * @type {string}
     * @memberof ChargePlatformFee
     */
    'payer_account_id': string;
    /**
     * Amount earned, in minor currency units.
     * @type {number}
     * @memberof ChargePlatformFee
     */
    'amount': number;
    /**
     * Amount refunded, in minor currency units. Can be less than the amount attribute if a partial refund was issued.
     * @type {number}
     * @memberof ChargePlatformFee
     */
    'amount_refunded': number;
    /**
     * Id of the charge this fee was taken from.
     * @type {string}
     * @memberof ChargePlatformFee
     */
    'charge_id': string;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof ChargePlatformFee
     */
    'currency': ChargePlatformFeeCurrencyEnum;
    /**
     * Whether the fee has been fully refunded. If the fee is only partially refunded, this attribute will be false.
     * @type {boolean}
     * @memberof ChargePlatformFee
     */
    'refunded': boolean;
    /**
     * A list of refunds that have been applied to the fee.
     * @type {Array<PlatformFeeRefund>}
     * @memberof ChargePlatformFee
     */
    'refunds': Array<PlatformFeeRefund>;
    /**
     * 
     * @type {PlatformFeeBalanceTransaction}
     * @memberof ChargePlatformFee
     */
    'balance_transaction': PlatformFeeBalanceTransaction;
}

export const ChargePlatformFeeCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type ChargePlatformFeeCurrencyEnum = typeof ChargePlatformFeeCurrencyEnum[keyof typeof ChargePlatformFeeCurrencyEnum];

/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof Customer
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof Customer
     */
    'created_at': string;
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof Customer
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof Customer
     */
    'id': string;
    /**
     * The id of the associated account.
     * @type {string}
     * @memberof Customer
     */
    'account_id': string;
    /**
     * The customer\'s first name.
     * @type {string}
     * @memberof Customer
     */
    'first_name'?: string;
    /**
     * The customer\'s middle name.
     * @type {string}
     * @memberof Customer
     */
    'middle_name'?: string;
    /**
     * The customer\'s last name.
     * @type {string}
     * @memberof Customer
     */
    'last_name'?: string;
    /**
     * The customer\'s email address.
     * @type {string}
     * @memberof Customer
     */
    'email'?: string;
    /**
     * The customer\'s phone number.
     * @type {string}
     * @memberof Customer
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface CustomerCreateParams
 */
export interface CustomerCreateParams {
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value (i.e. `\'\'` or `null`) to them. All keys can be unset by posting an empty value (i.e. `{}` or `null`) to `metadata`.
     * @type {{ [key: string]: string; }}
     * @memberof CustomerCreateParams
     */
    'metadata'?: { [key: string]: string; };
    /**
     * The customer\'s first name.
     * @type {string}
     * @memberof CustomerCreateParams
     */
    'first_name'?: string;
    /**
     * The customer\'s middle name.
     * @type {string}
     * @memberof CustomerCreateParams
     */
    'middle_name'?: string;
    /**
     * The customer\'s last name.
     * @type {string}
     * @memberof CustomerCreateParams
     */
    'last_name'?: string;
    /**
     * The customer\'s email address.
     * @type {string}
     * @memberof CustomerCreateParams
     */
    'email'?: string;
    /**
     * The customer\'s phone number.
     * @type {string}
     * @memberof CustomerCreateParams
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface CustomerUpdateParams
 */
export interface CustomerUpdateParams {
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value (i.e. `\'\'` or `null`) to them. All keys can be unset by posting an empty value (i.e. `{}` or `null`) to `metadata`.
     * @type {{ [key: string]: string; }}
     * @memberof CustomerUpdateParams
     */
    'metadata'?: { [key: string]: string; };
    /**
     * The customer\'s first name.
     * @type {string}
     * @memberof CustomerUpdateParams
     */
    'first_name'?: string;
    /**
     * The customer\'s middle name.
     * @type {string}
     * @memberof CustomerUpdateParams
     */
    'middle_name'?: string;
    /**
     * The customer\'s last name.
     * @type {string}
     * @memberof CustomerUpdateParams
     */
    'last_name'?: string;
    /**
     * The customer\'s email address.
     * @type {string}
     * @memberof CustomerUpdateParams
     */
    'email'?: string;
    /**
     * The customer\'s phone number.
     * @type {string}
     * @memberof CustomerUpdateParams
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface Dispute
 */
export interface Dispute {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof Dispute
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof Dispute
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof Dispute
     */
    'id': string;
    /**
     * The ID of the Account associated with this dispute.
     * @type {string}
     * @memberof Dispute
     */
    'account_id': string;
    /**
     * The ID of the Charge associated with this dispute.
     * @type {string}
     * @memberof Dispute
     */
    'charge_id': string;
    /**
     * Amount of the charge that is in dispute in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). If the dispute is type `chargeback` the amount has already been deducted from your account balance and can only be restored by submitting evidence proving the validity of the charge.
     * @type {number}
     * @memberof Dispute
     */
    'amount': number;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof Dispute
     */
    'currency': DisputeCurrencyEnum;
    /**
     * Current status of the dispute: `needs_response`, `under_review`, `closed`, `won` or `lost`.
     * @type {string}
     * @memberof Dispute
     */
    'status': DisputeStatusEnum;
    /**
     * Description explaining the reason for a dispute
     * @type {string}
     * @memberof Dispute
     */
    'reason_description'?: string;
    /**
     * The balance transactions that describes the impact of this dispute on your account balance.
     * @type {Array<BalanceTransaction>}
     * @memberof Dispute
     */
    'balance_transactions': Array<BalanceTransaction>;
    /**
     * Time at which the supporting evidence is due and the dispute will be closed with no response.
     * @type {string}
     * @memberof Dispute
     */
    'closing_at'?: string;
    /**
     * Time at which the dispute was reversed.
     * @type {string}
     * @memberof Dispute
     */
    'reversed_at'?: string;
}

export const DisputeCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type DisputeCurrencyEnum = typeof DisputeCurrencyEnum[keyof typeof DisputeCurrencyEnum];
export const DisputeStatusEnum = {
    NeedsResponse: 'needs_response',
    UnderReview: 'under_review',
    Closed: 'closed',
    Won: 'won',
    Lost: 'lost'
} as const;

export type DisputeStatusEnum = typeof DisputeStatusEnum[keyof typeof DisputeStatusEnum];

/**
 * 
 * @export
 * @interface EftDebitDetails
 */
export interface EftDebitDetails {
    /**
     * Name of the bank associated to this Eft Debit.
     * @type {string}
     * @memberof EftDebitDetails
     */
    'bank_name'?: string;
    /**
     * The last 2 digits of the bank account number.
     * @type {string}
     * @memberof EftDebitDetails
     */
    'last2'?: string;
    /**
     * The sequence of five-digits used by banks to identify specific financial institution\'s branch
     * @type {string}
     * @memberof EftDebitDetails
     */
    'transit_number'?: string;
    /**
     * The sequence of three-digits used by banks to identify specific financial institutions
     * @type {string}
     * @memberof EftDebitDetails
     */
    'institution_id'?: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof Event
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof Event
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * The id of the account that originated the event.
     * @type {string}
     * @memberof Event
     */
    'account_id': string;
    /**
     * Description of the event (e.g. `charge.succeeded` or `charge.refunded`).  `account.updated` Occurs whenever an account status or property has changed. This includes capability statuses.  `charge.captured` Occurs whenever a previously uncaptured charge is captured.  `charge.expired` Occurs whenever an uncaptured charge expires.  `charge.failed` Occurs whenever a failed charge attempt occurs.  `charge.succeeded` Occurs whenever a new charge is created and is successful.  `charge.pending` Occurs whenever a pending charge is created.  `charge.refunded` occurs whenever a charge is refunded, including partial refunds  `charge.refund.updated` Occurs whenever a refund is updated, on selected payment methods.  `charge.updated` Occurs when a charge description is updated  `customer.created` Occurs whenever a new customer is created.  `customer.deleted` Occurs whenever a customer is deleted.  `customer.updated` Occurs whenever any property of a customer changes.  `payment_intent.canceled` Occurs when a PaymentIntent is canceled.  `payment_intent.created` Occurs when a new PaymentIntent is created.  `payment_intent.payment_failed` Occurs when a PaymentIntent has failed the attempt to create a payment method or a payment.  `payment_intent.processing` Occurs when a PaymentIntent has started processing.  `payment_intent.requires_action` Occurs when a PaymentIntent transitions to requires_action state  `payment_intent.succeeded` Occurs when a PaymentIntent has successfully completed payment.  `payment_method.attached` Occurs whenever a new payment method is attached to a customer.  `payment_method.detached` Occurs whenever a payment method is detached from a customer.  `report_run.succeeded` Occurs whenever a report run has successfully been uploaded to S3 and our File system.  `report_run.failed` Occurs whenever a report run has failed to be uploaded to S3 or our File system.
     * @type {string}
     * @memberof Event
     */
    'type': EventTypeEnum;
    /**
     * Object containing the API resource relevant to the event. For example, a `charge.succeeded` event will have a full charge object as the value.
     * @type {object}
     * @memberof Event
     */
    'data': object;
}

export const EventTypeEnum = {
    AccountUpdated: 'account.updated',
    ChargeCaptured: 'charge.captured',
    ChargeExpired: 'charge.expired',
    ChargeFailed: 'charge.failed',
    ChargeSucceeded: 'charge.succeeded',
    ChargePending: 'charge.pending',
    ChargeRefunded: 'charge.refunded',
    ChargeRefundUpdated: 'charge.refund.updated',
    ChargeUpdated: 'charge.updated',
    CustomerCreated: 'customer.created',
    CustomerDeleted: 'customer.deleted',
    CustomerUpdated: 'customer.updated',
    DisputeCreated: 'dispute.created',
    DisputeUpdated: 'dispute.updated',
    PaymentIntentCanceled: 'payment_intent.canceled',
    PaymentIntentCreated: 'payment_intent.created',
    PaymentIntentPaymentFailed: 'payment_intent.payment_failed',
    PaymentIntentProcessing: 'payment_intent.processing',
    PaymentIntentRequiresAction: 'payment_intent.requires_action',
    PaymentIntentSucceeded: 'payment_intent.succeeded',
    PaymentIntentAmountCapturableUpdated: 'payment_intent.amount_capturable_updated',
    PaymentMethodAttached: 'payment_method.attached',
    PaymentMethodDetached: 'payment_method.detached',
    PayoutCreated: 'payout.created',
    PayoutFailed: 'payout.failed',
    PayoutPaid: 'payout.paid',
    PayoutUpdated: 'payout.updated',
    PlatformFeeCreated: 'platform_fee.created',
    PlatformFeeRefunded: 'platform_fee.refunded',
    SubscriptionCreated: 'subscription.created',
    SubscriptionCanceled: 'subscription.canceled',
    SubscriptionUpdated: 'subscription.updated',
    ReportRunSucceeded: 'report_run.succeeded',
    ReportRunFailed: 'report_run.failed'
} as const;

export type EventTypeEnum = typeof EventTypeEnum[keyof typeof EventTypeEnum];

/**
 * 
 * @export
 * @interface ForgotPasswordParams
 */
export interface ForgotPasswordParams {
    /**
     * Email
     * @type {string}
     * @memberof ForgotPasswordParams
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface HealthOutput
 */
export interface HealthOutput {
    /**
     * The overall health of the API. `pass` is healthy, `fail` is unhealthy, and `warn` is healthy with some concerns.
     * @type {string}
     * @memberof HealthOutput
     */
    'status': HealthOutputStatusEnum;
    /**
     * Public version of the API.
     * @type {string}
     * @memberof HealthOutput
     */
    'version'?: string;
    /**
     * Array of notes relevant to the current state of health.
     * @type {Array<string>}
     * @memberof HealthOutput
     */
    'notes'?: Array<string>;
    /**
     * Human-friendly description of the API.
     * @type {string}
     * @memberof HealthOutput
     */
    'description'?: string;
}

export const HealthOutputStatusEnum = {
    Pass: 'pass',
    Fail: 'fail',
    Warn: 'warn'
} as const;

export type HealthOutputStatusEnum = typeof HealthOutputStatusEnum[keyof typeof HealthOutputStatusEnum];

/**
 * 
 * @export
 * @interface Level3
 */
export interface Level3 {
    /**
     * More detailed information about the items being purchased. Max length is 25.
     * @type {Array<LineItem>}
     * @memberof Level3
     */
    'line_items': Array<LineItem>;
    /**
     * Postal/zip code of the address to which the purchased goods will be delivered. This field can be identical to the `shipping_from_zip` if the customer is present and takes immediate possession of the goods.
     * @type {string}
     * @memberof Level3
     */
    'shipping_address_zip': string;
    /**
     * 2-digit Country code (e.g. \'US\', \'CA\') of the address to which the purchased goods will be delivered.
     * @type {string}
     * @memberof Level3
     */
    'shipping_address_country': string;
    /**
     * The shipping or freight portion of the total transaction amount, in minor units.
     * @type {number}
     * @memberof Level3
     */
    'shipping_amount': number;
    /**
     * Postal/zip code of the address from which the purchased goods are being shipped
     * @type {string}
     * @memberof Level3
     */
    'shipping_from_zip': string;
    /**
     * Duty associated with the import of the purchased goods on the total amount for the order, in minor units.
     * @type {number}
     * @memberof Level3
     */
    'duty_amount': number;
}
/**
 * 
 * @export
 * @interface LineItem
 */
export interface LineItem {
    /**
     * Merchant-defined product code of the item being purchased
     * @type {string}
     * @memberof LineItem
     */
    'product_code': string;
    /**
     * Description of the item(s) being purchased
     * @type {string}
     * @memberof LineItem
     */
    'product_description': string;
    /**
     * Quantity of the item. Note: will be rounded to a maximum of 4 decimals.
     * @type {number}
     * @memberof LineItem
     */
    'quantity': number;
    /**
     * Amount of any value-added taxes that can be associated with the purchased item, in minor units.
     * @type {number}
     * @memberof LineItem
     */
    'tax_amount': number;
    /**
     * Price of the item being purchased, in minor units.
     * @type {number}
     * @memberof LineItem
     */
    'unit_amount': number;
}
/**
 * 
 * @export
 * @interface ListAPIKeys200Response
 */
export interface ListAPIKeys200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListAPIKeys200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListAPIKeys200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListAPIKeys200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListAPIKeys200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof ListAPIKeys200Response
     */
    'items': Array<ApiKey>;
}
/**
 * 
 * @export
 * @interface ListAPIKeys200ResponseAllOf
 */
export interface ListAPIKeys200ResponseAllOf {
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof ListAPIKeys200ResponseAllOf
     */
    'items': Array<ApiKey>;
}
/**
 * 
 * @export
 * @interface ListAllApplePayDomains200Response
 */
export interface ListAllApplePayDomains200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListAllApplePayDomains200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListAllApplePayDomains200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListAllApplePayDomains200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListAllApplePayDomains200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<ApplePayDomain>}
     * @memberof ListAllApplePayDomains200Response
     */
    'items': Array<ApplePayDomain>;
}
/**
 * 
 * @export
 * @interface ListAllApplePayDomains200ResponseAllOf
 */
export interface ListAllApplePayDomains200ResponseAllOf {
    /**
     * 
     * @type {Array<ApplePayDomain>}
     * @memberof ListAllApplePayDomains200ResponseAllOf
     */
    'items': Array<ApplePayDomain>;
}
/**
 * 
 * @export
 * @interface ListAllFiles200Response
 */
export interface ListAllFiles200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListAllFiles200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListAllFiles200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListAllFiles200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListAllFiles200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof ListAllFiles200Response
     */
    'items': Array<any>;
}
/**
 * 
 * @export
 * @interface ListAllFiles200ResponseAllOf
 */
export interface ListAllFiles200ResponseAllOf {
    /**
     * 
     * @type {Array<any>}
     * @memberof ListAllFiles200ResponseAllOf
     */
    'items': Array<any>;
}
/**
 * 
 * @export
 * @interface ListAllReportRuns200Response
 */
export interface ListAllReportRuns200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListAllReportRuns200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListAllReportRuns200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListAllReportRuns200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListAllReportRuns200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<ReportRun>}
     * @memberof ListAllReportRuns200Response
     */
    'items': Array<ReportRun>;
}
/**
 * 
 * @export
 * @interface ListAllReportRuns200ResponseAllOf
 */
export interface ListAllReportRuns200ResponseAllOf {
    /**
     * 
     * @type {Array<ReportRun>}
     * @memberof ListAllReportRuns200ResponseAllOf
     */
    'items': Array<ReportRun>;
}
/**
 * 
 * @export
 * @interface ListAllSubscriptions200Response
 */
export interface ListAllSubscriptions200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListAllSubscriptions200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListAllSubscriptions200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListAllSubscriptions200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListAllSubscriptions200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof ListAllSubscriptions200Response
     */
    'items': Array<Subscription>;
}
/**
 * 
 * @export
 * @interface ListAllSubscriptions200ResponseAllOf
 */
export interface ListAllSubscriptions200ResponseAllOf {
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof ListAllSubscriptions200ResponseAllOf
     */
    'items': Array<Subscription>;
}
/**
 * 
 * @export
 * @interface ListAllTerminalReaders200Response
 */
export interface ListAllTerminalReaders200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListAllTerminalReaders200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListAllTerminalReaders200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListAllTerminalReaders200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListAllTerminalReaders200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<TerminalReader>}
     * @memberof ListAllTerminalReaders200Response
     */
    'items': Array<TerminalReader>;
}
/**
 * 
 * @export
 * @interface ListAllTerminalReaders200ResponseAllOf
 */
export interface ListAllTerminalReaders200ResponseAllOf {
    /**
     * 
     * @type {Array<TerminalReader>}
     * @memberof ListAllTerminalReaders200ResponseAllOf
     */
    'items': Array<TerminalReader>;
}
/**
 * 
 * @export
 * @interface ListAllUserInvitations200Response
 */
export interface ListAllUserInvitations200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListAllUserInvitations200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListAllUserInvitations200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListAllUserInvitations200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListAllUserInvitations200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<UserInvitation>}
     * @memberof ListAllUserInvitations200Response
     */
    'items': Array<UserInvitation>;
}
/**
 * 
 * @export
 * @interface ListAllUserInvitations200ResponseAllOf
 */
export interface ListAllUserInvitations200ResponseAllOf {
    /**
     * 
     * @type {Array<UserInvitation>}
     * @memberof ListAllUserInvitations200ResponseAllOf
     */
    'items': Array<UserInvitation>;
}
/**
 * 
 * @export
 * @interface ListAllUsers200Response
 */
export interface ListAllUsers200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListAllUsers200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListAllUsers200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListAllUsers200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListAllUsers200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof ListAllUsers200Response
     */
    'items': Array<User>;
}
/**
 * 
 * @export
 * @interface ListAllUsers200ResponseAllOf
 */
export interface ListAllUsers200ResponseAllOf {
    /**
     * 
     * @type {Array<User>}
     * @memberof ListAllUsers200ResponseAllOf
     */
    'items': Array<User>;
}
/**
 * 
 * @export
 * @interface ListAllWebhookEndpoints200Response
 */
export interface ListAllWebhookEndpoints200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListAllWebhookEndpoints200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListAllWebhookEndpoints200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListAllWebhookEndpoints200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListAllWebhookEndpoints200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<WebhookEndpoint>}
     * @memberof ListAllWebhookEndpoints200Response
     */
    'items': Array<WebhookEndpoint>;
}
/**
 * 
 * @export
 * @interface ListAllWebhookEndpoints200ResponseAllOf
 */
export interface ListAllWebhookEndpoints200ResponseAllOf {
    /**
     * 
     * @type {Array<WebhookEndpoint>}
     * @memberof ListAllWebhookEndpoints200ResponseAllOf
     */
    'items': Array<WebhookEndpoint>;
}
/**
 * 
 * @export
 * @interface ListBalanceTransactions200Response
 */
export interface ListBalanceTransactions200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListBalanceTransactions200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListBalanceTransactions200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListBalanceTransactions200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListBalanceTransactions200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<BalanceTransaction>}
     * @memberof ListBalanceTransactions200Response
     */
    'items': Array<BalanceTransaction>;
}
/**
 * 
 * @export
 * @interface ListBalanceTransactions200ResponseAllOf
 */
export interface ListBalanceTransactions200ResponseAllOf {
    /**
     * 
     * @type {Array<BalanceTransaction>}
     * @memberof ListBalanceTransactions200ResponseAllOf
     */
    'items': Array<BalanceTransaction>;
}
/**
 * 
 * @export
 * @interface ListConnectedAccounts200Response
 */
export interface ListConnectedAccounts200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListConnectedAccounts200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListConnectedAccounts200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListConnectedAccounts200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListConnectedAccounts200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Account>}
     * @memberof ListConnectedAccounts200Response
     */
    'items': Array<Account>;
}
/**
 * 
 * @export
 * @interface ListConnectedAccounts200ResponseAllOf
 */
export interface ListConnectedAccounts200ResponseAllOf {
    /**
     * 
     * @type {Array<Account>}
     * @memberof ListConnectedAccounts200ResponseAllOf
     */
    'items': Array<Account>;
}
/**
 * 
 * @export
 * @interface ListCustomers200Response
 */
export interface ListCustomers200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListCustomers200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListCustomers200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListCustomers200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListCustomers200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Customer>}
     * @memberof ListCustomers200Response
     */
    'items': Array<Customer>;
}
/**
 * 
 * @export
 * @interface ListCustomers200ResponseAllOf
 */
export interface ListCustomers200ResponseAllOf {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof ListCustomers200ResponseAllOf
     */
    'items': Array<Customer>;
}
/**
 * 
 * @export
 * @interface ListDisputes200Response
 */
export interface ListDisputes200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListDisputes200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListDisputes200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListDisputes200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListDisputes200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Dispute>}
     * @memberof ListDisputes200Response
     */
    'items': Array<Dispute>;
}
/**
 * 
 * @export
 * @interface ListDisputes200ResponseAllOf
 */
export interface ListDisputes200ResponseAllOf {
    /**
     * 
     * @type {Array<Dispute>}
     * @memberof ListDisputes200ResponseAllOf
     */
    'items': Array<Dispute>;
}
/**
 * 
 * @export
 * @interface ListEvents200Response
 */
export interface ListEvents200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListEvents200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListEvents200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListEvents200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListEvents200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Event>}
     * @memberof ListEvents200Response
     */
    'items': Array<Event>;
}
/**
 * 
 * @export
 * @interface ListEvents200ResponseAllOf
 */
export interface ListEvents200ResponseAllOf {
    /**
     * 
     * @type {Array<Event>}
     * @memberof ListEvents200ResponseAllOf
     */
    'items': Array<Event>;
}
/**
 * 
 * @export
 * @interface ListPaymentIntents200Response
 */
export interface ListPaymentIntents200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListPaymentIntents200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListPaymentIntents200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListPaymentIntents200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListPaymentIntents200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<PaymentIntent>}
     * @memberof ListPaymentIntents200Response
     */
    'items': Array<PaymentIntent>;
}
/**
 * 
 * @export
 * @interface ListPaymentIntents200ResponseAllOf
 */
export interface ListPaymentIntents200ResponseAllOf {
    /**
     * 
     * @type {Array<PaymentIntent>}
     * @memberof ListPaymentIntents200ResponseAllOf
     */
    'items': Array<PaymentIntent>;
}
/**
 * 
 * @export
 * @interface ListPaymentMethods200Response
 */
export interface ListPaymentMethods200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListPaymentMethods200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListPaymentMethods200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListPaymentMethods200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListPaymentMethods200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<PaymentMethod>}
     * @memberof ListPaymentMethods200Response
     */
    'items': Array<PaymentMethod>;
}
/**
 * 
 * @export
 * @interface ListPaymentMethods200ResponseAllOf
 */
export interface ListPaymentMethods200ResponseAllOf {
    /**
     * 
     * @type {Array<PaymentMethod>}
     * @memberof ListPaymentMethods200ResponseAllOf
     */
    'items': Array<PaymentMethod>;
}
/**
 * 
 * @export
 * @interface ListPayouts200Response
 */
export interface ListPayouts200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListPayouts200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListPayouts200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListPayouts200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListPayouts200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Payout>}
     * @memberof ListPayouts200Response
     */
    'items': Array<Payout>;
}
/**
 * 
 * @export
 * @interface ListPayouts200ResponseAllOf
 */
export interface ListPayouts200ResponseAllOf {
    /**
     * 
     * @type {Array<Payout>}
     * @memberof ListPayouts200ResponseAllOf
     */
    'items': Array<Payout>;
}
/**
 * 
 * @export
 * @interface ListPlatformFees200Response
 */
export interface ListPlatformFees200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListPlatformFees200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListPlatformFees200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListPlatformFees200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListPlatformFees200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<PlatformFee>}
     * @memberof ListPlatformFees200Response
     */
    'items': Array<PlatformFee>;
}
/**
 * 
 * @export
 * @interface ListPlatformFees200ResponseAllOf
 */
export interface ListPlatformFees200ResponseAllOf {
    /**
     * 
     * @type {Array<PlatformFee>}
     * @memberof ListPlatformFees200ResponseAllOf
     */
    'items': Array<PlatformFee>;
}
/**
 * 
 * @export
 * @interface ListProductCodes200Response
 */
export interface ListProductCodes200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListProductCodes200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListProductCodes200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListProductCodes200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListProductCodes200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<ProductCode>}
     * @memberof ListProductCodes200Response
     */
    'items': Array<ProductCode>;
}
/**
 * 
 * @export
 * @interface ListProductCodes200ResponseAllOf
 */
export interface ListProductCodes200ResponseAllOf {
    /**
     * 
     * @type {Array<ProductCode>}
     * @memberof ListProductCodes200ResponseAllOf
     */
    'items': Array<ProductCode>;
}
/**
 * 
 * @export
 * @interface ListRefunds200Response
 */
export interface ListRefunds200Response {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof ListRefunds200Response
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof ListRefunds200Response
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof ListRefunds200Response
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof ListRefunds200Response
     */
    'total'?: number;
    /**
     * 
     * @type {Array<Refund>}
     * @memberof ListRefunds200Response
     */
    'items': Array<Refund>;
}
/**
 * 
 * @export
 * @interface ListRefunds200ResponseAllOf
 */
export interface ListRefunds200ResponseAllOf {
    /**
     * 
     * @type {Array<Refund>}
     * @memberof ListRefunds200ResponseAllOf
     */
    'items': Array<Refund>;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * 
     * @type {LoginDtoUser}
     * @memberof LoginDto
     */
    'user': LoginDtoUser;
    /**
     * JSON Web Token used for authentication (i.e. access token).
     * @type {string}
     * @memberof LoginDto
     */
    'token': string;
    /**
     * JSON Web Token used to refresh access tokens.
     * @type {string}
     * @memberof LoginDto
     */
    'refresh_token': string;
}
/**
 * The logged in user.
 * @export
 * @interface LoginDtoUser
 */
export interface LoginDtoUser {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof LoginDtoUser
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof LoginDtoUser
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof LoginDtoUser
     */
    'id': string;
    /**
     * The full name of the user.
     * @type {string}
     * @memberof LoginDtoUser
     */
    'name': string;
    /**
     * The user email.
     * @type {string}
     * @memberof LoginDtoUser
     */
    'email': string;
    /**
     * The ID of the Account associated with this user.
     * @type {string}
     * @memberof LoginDtoUser
     */
    'account_id': string;
    /**
     * The user\'s role, primarily used in the Tilled Dashboard. The roles have varied restrictions on the actions they can take.
     * @type {string}
     * @memberof LoginDtoUser
     */
    'role': LoginDtoUserRoleEnum;
    /**
     * Time at which the user last successfully logged in via the API.
     * @type {string}
     * @memberof LoginDtoUser
     */
    'last_login_at'?: string;
    /**
     * Time at which the user\'s token was last used to authenticate a request to the API.
     * @type {string}
     * @memberof LoginDtoUser
     */
    'last_request_at'?: string;
    /**
     * Six digit verification code of the user.
     * @type {string}
     * @memberof LoginDtoUser
     */
    'verification_code'?: string;
}

export const LoginDtoUserRoleEnum = {
    Owner: 'owner',
    Admin: 'admin',
    Developer: 'developer',
    Analyst: 'analyst',
    ViewOnly: 'view_only',
    MerchantOwner: 'merchant_owner',
    MerchantAdmin: 'merchant_admin'
} as const;

export type LoginDtoUserRoleEnum = typeof LoginDtoUserRoleEnum[keyof typeof LoginDtoUserRoleEnum];

/**
 * 
 * @export
 * @interface LoginParams
 */
export interface LoginParams {
    /**
     * Password
     * @type {string}
     * @memberof LoginParams
     */
    'password': string;
    /**
     * Email
     * @type {string}
     * @memberof LoginParams
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface MerchantApplication
 */
export interface MerchantApplication {
    /**
     * Indicates whether or not the merchant has accepted the terms and conditions.
     * @type {boolean}
     * @memberof MerchantApplication
     */
    'accept_terms_and_conditions': boolean;
    /**
     * Links to terms and conditions for a merchant application.
     * @type {Array<TermsAndConditionsDetail>}
     * @memberof MerchantApplication
     */
    'terms_and_conditions_links'?: Array<TermsAndConditionsDetail>;
    /**
     * If an application contains any validation errors they will appear here. If they are not addressed before submission then the submission will fail.
     * @type {Array<string>}
     * @memberof MerchantApplication
     */
    'validation_errors'?: Array<string>;
    /**
     * 
     * @type {MerchantApplicationBusinessLegalEntity}
     * @memberof MerchantApplication
     */
    'business_legal_entity'?: MerchantApplicationBusinessLegalEntity;
    /**
     * The product codes applied to/associated with this merchant application.
     * @type {Array<ProductCode>}
     * @memberof MerchantApplication
     */
    'product_codes': Array<ProductCode>;
}
/**
 * Merchant account details
 * @export
 * @interface MerchantApplicationBusinessLegalEntity
 */
export interface MerchantApplicationBusinessLegalEntity {
    /**
     * 
     * @type {BusinessLegalEntityAchBankAccount}
     * @memberof MerchantApplicationBusinessLegalEntity
     * @deprecated
     */
    'ach_bank_account'?: BusinessLegalEntityAchBankAccount;
    /**
     * Type of business. * `CHARITY` = Charity * `CIC` = Community Interest Company * `CORP` = Corporation * `LTD` = Limited * `LLC` = Limited Liability Company * `LLP` = Limited Liability Partnership * `NPCORP` = Non-Profit * `PARTNERSHP` = Partnership * `PLC` = Public Limited Company * `GOV` = Public Sector/Governmental * `SOLEPROP` = Sole Proprietorship/Sole Trader * `TRUST` = Trust
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'type': MerchantApplicationBusinessLegalEntityTypeEnum;
    /**
     * The merchant name
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'name': string;
    /**
     * Registered business legal/trading name (e.g. \"ACME CA\")
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'legal_name': string;
    /**
     * Company\'s Tax Identification Number
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'tax_identification_number': string;
    /**
     * Company\'s business description
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'description'?: string;
    /**
     * 
     * @type {BusinessLegalEntityAddress}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'address': BusinessLegalEntityAddress;
    /**
     * Email of the business.
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'company_email'?: string;
    /**
     * Category code of the business. * `ACCT` = Accounting * `ART` = Artist Supply and Craft Stores * `BEAUTY` = Barber & Beauty Shop * `CATERING` = Catering * `CHARITY` = Charity * `CLEANING` = Cleaning Services * `CONSULTANT` = Consultant * `CONTRACTOR` = Trade Contractor * `DENTIST` = Dentistry * `EDU` = Schools & Education * `FOOD` = Food/Grocery * `LANDSCAPING` = Landscaping * `LEGAL` = Legal Services * `MEDICAL_PRACT` = Medical Practitioner * `MEDICAL_SERV` = Health Services * `MEMBERSHIP` = Membership Org. * `MISC_FOOD_STORES` = Misc. Food Stores * `MISC_MERCH` = Misc General Merchandise * `MISC_SERV` = Services * `MUSIC` = Music/Entertainment * `PC` = Computer Services * `PHOTO_FILM` = Photo/FILM * `PROF_SERV` = Professional Services * `REAL_ESTATE` = Real Estate * `RECREATION` = Recreation Services * `REPAIR` = Repair Services * `RESTO` = Restaurant/Bar * `RETAIL` = Direct Marketing Retail (MOTO) * `TAXI` = Taxi/Limo * `VET` = Veterinary * `WEB_DEV` = Web Design * `WEB_HOSTING` = Web Hosting
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'category': MerchantApplicationBusinessLegalEntityCategoryEnum;
    /**
     * Customer support phone number of the business. Cannot contain special characters.
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'phone': string;
    /**
     * Single currency used for processing and settlement for this merchant account.
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'currency': MerchantApplicationBusinessLegalEntityCurrencyEnum;
    /**
     * Estimated yearly volume of transactions of the business. * `LOW` = 0-50k * `MEDIUM` = 50-100k * `HIGH` = 100-250k * `VERY_HIGH` = 250k+
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'yearly_volume_range': MerchantApplicationBusinessLegalEntityYearlyVolumeRangeEnum;
    /**
     * Average transaction amount, in minor units. (e.g. $100.00 = 10000 minor units)
     * @type {number}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'average_transaction_amount': number;
    /**
     * Region for the merchant account
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'region': MerchantApplicationBusinessLegalEntityRegionEnum;
    /**
     * The locale value used for the merchant account. Values depend on the region.
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'locale': MerchantApplicationBusinessLegalEntityLocaleEnum;
    /**
     * Provides information about a payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 20 characters for the concatenated descriptor.
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'statement_descriptor': string;
    /**
     * 
     * @type {BusinessLegalEntityBankAccount}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'bank_account'?: BusinessLegalEntityBankAccount;
    /**
     * Array of Principals (ie Business Owners).
     * @type {Array<Principal>}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'principals': Array<Principal>;
    /**
     * Website of the business.
     * @type {string}
     * @memberof MerchantApplicationBusinessLegalEntity
     */
    'website'?: string;
}

export const MerchantApplicationBusinessLegalEntityTypeEnum = {
    Charity: 'CHARITY',
    Cic: 'CIC',
    Corp: 'CORP',
    Ltd: 'LTD',
    Llc: 'LLC',
    Llp: 'LLP',
    Npcorp: 'NPCORP',
    Partnership: 'PARTNERSHIP',
    Plc: 'PLC',
    Gov: 'GOV',
    Soleprop: 'SOLEPROP',
    Trust: 'TRUST'
} as const;

export type MerchantApplicationBusinessLegalEntityTypeEnum = typeof MerchantApplicationBusinessLegalEntityTypeEnum[keyof typeof MerchantApplicationBusinessLegalEntityTypeEnum];
export const MerchantApplicationBusinessLegalEntityCategoryEnum = {
    Acct: 'ACCT',
    Art: 'ART',
    Beauty: 'BEAUTY',
    Catering: 'CATERING',
    Charity: 'CHARITY',
    Cleaning: 'CLEANING',
    Consultant: 'CONSULTANT',
    Contractor: 'CONTRACTOR',
    Dentist: 'DENTIST',
    Edu: 'EDU',
    Food: 'FOOD',
    Landscaping: 'LANDSCAPING',
    Legal: 'LEGAL',
    MedicalPract: 'MEDICAL_PRACT',
    MedicalServ: 'MEDICAL_SERV',
    Membership: 'MEMBERSHIP',
    MiscFoodStores: 'MISC_FOOD_STORES',
    MiscMerch: 'MISC_MERCH',
    MiscServ: 'MISC_SERV',
    Music: 'MUSIC',
    Pc: 'PC',
    PhotoFilm: 'PHOTO_FILM',
    ProfServ: 'PROF_SERV',
    RealEstate: 'REAL_ESTATE',
    Recreation: 'RECREATION',
    Repair: 'REPAIR',
    Resto: 'RESTO',
    Retail: 'RETAIL',
    Taxi: 'TAXI',
    Vet: 'VET',
    WebDev: 'WEB_DEV',
    WebHosting: 'WEB_HOSTING'
} as const;

export type MerchantApplicationBusinessLegalEntityCategoryEnum = typeof MerchantApplicationBusinessLegalEntityCategoryEnum[keyof typeof MerchantApplicationBusinessLegalEntityCategoryEnum];
export const MerchantApplicationBusinessLegalEntityCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type MerchantApplicationBusinessLegalEntityCurrencyEnum = typeof MerchantApplicationBusinessLegalEntityCurrencyEnum[keyof typeof MerchantApplicationBusinessLegalEntityCurrencyEnum];
export const MerchantApplicationBusinessLegalEntityYearlyVolumeRangeEnum = {
    Low: 'LOW',
    Medium: 'MEDIUM',
    High: 'HIGH',
    VeryHigh: 'VERY_HIGH'
} as const;

export type MerchantApplicationBusinessLegalEntityYearlyVolumeRangeEnum = typeof MerchantApplicationBusinessLegalEntityYearlyVolumeRangeEnum[keyof typeof MerchantApplicationBusinessLegalEntityYearlyVolumeRangeEnum];
export const MerchantApplicationBusinessLegalEntityRegionEnum = {
    Us: 'US',
    Ca: 'CA'
} as const;

export type MerchantApplicationBusinessLegalEntityRegionEnum = typeof MerchantApplicationBusinessLegalEntityRegionEnum[keyof typeof MerchantApplicationBusinessLegalEntityRegionEnum];
export const MerchantApplicationBusinessLegalEntityLocaleEnum = {
    EnUs: 'en_US',
    EnCa: 'en_CA',
    FrCa: 'fr_CA',
    EnGb: 'en_GB'
} as const;

export type MerchantApplicationBusinessLegalEntityLocaleEnum = typeof MerchantApplicationBusinessLegalEntityLocaleEnum[keyof typeof MerchantApplicationBusinessLegalEntityLocaleEnum];

/**
 * 
 * @export
 * @interface MerchantApplicationCreateParams
 */
export interface MerchantApplicationCreateParams {
    /**
     * Indicates whether or not the merchant has accepted the terms and conditions.
     * @type {boolean}
     * @memberof MerchantApplicationCreateParams
     */
    'accept_terms_and_conditions': boolean;
    /**
     * 
     * @type {MerchantApplicationBusinessLegalEntity}
     * @memberof MerchantApplicationCreateParams
     */
    'business_legal_entity'?: MerchantApplicationBusinessLegalEntity;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof ModelFile
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof ModelFile
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof ModelFile
     */
    'id': string;
    /**
     * The file type. Can be `png`, `jpg`, `pdf`, or `csv`.
     * @type {string}
     * @memberof ModelFile
     */
    'type': ModelFileTypeEnum;
    /**
     * The file purpose. Can be `logo`, `icon`, or `report`.
     * @type {string}
     * @memberof ModelFile
     */
    'purpose': ModelFilePurposeEnum;
    /**
     * The filename.
     * @type {string}
     * @memberof ModelFile
     */
    'filename': string;
    /**
     * The URL for public files.
     * @type {string}
     * @memberof ModelFile
     */
    'url'?: string;
    /**
     * The user friendly title.
     * @type {string}
     * @memberof ModelFile
     */
    'title'?: string;
    /**
     * The file size.
     * @type {number}
     * @memberof ModelFile
     */
    'size': number;
    /**
     * Time at which the file should no longer be accessible.
     * @type {string}
     * @memberof ModelFile
     */
    'expires_at'?: string;
}

export const ModelFileTypeEnum = {
    Png: 'png',
    Jpg: 'jpg',
    Pdf: 'pdf',
    Csv: 'csv'
} as const;

export type ModelFileTypeEnum = typeof ModelFileTypeEnum[keyof typeof ModelFileTypeEnum];
export const ModelFilePurposeEnum = {
    Logo: 'logo',
    Icon: 'icon',
    Terms: 'terms',
    Report: 'report'
} as const;

export type ModelFilePurposeEnum = typeof ModelFilePurposeEnum[keyof typeof ModelFilePurposeEnum];

/**
 * 
 * @export
 * @interface PaginatedDto
 */
export interface PaginatedDto {
    /**
     * Whether or not there are more elements available after this set. If `false`, this set comprises the end of the list.
     * @type {boolean}
     * @memberof PaginatedDto
     */
    'has_more': boolean;
    /**
     * The (zero-based) offset of the first item in the collection to return.
     * @type {number}
     * @memberof PaginatedDto
     */
    'offset'?: number;
    /**
     * The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @type {number}
     * @memberof PaginatedDto
     */
    'limit'?: number;
    /**
     * The total items count.
     * @type {number}
     * @memberof PaginatedDto
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface PartialAddress
 */
export interface PartialAddress {
    /**
     * First line of the street address
     * @type {string}
     * @memberof PartialAddress
     */
    'street'?: string;
    /**
     * Second line of the street address, if required.
     * @type {string}
     * @memberof PartialAddress
     */
    'street2'?: string;
    /**
     * City where address is located.
     * @type {string}
     * @memberof PartialAddress
     */
    'city'?: string;
    /**
     * State/province/region of the address. For US and CA use 2-digit state/province codes (e.g. \'AL\', \'AK\', \'BC\', \'ON\', \'etc\'.)
     * @type {string}
     * @memberof PartialAddress
     */
    'state'?: string;
    /**
     * Zip code or postal code of the address. No special characters.
     * @type {string}
     * @memberof PartialAddress
     */
    'zip'?: string;
    /**
     * 2-digit Country code (e.g. \'US\', \'CA\') [See ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     * @type {string}
     * @memberof PartialAddress
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface PaymentIntent
 */
export interface PaymentIntent {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof PaymentIntent
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof PaymentIntent
     */
    'created_at': string;
    /**
     * The list of payment method types (e.g. card) that this PaymentIntent is allowed to use.
     * @type {Array<string>}
     * @memberof PaymentIntent
     */
    'payment_method_types': Array<PaymentIntentPaymentMethodTypesEnum>;
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof PaymentIntent
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {PaymentIntentLevel3}
     * @memberof PaymentIntent
     */
    'level3'?: PaymentIntentLevel3;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof PaymentIntent
     */
    'id': string;
    /**
     * ID of the Tilled account for which the funds of this PaymentIntent are intended.
     * @type {string}
     * @memberof PaymentIntent
     */
    'account_id': string;
    /**
     * Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency).
     * @type {number}
     * @memberof PaymentIntent
     */
    'amount': number;
    /**
     * Amount that can be captured from this PaymentIntent.
     * @type {number}
     * @memberof PaymentIntent
     */
    'amount_capturable': number;
    /**
     * Amount that was collected by this PaymentIntent.
     * @type {number}
     * @memberof PaymentIntent
     */
    'amount_received': number;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof PaymentIntent
     */
    'currency': PaymentIntentCurrencyEnum;
    /**
     * Status of this PaymentIntent, one of `requires_payment_method`, `requires_confirmation`, `requires_action`, `processing`, `requires_capture`, `canceled`, or `succeeded`.
     * @type {string}
     * @memberof PaymentIntent
     */
    'status': PaymentIntentStatusEnum;
    /**
     * Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor
     * @type {string}
     * @memberof PaymentIntent
     */
    'statement_descriptor_suffix'?: string;
    /**
     * 
     * @type {PaymentIntentPaymentMethod}
     * @memberof PaymentIntent
     */
    'payment_method'?: PaymentIntentPaymentMethod;
    /**
     * Controls when the funds will be captured from the customer’s account.  `automatic` (Default) Tilled automatically captures funds when the customer authorizes the payment.  `manual` Place a hold on funds when the customer authorizes the payment, but don\'t capture the funds until later.
     * @type {string}
     * @memberof PaymentIntent
     */
    'capture_method': PaymentIntentCaptureMethodEnum;
    /**
     * Charges that were created by this PaymentIntent, if any. At most, this list will only contain one successful charge.
     * @type {Array<Charge>}
     * @memberof PaymentIntent
     */
    'charges': Array<Charge>;
    /**
     * The client secret of this PaymentIntent. Used for client-side retrieval using a publishable key. The client secret can be used to complete a payment from your frontend. It should not be stored, logged, embedded in URLs, or exposed to anyone other than the customer. Make sure that you have TLS enabled on any page that includes the client secret.
     * @type {string}
     * @memberof PaymentIntent
     */
    'client_secret': string;
    /**
     * The amount of the fee (if any) that will be requested to be applied to the payment and transferred to the `partner` account. The amount of the fee collected will be capped a the total payment amount.
     * @type {number}
     * @memberof PaymentIntent
     */
    'platform_fee_amount'?: number;
    /**
     * 
     * @type {PaymentIntentLastPaymentError}
     * @memberof PaymentIntent
     */
    'last_payment_error'?: PaymentIntentLastPaymentError;
    /**
     * Populated when `status` is `canceled`, this is the time at which the PaymentIntent was canceled.
     * @type {string}
     * @memberof PaymentIntent
     */
    'canceled_at'?: string;
    /**
     * Reason for cancellation of this PaymentIntent, either user-provided (`duplicate`, `fraudulent`, `requested_by_customer`, or `abandoned`) or generated by Tilled internally (`automatic`).
     * @type {string}
     * @memberof PaymentIntent
     */
    'cancellation_reason'?: PaymentIntentCancellationReasonEnum;
    /**
     * Used to identify authorization requests that use stored credentials to improve authorization rates and reduce fraud.  `consumer_ad_hoc` Ad hoc consumer-initiated request  `merchant_ad_hoc` Unscheduled merchant-initiated request  `merchant_recurring` Scheduled, merchant-initiated recurring request
     * @type {string}
     * @memberof PaymentIntent
     */
    'occurrence_type'?: PaymentIntentOccurrenceTypeEnum;
    /**
     * ID of the subscription related to this PaymentIntent (if any).
     * @type {string}
     * @memberof PaymentIntent
     */
    'subscription_id'?: string;
}

export const PaymentIntentPaymentMethodTypesEnum = {
    Card: 'card',
    AchDebit: 'ach_debit',
    CardPresent: 'card_present',
    EftDebit: 'eft_debit'
} as const;

export type PaymentIntentPaymentMethodTypesEnum = typeof PaymentIntentPaymentMethodTypesEnum[keyof typeof PaymentIntentPaymentMethodTypesEnum];
export const PaymentIntentCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type PaymentIntentCurrencyEnum = typeof PaymentIntentCurrencyEnum[keyof typeof PaymentIntentCurrencyEnum];
export const PaymentIntentStatusEnum = {
    Canceled: 'canceled',
    Processing: 'processing',
    RequiresAction: 'requires_action',
    RequiresCapture: 'requires_capture',
    RequiresConfirmation: 'requires_confirmation',
    RequiresPaymentMethod: 'requires_payment_method',
    Succeeded: 'succeeded'
} as const;

export type PaymentIntentStatusEnum = typeof PaymentIntentStatusEnum[keyof typeof PaymentIntentStatusEnum];
export const PaymentIntentCaptureMethodEnum = {
    Automatic: 'automatic',
    Manual: 'manual'
} as const;

export type PaymentIntentCaptureMethodEnum = typeof PaymentIntentCaptureMethodEnum[keyof typeof PaymentIntentCaptureMethodEnum];
export const PaymentIntentCancellationReasonEnum = {
    Duplicate: 'duplicate',
    Fraudulent: 'fraudulent',
    RequestedByCustomer: 'requested_by_customer',
    Abandoned: 'abandoned',
    Automatic: 'automatic'
} as const;

export type PaymentIntentCancellationReasonEnum = typeof PaymentIntentCancellationReasonEnum[keyof typeof PaymentIntentCancellationReasonEnum];
export const PaymentIntentOccurrenceTypeEnum = {
    ConsumerAdHoc: 'consumer_ad_hoc',
    MerchantAdHoc: 'merchant_ad_hoc',
    MerchantRecurring: 'merchant_recurring'
} as const;

export type PaymentIntentOccurrenceTypeEnum = typeof PaymentIntentOccurrenceTypeEnum[keyof typeof PaymentIntentOccurrenceTypeEnum];

/**
 * 
 * @export
 * @interface PaymentIntentCancelParams
 */
export interface PaymentIntentCancelParams {
    /**
     * Reason for canceling this PaymentIntent. Possible values are `duplicate`, `fraudulent`, `requested_by_customer`, or `abandoned`
     * @type {string}
     * @memberof PaymentIntentCancelParams
     */
    'cancellation_reason'?: PaymentIntentCancelParamsCancellationReasonEnum;
}

export const PaymentIntentCancelParamsCancellationReasonEnum = {
    Duplicate: 'duplicate',
    Fraudulent: 'fraudulent',
    RequestedByCustomer: 'requested_by_customer',
    Abandoned: 'abandoned'
} as const;

export type PaymentIntentCancelParamsCancellationReasonEnum = typeof PaymentIntentCancelParamsCancellationReasonEnum[keyof typeof PaymentIntentCancelParamsCancellationReasonEnum];

/**
 * 
 * @export
 * @interface PaymentIntentCaptureParams
 */
export interface PaymentIntentCaptureParams {
    /**
     * The amount to capture from the PaymentIntent, which must be less than or equal to the original amount. Any additional amount will be automatically refunded. Defaults to the full `amount` if not provided.
     * @type {number}
     * @memberof PaymentIntentCaptureParams
     */
    'amount_to_capture'?: number;
    /**
     * The amount of the platform fee (if any) that will be requested to be applied to the payment and transferred to the `partner` account. The amount of the fee collected will be capped at the total payment amount.
     * @type {number}
     * @memberof PaymentIntentCaptureParams
     */
    'platform_fee_amount'?: number;
}
/**
 * 
 * @export
 * @interface PaymentIntentConfirmParams
 */
export interface PaymentIntentConfirmParams {
    /**
     * ID of the PaymentMethod to attach to this PaymentIntent.
     * @type {string}
     * @memberof PaymentIntentConfirmParams
     */
    'payment_method_id'?: string;
}
/**
 * 
 * @export
 * @interface PaymentIntentCreateParams
 */
export interface PaymentIntentCreateParams {
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value (i.e. `\'\'` or `null`) to them. All keys can be unset by posting an empty value (i.e. `{}` or `null`) to `metadata`.
     * @type {{ [key: string]: string; }}
     * @memberof PaymentIntentCreateParams
     */
    'metadata'?: { [key: string]: string; };
    /**
     * The list of payment method types (e.g. card) that this PaymentIntent is allowed to use.
     * @type {Array<string>}
     * @memberof PaymentIntentCreateParams
     */
    'payment_method_types': Array<PaymentIntentCreateParamsPaymentMethodTypesEnum>;
    /**
     * Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge $1.00)
     * @type {number}
     * @memberof PaymentIntentCreateParams
     */
    'amount': number;
    /**
     * The amount of the platform fee (if any) that will be requested to be applied to the payment and transferred to the `partner` account. The amount of the fee collected will be capped at the total payment amount.
     * @type {number}
     * @memberof PaymentIntentCreateParams
     */
    'platform_fee_amount'?: number;
    /**
     * Three-letter ISO currency code, in lowercase.
     * @type {string}
     * @memberof PaymentIntentCreateParams
     */
    'currency': PaymentIntentCreateParamsCurrencyEnum;
    /**
     * ID of the PaymentMethod to attach to this PaymentIntent.
     * @type {string}
     * @memberof PaymentIntentCreateParams
     */
    'payment_method_id'?: string;
    /**
     * Controls when the funds will be captured from the customer’s account.  `automatic` (Default) Tilled automatically captures funds when the customer authorizes the payment.  `manual` Place a hold on funds when the customer authorizes the payment, but don\'t capture the funds until later. Manual capture is not currently supported for card-present payment intents.
     * @type {string}
     * @memberof PaymentIntentCreateParams
     */
    'capture_method'?: PaymentIntentCreateParamsCaptureMethodEnum;
    /**
     * Set to \'true\' to attempt to confirm this PaymentIntent immediately. This parameter defaults to `false`.
     * @type {boolean}
     * @memberof PaymentIntentCreateParams
     */
    'confirm'?: boolean;
    /**
     * Provides information about a payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 20 characters for the concatenated descriptor.
     * @type {string}
     * @memberof PaymentIntentCreateParams
     */
    'statement_descriptor_suffix'?: string;
    /**
     * Used to identify authorization requests that use stored credentials to improve authorization rates and reduce fraud.  `consumer_ad_hoc` Ad hoc consumer-initiated request  `merchant_ad_hoc` Unscheduled merchant-initiated request  `merchant_recurring` Scheduled, merchant-initiated recurring request
     * @type {string}
     * @memberof PaymentIntentCreateParams
     */
    'occurrence_type'?: PaymentIntentCreateParamsOccurrenceTypeEnum;
    /**
     * 
     * @type {PaymentIntentLevel3}
     * @memberof PaymentIntentCreateParams
     */
    'level3'?: PaymentIntentLevel3;
}

export const PaymentIntentCreateParamsPaymentMethodTypesEnum = {
    Card: 'card',
    AchDebit: 'ach_debit',
    CardPresent: 'card_present',
    EftDebit: 'eft_debit'
} as const;

export type PaymentIntentCreateParamsPaymentMethodTypesEnum = typeof PaymentIntentCreateParamsPaymentMethodTypesEnum[keyof typeof PaymentIntentCreateParamsPaymentMethodTypesEnum];
export const PaymentIntentCreateParamsCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type PaymentIntentCreateParamsCurrencyEnum = typeof PaymentIntentCreateParamsCurrencyEnum[keyof typeof PaymentIntentCreateParamsCurrencyEnum];
export const PaymentIntentCreateParamsCaptureMethodEnum = {
    Automatic: 'automatic',
    Manual: 'manual'
} as const;

export type PaymentIntentCreateParamsCaptureMethodEnum = typeof PaymentIntentCreateParamsCaptureMethodEnum[keyof typeof PaymentIntentCreateParamsCaptureMethodEnum];
export const PaymentIntentCreateParamsOccurrenceTypeEnum = {
    ConsumerAdHoc: 'consumer_ad_hoc',
    MerchantAdHoc: 'merchant_ad_hoc',
    MerchantRecurring: 'merchant_recurring'
} as const;

export type PaymentIntentCreateParamsOccurrenceTypeEnum = typeof PaymentIntentCreateParamsOccurrenceTypeEnum[keyof typeof PaymentIntentCreateParamsOccurrenceTypeEnum];

/**
 * 
 * @export
 * @interface PaymentIntentError
 */
export interface PaymentIntentError {
    /**
     * Error code explaining reason for charge failure.
     * @type {string}
     * @memberof PaymentIntentError
     */
    'code'?: PaymentIntentErrorCodeEnum;
    /**
     * The id of the failed charge.
     * @type {string}
     * @memberof PaymentIntentError
     */
    'charge_id': string;
    /**
     * A human-readable message providing more details about the error.
     * @type {string}
     * @memberof PaymentIntentError
     */
    'message': string;
}

export const PaymentIntentErrorCodeEnum = {
    InsufficientFunds: 'insufficient_funds',
    AvsCheckFailed: 'avs_check_failed',
    GenericDecline: 'generic_decline',
    CallIssuer: 'call_issuer',
    ExpiredCard: 'expired_card',
    PickupCard: 'pickup_card',
    InvalidNumber: 'invalid_number',
    LimitExceeded: 'limit_exceeded',
    NotPermitted: 'not_permitted',
    IncorrectCvc: 'incorrect_cvc',
    ServiceNotAllowed: 'service_not_allowed',
    InvalidExpiry: 'invalid_expiry',
    CardNotSupported: 'card_not_supported',
    RestrictedCard: 'restricted_card',
    Fraudulent: 'fraudulent',
    ProcessingError: 'processing_error',
    BankAccountBlocked: 'bank_account_blocked',
    InternalError: 'internal_error'
} as const;

export type PaymentIntentErrorCodeEnum = typeof PaymentIntentErrorCodeEnum[keyof typeof PaymentIntentErrorCodeEnum];

/**
 * The payment error encountered in the previous PaymentIntent confirmation. It will be cleared if the PaymentIntent is later updated for any reason.
 * @export
 * @interface PaymentIntentLastPaymentError
 */
export interface PaymentIntentLastPaymentError {
    /**
     * Error code explaining reason for charge failure.
     * @type {string}
     * @memberof PaymentIntentLastPaymentError
     */
    'code'?: PaymentIntentLastPaymentErrorCodeEnum;
    /**
     * The id of the failed charge.
     * @type {string}
     * @memberof PaymentIntentLastPaymentError
     */
    'charge_id': string;
    /**
     * A human-readable message providing more details about the error.
     * @type {string}
     * @memberof PaymentIntentLastPaymentError
     */
    'message': string;
}

export const PaymentIntentLastPaymentErrorCodeEnum = {
    InsufficientFunds: 'insufficient_funds',
    AvsCheckFailed: 'avs_check_failed',
    GenericDecline: 'generic_decline',
    CallIssuer: 'call_issuer',
    ExpiredCard: 'expired_card',
    PickupCard: 'pickup_card',
    InvalidNumber: 'invalid_number',
    LimitExceeded: 'limit_exceeded',
    NotPermitted: 'not_permitted',
    IncorrectCvc: 'incorrect_cvc',
    ServiceNotAllowed: 'service_not_allowed',
    InvalidExpiry: 'invalid_expiry',
    CardNotSupported: 'card_not_supported',
    RestrictedCard: 'restricted_card',
    Fraudulent: 'fraudulent',
    ProcessingError: 'processing_error',
    BankAccountBlocked: 'bank_account_blocked',
    InternalError: 'internal_error'
} as const;

export type PaymentIntentLastPaymentErrorCodeEnum = typeof PaymentIntentLastPaymentErrorCodeEnum[keyof typeof PaymentIntentLastPaymentErrorCodeEnum];

/**
 * Level 2 and Level 3 (L2/L3) credit card processing refers to certain B2B card transactions for which the merchant might be eligible for lower credit card interchange rates. The lower rates may be available for merchants who provide more detailed information when processing card-not-present transactions.
 * @export
 * @interface PaymentIntentLevel3
 */
export interface PaymentIntentLevel3 {
    /**
     * More detailed information about the items being purchased. Max length is 25.
     * @type {Array<LineItem>}
     * @memberof PaymentIntentLevel3
     */
    'line_items': Array<LineItem>;
    /**
     * Postal/zip code of the address to which the purchased goods will be delivered. This field can be identical to the `shipping_from_zip` if the customer is present and takes immediate possession of the goods.
     * @type {string}
     * @memberof PaymentIntentLevel3
     */
    'shipping_address_zip': string;
    /**
     * 2-digit Country code (e.g. \'US\', \'CA\') of the address to which the purchased goods will be delivered.
     * @type {string}
     * @memberof PaymentIntentLevel3
     */
    'shipping_address_country': string;
    /**
     * The shipping or freight portion of the total transaction amount, in minor units.
     * @type {number}
     * @memberof PaymentIntentLevel3
     */
    'shipping_amount': number;
    /**
     * Postal/zip code of the address from which the purchased goods are being shipped
     * @type {string}
     * @memberof PaymentIntentLevel3
     */
    'shipping_from_zip': string;
    /**
     * Duty associated with the import of the purchased goods on the total amount for the order, in minor units.
     * @type {number}
     * @memberof PaymentIntentLevel3
     */
    'duty_amount': number;
}
/**
 * The PaymentMethod used in this PaymentIntent.
 * @export
 * @interface PaymentIntentPaymentMethod
 */
export interface PaymentIntentPaymentMethod {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof PaymentIntentPaymentMethod
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof PaymentIntentPaymentMethod
     */
    'created_at': string;
    /**
     * The type of the PaymentMethod. An additional hash is included on the PaymentMethod with a name matching this value. It contains additional information specific to the PaymentMethod type.
     * @type {string}
     * @memberof PaymentIntentPaymentMethod
     */
    'type': PaymentIntentPaymentMethodTypeEnum;
    /**
     * 
     * @type {PaymentMethodCard}
     * @memberof PaymentIntentPaymentMethod
     */
    'card'?: PaymentMethodCard;
    /**
     * 
     * @type {PaymentMethodCardPresent}
     * @memberof PaymentIntentPaymentMethod
     */
    'card_present'?: PaymentMethodCardPresent;
    /**
     * 
     * @type {PaymentMethodAchDebit}
     * @memberof PaymentIntentPaymentMethod
     */
    'ach_debit'?: PaymentMethodAchDebit;
    /**
     * 
     * @type {PaymentMethodEftDebit}
     * @memberof PaymentIntentPaymentMethod
     */
    'eft_debit'?: PaymentMethodEftDebit;
    /**
     * 
     * @type {PaymentMethodBillingDetails}
     * @memberof PaymentIntentPaymentMethod
     */
    'billing_details'?: PaymentMethodBillingDetails;
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof PaymentIntentPaymentMethod
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof PaymentIntentPaymentMethod
     */
    'id': string;
    /**
     * The ID of the Customer to which this PaymentMethod is saved.
     * @type {string}
     * @memberof PaymentIntentPaymentMethod
     */
    'customer_id'?: string;
    /**
     * A customer provided name for the PaymentMethod.
     * @type {string}
     * @memberof PaymentIntentPaymentMethod
     */
    'nick_name'?: string;
    /**
     * The time at which this PaymentMethod expires and is no longer available. PaymentMethods are created using a token generated by Tilled.js representing the details of a payment method (e.g. card or bank details). This token is a single-use token with an expiration date. Use `/payment-methods/{id}/attach` to make this PaymentMethod reusable.
     * @type {string}
     * @memberof PaymentIntentPaymentMethod
     */
    'expires_at'?: string;
    /**
     * Indicates whether or not the payment method can be used to make a charge. When a payment method is created via Tilled.js, a payment method is only capable of being used once (i.e. single-use) unless it is attached to a customer, in which case it becomes reusable.
     * @type {boolean}
     * @memberof PaymentIntentPaymentMethod
     */
    'chargeable': boolean;
    /**
     * The terminal reader integration mode. ie Will this be run through a semi-integrated mode or SDK mode?
     * @type {string}
     * @memberof PaymentIntentPaymentMethod
     */
    'terminal_reader_integration_mode'?: PaymentIntentPaymentMethodTerminalReaderIntegrationModeEnum;
    /**
     * 
     * @type {PaymentMethodTerminalReader}
     * @memberof PaymentIntentPaymentMethod
     */
    'terminal_reader'?: PaymentMethodTerminalReader;
}

export const PaymentIntentPaymentMethodTypeEnum = {
    Card: 'card',
    AchDebit: 'ach_debit',
    CardPresent: 'card_present',
    EftDebit: 'eft_debit'
} as const;

export type PaymentIntentPaymentMethodTypeEnum = typeof PaymentIntentPaymentMethodTypeEnum[keyof typeof PaymentIntentPaymentMethodTypeEnum];
export const PaymentIntentPaymentMethodTerminalReaderIntegrationModeEnum = {
    Semi: 'semi',
    Sdk: 'sdk'
} as const;

export type PaymentIntentPaymentMethodTerminalReaderIntegrationModeEnum = typeof PaymentIntentPaymentMethodTerminalReaderIntegrationModeEnum[keyof typeof PaymentIntentPaymentMethodTerminalReaderIntegrationModeEnum];

/**
 * 
 * @export
 * @interface PaymentIntentUpdateParams
 */
export interface PaymentIntentUpdateParams {
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value (i.e. `\'\'` or `null`) to them. All keys can be unset by posting an empty value (i.e. `{}` or `null`) to `metadata`.
     * @type {{ [key: string]: string; }}
     * @memberof PaymentIntentUpdateParams
     */
    'metadata'?: { [key: string]: string; };
    /**
     * The list of payment method types (e.g. card) that this PaymentIntent is allowed to use.
     * @type {Array<string>}
     * @memberof PaymentIntentUpdateParams
     */
    'payment_method_types'?: Array<PaymentIntentUpdateParamsPaymentMethodTypesEnum>;
    /**
     * Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge $1.00)
     * @type {number}
     * @memberof PaymentIntentUpdateParams
     */
    'amount'?: number;
    /**
     * The amount of the platform fee (if any) that will be requested to be applied to the payment and transferred to the `partner` account. The amount of the fee collected will be capped at the total payment amount.
     * @type {number}
     * @memberof PaymentIntentUpdateParams
     */
    'platform_fee_amount'?: number;
    /**
     * Three-letter ISO currency code, in lowercase.
     * @type {string}
     * @memberof PaymentIntentUpdateParams
     */
    'currency'?: PaymentIntentUpdateParamsCurrencyEnum;
    /**
     * ID of the PaymentMethod to attach to this PaymentIntent.
     * @type {string}
     * @memberof PaymentIntentUpdateParams
     */
    'payment_method_id'?: string;
    /**
     * Controls when the funds will be captured from the customer’s account.  `automatic` (Default) Tilled automatically captures funds when the customer authorizes the payment.  `manual` Place a hold on funds when the customer authorizes the payment, but don\'t capture the funds until later. Manual capture is not currently supported for card-present payment intents.
     * @type {string}
     * @memberof PaymentIntentUpdateParams
     */
    'capture_method'?: PaymentIntentUpdateParamsCaptureMethodEnum;
    /**
     * Provides information about a payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 20 characters for the concatenated descriptor.
     * @type {string}
     * @memberof PaymentIntentUpdateParams
     */
    'statement_descriptor_suffix'?: string;
    /**
     * Used to identify authorization requests that use stored credentials to improve authorization rates and reduce fraud.  `consumer_ad_hoc` Ad hoc consumer-initiated request  `merchant_ad_hoc` Unscheduled merchant-initiated request  `merchant_recurring` Scheduled, merchant-initiated recurring request
     * @type {string}
     * @memberof PaymentIntentUpdateParams
     */
    'occurrence_type'?: PaymentIntentUpdateParamsOccurrenceTypeEnum;
    /**
     * 
     * @type {PaymentIntentLevel3}
     * @memberof PaymentIntentUpdateParams
     */
    'level3'?: PaymentIntentLevel3;
}

export const PaymentIntentUpdateParamsPaymentMethodTypesEnum = {
    Card: 'card',
    AchDebit: 'ach_debit',
    CardPresent: 'card_present',
    EftDebit: 'eft_debit'
} as const;

export type PaymentIntentUpdateParamsPaymentMethodTypesEnum = typeof PaymentIntentUpdateParamsPaymentMethodTypesEnum[keyof typeof PaymentIntentUpdateParamsPaymentMethodTypesEnum];
export const PaymentIntentUpdateParamsCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type PaymentIntentUpdateParamsCurrencyEnum = typeof PaymentIntentUpdateParamsCurrencyEnum[keyof typeof PaymentIntentUpdateParamsCurrencyEnum];
export const PaymentIntentUpdateParamsCaptureMethodEnum = {
    Automatic: 'automatic',
    Manual: 'manual'
} as const;

export type PaymentIntentUpdateParamsCaptureMethodEnum = typeof PaymentIntentUpdateParamsCaptureMethodEnum[keyof typeof PaymentIntentUpdateParamsCaptureMethodEnum];
export const PaymentIntentUpdateParamsOccurrenceTypeEnum = {
    ConsumerAdHoc: 'consumer_ad_hoc',
    MerchantAdHoc: 'merchant_ad_hoc',
    MerchantRecurring: 'merchant_recurring'
} as const;

export type PaymentIntentUpdateParamsOccurrenceTypeEnum = typeof PaymentIntentUpdateParamsOccurrenceTypeEnum[keyof typeof PaymentIntentUpdateParamsOccurrenceTypeEnum];

/**
 * 
 * @export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof PaymentMethod
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof PaymentMethod
     */
    'created_at': string;
    /**
     * The type of the PaymentMethod. An additional hash is included on the PaymentMethod with a name matching this value. It contains additional information specific to the PaymentMethod type.
     * @type {string}
     * @memberof PaymentMethod
     */
    'type': PaymentMethodTypeEnum;
    /**
     * 
     * @type {PaymentMethodCard}
     * @memberof PaymentMethod
     */
    'card'?: PaymentMethodCard;
    /**
     * 
     * @type {PaymentMethodCardPresent}
     * @memberof PaymentMethod
     */
    'card_present'?: PaymentMethodCardPresent;
    /**
     * 
     * @type {PaymentMethodAchDebit}
     * @memberof PaymentMethod
     */
    'ach_debit'?: PaymentMethodAchDebit;
    /**
     * 
     * @type {PaymentMethodEftDebit}
     * @memberof PaymentMethod
     */
    'eft_debit'?: PaymentMethodEftDebit;
    /**
     * 
     * @type {PaymentMethodBillingDetails}
     * @memberof PaymentMethod
     */
    'billing_details'?: PaymentMethodBillingDetails;
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof PaymentMethod
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof PaymentMethod
     */
    'id': string;
    /**
     * The ID of the Customer to which this PaymentMethod is saved.
     * @type {string}
     * @memberof PaymentMethod
     */
    'customer_id'?: string;
    /**
     * A customer provided name for the PaymentMethod.
     * @type {string}
     * @memberof PaymentMethod
     */
    'nick_name'?: string;
    /**
     * The time at which this PaymentMethod expires and is no longer available. PaymentMethods are created using a token generated by Tilled.js representing the details of a payment method (e.g. card or bank details). This token is a single-use token with an expiration date. Use `/payment-methods/{id}/attach` to make this PaymentMethod reusable.
     * @type {string}
     * @memberof PaymentMethod
     */
    'expires_at'?: string;
    /**
     * Indicates whether or not the payment method can be used to make a charge. When a payment method is created via Tilled.js, a payment method is only capable of being used once (i.e. single-use) unless it is attached to a customer, in which case it becomes reusable.
     * @type {boolean}
     * @memberof PaymentMethod
     */
    'chargeable': boolean;
    /**
     * The terminal reader integration mode. ie Will this be run through a semi-integrated mode or SDK mode?
     * @type {string}
     * @memberof PaymentMethod
     */
    'terminal_reader_integration_mode'?: PaymentMethodTerminalReaderIntegrationModeEnum;
    /**
     * 
     * @type {PaymentMethodTerminalReader}
     * @memberof PaymentMethod
     */
    'terminal_reader'?: PaymentMethodTerminalReader;
}

export const PaymentMethodTypeEnum = {
    Card: 'card',
    AchDebit: 'ach_debit',
    CardPresent: 'card_present',
    EftDebit: 'eft_debit'
} as const;

export type PaymentMethodTypeEnum = typeof PaymentMethodTypeEnum[keyof typeof PaymentMethodTypeEnum];
export const PaymentMethodTerminalReaderIntegrationModeEnum = {
    Semi: 'semi',
    Sdk: 'sdk'
} as const;

export type PaymentMethodTerminalReaderIntegrationModeEnum = typeof PaymentMethodTerminalReaderIntegrationModeEnum[keyof typeof PaymentMethodTerminalReaderIntegrationModeEnum];

/**
 * If this is a `ach_debit` PaymentMethod, this hash contains details about the ACH Debit bank account.
 * @export
 * @interface PaymentMethodAchDebit
 */
export interface PaymentMethodAchDebit {
    /**
     * Name of the bank associated to this Ach Debit.
     * @type {string}
     * @memberof PaymentMethodAchDebit
     */
    'bank_name'?: string;
    /**
     * The last 2 digits of the bank acount number.
     * @type {string}
     * @memberof PaymentMethodAchDebit
     */
    'last2'?: string;
    /**
     * Nine-digit code that identifies specific financial institution in the US.
     * @type {string}
     * @memberof PaymentMethodAchDebit
     */
    'routing_number'?: string;
    /**
     * Account type
     * @type {string}
     * @memberof PaymentMethodAchDebit
     */
    'account_type'?: PaymentMethodAchDebitAccountTypeEnum;
}

export const PaymentMethodAchDebitAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings',
    Unknown: 'unknown'
} as const;

export type PaymentMethodAchDebitAccountTypeEnum = typeof PaymentMethodAchDebitAccountTypeEnum[keyof typeof PaymentMethodAchDebitAccountTypeEnum];

/**
 * 
 * @export
 * @interface PaymentMethodAttachParams
 */
export interface PaymentMethodAttachParams {
    /**
     * The ID of the Customer to which to attach the PaymentMethod.
     * @type {string}
     * @memberof PaymentMethodAttachParams
     */
    'customer_id': string;
}
/**
 * Billing information associated with the PaymentMethod that may be used or required by particular types of payment methods. (e.g. it is required for `ach_debit` and Apple Pay)
 * @export
 * @interface PaymentMethodBillingDetails
 */
export interface PaymentMethodBillingDetails {
    /**
     * 
     * @type {PaymentMethodBillingDetailsAddress}
     * @memberof PaymentMethodBillingDetails
     */
    'address'?: PaymentMethodBillingDetailsAddress;
    /**
     * Email address
     * @type {string}
     * @memberof PaymentMethodBillingDetails
     */
    'email'?: string;
    /**
     * Full name
     * @type {string}
     * @memberof PaymentMethodBillingDetails
     */
    'name'?: string;
    /**
     * Billing phone number (including extension)
     * @type {string}
     * @memberof PaymentMethodBillingDetails
     */
    'phone'?: string;
}
/**
 * The billing address.
 * @export
 * @interface PaymentMethodBillingDetailsAddress
 */
export interface PaymentMethodBillingDetailsAddress {
    /**
     * First line of the street address
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'street'?: string;
    /**
     * Second line of the street address, if required.
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'street2'?: string;
    /**
     * City where address is located.
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'city'?: string;
    /**
     * State/province/region of the address. For US and CA use 2-digit state/province codes (e.g. \'AL\', \'AK\', \'BC\', \'ON\', \'etc\'.)
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'state'?: string;
    /**
     * Zip code or postal code of the address. No special characters.
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'zip'?: string;
    /**
     * 2-digit Country code (e.g. \'US\', \'CA\') [See ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'country'?: string;
}
/**
 * If this is a `card` PaymentMethod, this hash contains the user\'s card details.
 * @export
 * @interface PaymentMethodCard
 */
export interface PaymentMethodCard {
    /**
     * Type of card.
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'brand'?: PaymentMethodCardBrandEnum;
    /**
     * Last 4 digits of the card.
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'last4'?: string;
    /**
     * Two-digit number representing the card\'s expiration month.
     * @type {number}
     * @memberof PaymentMethodCard
     */
    'exp_month'?: number;
    /**
     * Two- or four-digit number representing the card\'s expiration year.
     * @type {number}
     * @memberof PaymentMethodCard
     */
    'exp_year'?: number;
    /**
     * 
     * @type {CardDetailsChecks}
     * @memberof PaymentMethodCard
     */
    'checks'?: CardDetailsChecks;
    /**
     * The card holder\'s name.
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'holder_name'?: string;
}

export const PaymentMethodCardBrandEnum = {
    Amex: 'amex',
    Diners: 'diners',
    Discover: 'discover',
    Jcb: 'jcb',
    Maestro: 'maestro',
    Mastercard: 'mastercard',
    Solo: 'solo',
    Visa: 'visa',
    VisaDebit: 'visa_debit',
    VisaElectron: 'visa_electron',
    Unknown: 'unknown'
} as const;

export type PaymentMethodCardBrandEnum = typeof PaymentMethodCardBrandEnum[keyof typeof PaymentMethodCardBrandEnum];

/**
 * If this is a `card_present` PaymentMethod, this hash contains the user\'s card details.
 * @export
 * @interface PaymentMethodCardPresent
 */
export interface PaymentMethodCardPresent {
    /**
     * Type of card.
     * @type {string}
     * @memberof PaymentMethodCardPresent
     */
    'brand'?: PaymentMethodCardPresentBrandEnum;
    /**
     * Last 4 digits of the card.
     * @type {string}
     * @memberof PaymentMethodCardPresent
     */
    'last4'?: string;
    /**
     * Two-digit number representing the card\'s expiration month.
     * @type {number}
     * @memberof PaymentMethodCardPresent
     */
    'exp_month'?: number;
    /**
     * Two- or four-digit number representing the card\'s expiration year.
     * @type {number}
     * @memberof PaymentMethodCardPresent
     */
    'exp_year'?: number;
    /**
     * 
     * @type {CardDetailsChecks}
     * @memberof PaymentMethodCardPresent
     */
    'checks'?: CardDetailsChecks;
    /**
     * The card holder\'s name.
     * @type {string}
     * @memberof PaymentMethodCardPresent
     */
    'holder_name'?: string;
}

export const PaymentMethodCardPresentBrandEnum = {
    Amex: 'amex',
    Diners: 'diners',
    Discover: 'discover',
    Jcb: 'jcb',
    Maestro: 'maestro',
    Mastercard: 'mastercard',
    Solo: 'solo',
    Visa: 'visa',
    VisaDebit: 'visa_debit',
    VisaElectron: 'visa_electron',
    Unknown: 'unknown'
} as const;

export type PaymentMethodCardPresentBrandEnum = typeof PaymentMethodCardPresentBrandEnum[keyof typeof PaymentMethodCardPresentBrandEnum];

/**
 * 
 * @export
 * @interface PaymentMethodCreateAchDebitSingleUseTokenParams
 */
export interface PaymentMethodCreateAchDebitSingleUseTokenParams {
    /**
     * 
     * @type {PaymentMethodCreateAchDebitSingleUseTokenParamsBillingDetails}
     * @memberof PaymentMethodCreateAchDebitSingleUseTokenParams
     */
    'billing_details': PaymentMethodCreateAchDebitSingleUseTokenParamsBillingDetails;
    /**
     * 
     * @type {PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebit}
     * @memberof PaymentMethodCreateAchDebitSingleUseTokenParams
     */
    'ach_debit': PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebit;
}
/**
 * Details about the ACH Direct Debit bank account.
 * @export
 * @interface PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebit
 */
export interface PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebit {
    /**
     * Bank account type.
     * @type {string}
     * @memberof PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebit
     */
    'account_type': PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebitAccountTypeEnum;
    /**
     * This is the bank account number
     * @type {string}
     * @memberof PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebit
     */
    'account_number': string;
    /**
     * The sequence of 9-digits used by banks to identify specific financial institutions (i.e. ABA routing number)
     * @type {string}
     * @memberof PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebit
     */
    'routing_number': string;
    /**
     * The name of the customer or company that owns the bank account.
     * @type {string}
     * @memberof PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebit
     */
    'account_holder_name': string;
}

export const PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebitAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings'
} as const;

export type PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebitAccountTypeEnum = typeof PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebitAccountTypeEnum[keyof typeof PaymentMethodCreateAchDebitSingleUseTokenParamsAchDebitAccountTypeEnum];

/**
 * Billing information associated with the PaymentMethod that may be used or required by particular types of payment methods.
 * @export
 * @interface PaymentMethodCreateAchDebitSingleUseTokenParamsBillingDetails
 */
export interface PaymentMethodCreateAchDebitSingleUseTokenParamsBillingDetails {
    /**
     * 
     * @type {PaymentMethodCreateDebitSingleUseTokenParamsBillingDetailsAddress}
     * @memberof PaymentMethodCreateAchDebitSingleUseTokenParamsBillingDetails
     */
    'address': PaymentMethodCreateDebitSingleUseTokenParamsBillingDetailsAddress;
    /**
     * Email address
     * @type {string}
     * @memberof PaymentMethodCreateAchDebitSingleUseTokenParamsBillingDetails
     */
    'email'?: string;
    /**
     * Full name
     * @type {string}
     * @memberof PaymentMethodCreateAchDebitSingleUseTokenParamsBillingDetails
     */
    'name'?: string;
    /**
     * Billing phone number (including extension)
     * @type {string}
     * @memberof PaymentMethodCreateAchDebitSingleUseTokenParamsBillingDetails
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodCreateDebitSingleUseTokenParamsBillingDetails
 */
export interface PaymentMethodCreateDebitSingleUseTokenParamsBillingDetails {
    /**
     * 
     * @type {PaymentMethodCreateDebitSingleUseTokenParamsBillingDetailsAddress}
     * @memberof PaymentMethodCreateDebitSingleUseTokenParamsBillingDetails
     */
    'address': PaymentMethodCreateDebitSingleUseTokenParamsBillingDetailsAddress;
    /**
     * Email address
     * @type {string}
     * @memberof PaymentMethodCreateDebitSingleUseTokenParamsBillingDetails
     */
    'email'?: string;
    /**
     * Full name
     * @type {string}
     * @memberof PaymentMethodCreateDebitSingleUseTokenParamsBillingDetails
     */
    'name'?: string;
    /**
     * Billing phone number (including extension)
     * @type {string}
     * @memberof PaymentMethodCreateDebitSingleUseTokenParamsBillingDetails
     */
    'phone'?: string;
}
/**
 * The billing address.
 * @export
 * @interface PaymentMethodCreateDebitSingleUseTokenParamsBillingDetailsAddress
 */
export interface PaymentMethodCreateDebitSingleUseTokenParamsBillingDetailsAddress {
    /**
     * First line of the street address
     * @type {string}
     * @memberof PaymentMethodCreateDebitSingleUseTokenParamsBillingDetailsAddress
     */
    'street': string;
    /**
     * Second line of the street address, if required.
     * @type {string}
     * @memberof PaymentMethodCreateDebitSingleUseTokenParamsBillingDetailsAddress
     */
    'street2'?: string;
    /**
     * City where address is located.
     * @type {string}
     * @memberof PaymentMethodCreateDebitSingleUseTokenParamsBillingDetailsAddress
     */
    'city': string;
    /**
     * State/province/region of the address. For US and CA use 2-digit state/province codes (e.g. \'AL\', \'AK\', \'BC\', \'ON\', \'etc\'.)
     * @type {string}
     * @memberof PaymentMethodCreateDebitSingleUseTokenParamsBillingDetailsAddress
     */
    'state': string;
    /**
     * Zip code or postal code of the address. No special characters.
     * @type {string}
     * @memberof PaymentMethodCreateDebitSingleUseTokenParamsBillingDetailsAddress
     */
    'zip': string;
    /**
     * 2-digit Country code (e.g. \'US\', \'CA\') [See ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     * @type {string}
     * @memberof PaymentMethodCreateDebitSingleUseTokenParamsBillingDetailsAddress
     */
    'country': string;
}
/**
 * 
 * @export
 * @interface PaymentMethodCreateParams
 */
export interface PaymentMethodCreateParams {
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value (i.e. `\'\'` or `null`) to them. All keys can be unset by posting an empty value (i.e. `{}` or `null`) to `metadata`.
     * @type {{ [key: string]: string; }}
     * @memberof PaymentMethodCreateParams
     */
    'metadata'?: { [key: string]: string; };
    /**
     * The type of the PaymentMethod. An additional hash is included on the PaymentMethod with a name matching this value. It contains additional information specific to the PaymentMethod type.
     * @type {string}
     * @memberof PaymentMethodCreateParams
     */
    'type': PaymentMethodCreateParamsTypeEnum;
    /**
     * A token generated by Tilled.js representing the details of a payment method (e.g. card or bank details)
     * @type {string}
     * @memberof PaymentMethodCreateParams
     */
    'payment_token'?: string;
    /**
     * A customer provided name for the PaymentMethod.
     * @type {string}
     * @memberof PaymentMethodCreateParams
     */
    'nick_name'?: string;
    /**
     * 
     * @type {PaymentMethodCreateParamsBillingDetails}
     * @memberof PaymentMethodCreateParams
     */
    'billing_details'?: PaymentMethodCreateParamsBillingDetails;
    /**
     * 
     * @type {PaymentMethodCreateParamsAchDebit}
     * @memberof PaymentMethodCreateParams
     */
    'ach_debit'?: PaymentMethodCreateParamsAchDebit;
    /**
     * 
     * @type {PaymentMethodCreateParamsEftDebit}
     * @memberof PaymentMethodCreateParams
     */
    'eft_debit'?: PaymentMethodCreateParamsEftDebit;
    /**
     * 
     * @type {PaymentMethodCreateParamsCard}
     * @memberof PaymentMethodCreateParams
     */
    'card'?: PaymentMethodCreateParamsCard;
    /**
     * [Beta] If this is a `card_present` PaymentMethod, this is the id of terminal reader you want to use to collect card information.
     * @type {string}
     * @memberof PaymentMethodCreateParams
     */
    'terminal_reader_id'?: string;
    /**
     * [Beta] If this is a `card_present` PaymentMethod, this is integration mode for the payment.
     * @type {string}
     * @memberof PaymentMethodCreateParams
     */
    'terminal_reader_integration_mode'?: PaymentMethodCreateParamsTerminalReaderIntegrationModeEnum;
}

export const PaymentMethodCreateParamsTypeEnum = {
    Card: 'card',
    AchDebit: 'ach_debit',
    CardPresent: 'card_present',
    EftDebit: 'eft_debit'
} as const;

export type PaymentMethodCreateParamsTypeEnum = typeof PaymentMethodCreateParamsTypeEnum[keyof typeof PaymentMethodCreateParamsTypeEnum];
export const PaymentMethodCreateParamsTerminalReaderIntegrationModeEnum = {
    Semi: 'semi',
    Sdk: 'sdk'
} as const;

export type PaymentMethodCreateParamsTerminalReaderIntegrationModeEnum = typeof PaymentMethodCreateParamsTerminalReaderIntegrationModeEnum[keyof typeof PaymentMethodCreateParamsTerminalReaderIntegrationModeEnum];

/**
 * If this is an `ach_debit` PaymentMethod, this hash contains details about the ACH Direct Debit bank account.
 * @export
 * @interface PaymentMethodCreateParamsAchDebit
 */
export interface PaymentMethodCreateParamsAchDebit {
    /**
     * Bank account type.
     * @type {string}
     * @memberof PaymentMethodCreateParamsAchDebit
     */
    'account_type': PaymentMethodCreateParamsAchDebitAccountTypeEnum;
    /**
     * This is the bank account number
     * @type {string}
     * @memberof PaymentMethodCreateParamsAchDebit
     */
    'account_number': string;
    /**
     * The sequence of 9-digits used by banks to identify specific financial institutions (i.e. ABA routing number)
     * @type {string}
     * @memberof PaymentMethodCreateParamsAchDebit
     */
    'routing_number': string;
    /**
     * The name of the customer or company that owns the bank account.
     * @type {string}
     * @memberof PaymentMethodCreateParamsAchDebit
     */
    'account_holder_name': string;
}

export const PaymentMethodCreateParamsAchDebitAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings'
} as const;

export type PaymentMethodCreateParamsAchDebitAccountTypeEnum = typeof PaymentMethodCreateParamsAchDebitAccountTypeEnum[keyof typeof PaymentMethodCreateParamsAchDebitAccountTypeEnum];

/**
 * Billing information associated with the PaymentMethod that may be used or required by most types of payment methods.
 * @export
 * @interface PaymentMethodCreateParamsBillingDetails
 */
export interface PaymentMethodCreateParamsBillingDetails {
    /**
     * 
     * @type {PaymentMethodBillingDetailsAddress}
     * @memberof PaymentMethodCreateParamsBillingDetails
     */
    'address'?: PaymentMethodBillingDetailsAddress;
    /**
     * Email address
     * @type {string}
     * @memberof PaymentMethodCreateParamsBillingDetails
     */
    'email'?: string;
    /**
     * Full name
     * @type {string}
     * @memberof PaymentMethodCreateParamsBillingDetails
     */
    'name'?: string;
    /**
     * Billing phone number (including extension)
     * @type {string}
     * @memberof PaymentMethodCreateParamsBillingDetails
     */
    'phone'?: string;
}
/**
 * If this is a `card` PaymentMethod, this hash contains the user\'s card details. When providing a card number, you must meet the requirements for PCI compliance. We strongly recommend using Tilled.js instead of interacting with this API directly.
 * @export
 * @interface PaymentMethodCreateParamsCard
 */
export interface PaymentMethodCreateParamsCard {
    /**
     * The card\'s CVC. It is highly recommended to always include this value.
     * @type {string}
     * @memberof PaymentMethodCreateParamsCard
     */
    'cvc'?: string;
    /**
     * Two-digit number representing the card\'s expiration month.
     * @type {number}
     * @memberof PaymentMethodCreateParamsCard
     */
    'exp_month': number;
    /**
     * Four-digit number representing the card\'s expiration year.
     * @type {number}
     * @memberof PaymentMethodCreateParamsCard
     */
    'exp_year': number;
    /**
     * The card number, as a string without any separators.
     * @type {string}
     * @memberof PaymentMethodCreateParamsCard
     */
    'number': string;
}
/**
 * If this is an `eft_debit` PaymentMethod, this hash contains details about the EFT Direct Debit bank account.
 * @export
 * @interface PaymentMethodCreateParamsEftDebit
 */
export interface PaymentMethodCreateParamsEftDebit {
    /**
     * This is the bank account number
     * @type {string}
     * @memberof PaymentMethodCreateParamsEftDebit
     */
    'account_number': string;
    /**
     * The name of the customer or company that owns the bank account.
     * @type {string}
     * @memberof PaymentMethodCreateParamsEftDebit
     */
    'account_holder_name': string;
    /**
     * The sequence of three-digits used by banks to identify specific financial institutions
     * @type {string}
     * @memberof PaymentMethodCreateParamsEftDebit
     */
    'institution_id': string;
    /**
     * The sequence of five-digits used by banks to identify specific financial institution\'s branch
     * @type {string}
     * @memberof PaymentMethodCreateParamsEftDebit
     */
    'transit_number': string;
}
/**
 * If this is a `eft_debit` PaymentMethod, this hash contains details about the EFT Debit bank account.
 * @export
 * @interface PaymentMethodEftDebit
 */
export interface PaymentMethodEftDebit {
    /**
     * Name of the bank associated to this Eft Debit.
     * @type {string}
     * @memberof PaymentMethodEftDebit
     */
    'bank_name'?: string;
    /**
     * The last 2 digits of the bank account number.
     * @type {string}
     * @memberof PaymentMethodEftDebit
     */
    'last2'?: string;
    /**
     * The sequence of five-digits used by banks to identify specific financial institution\'s branch
     * @type {string}
     * @memberof PaymentMethodEftDebit
     */
    'transit_number'?: string;
    /**
     * The sequence of three-digits used by banks to identify specific financial institutions
     * @type {string}
     * @memberof PaymentMethodEftDebit
     */
    'institution_id'?: string;
}
/**
 * If the payment method type is \"card_present\" then we return the terminal_reader object.
 * @export
 * @interface PaymentMethodTerminalReader
 */
export interface PaymentMethodTerminalReader {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof PaymentMethodTerminalReader
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof PaymentMethodTerminalReader
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof PaymentMethodTerminalReader
     */
    'id': string;
    /**
     * The Account that owns this terminal reader.
     * @type {string}
     * @memberof PaymentMethodTerminalReader
     */
    'account_id': string;
    /**
     * The type of the terminal reader. Currently only Handpoint powered terminal readers are supported. https://www.handpoint.com/docs/device/Basics
     * @type {string}
     * @memberof PaymentMethodTerminalReader
     */
    'type': PaymentMethodTerminalReaderTypeEnum;
    /**
     * The serial number of the terminal reader.
     * @type {string}
     * @memberof PaymentMethodTerminalReader
     */
    'serial_number': string;
    /**
     * The merchant provided description of the terminal reader
     * @type {string}
     * @memberof PaymentMethodTerminalReader
     */
    'description'?: string;
}

export const PaymentMethodTerminalReaderTypeEnum = {
    A920: 'pax_a920',
    A920Pro: 'pax_a920_pro',
    A60: 'pax_a60',
    A77: 'pax_a77',
    A80: 'pax_a80'
} as const;

export type PaymentMethodTerminalReaderTypeEnum = typeof PaymentMethodTerminalReaderTypeEnum[keyof typeof PaymentMethodTerminalReaderTypeEnum];

/**
 * 
 * @export
 * @interface PaymentMethodUpdateParams
 */
export interface PaymentMethodUpdateParams {
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value (i.e. `\'\'` or `null`) to them. All keys can be unset by posting an empty value (i.e. `{}` or `null`) to `metadata`.
     * @type {{ [key: string]: string; }}
     * @memberof PaymentMethodUpdateParams
     */
    'metadata'?: { [key: string]: string; };
    /**
     * A customer provided name for the PaymentMethod.
     * @type {string}
     * @memberof PaymentMethodUpdateParams
     */
    'nick_name'?: string;
    /**
     * 
     * @type {PaymentMethodCreateParamsBillingDetails}
     * @memberof PaymentMethodUpdateParams
     */
    'billing_details'?: PaymentMethodCreateParamsBillingDetails;
}
/**
 * 
 * @export
 * @interface Payout
 */
export interface Payout {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof Payout
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof Payout
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof Payout
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'account_id': string;
    /**
     * Amount to be transferred to your bank account, in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency).
     * @type {number}
     * @memberof Payout
     */
    'amount': number;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof Payout
     */
    'currency': PayoutCurrencyEnum;
    /**
     * An arbitrary string attached to the object. Often useful for displaying to users.
     * @type {string}
     * @memberof Payout
     */
    'description'?: string;
    /**
     * Current status of the payout: `paid`, `pending`, `in_transit`, `canceled` or `failed`. A payout is `pending` until it is submitted to the bank, when it becomes `in_transit`. The status then changes to `paid` if the transaction goes through, or to `failed` or `canceled` (within 5 business days). Some failed payouts may initially show as `paid` but then change to `failed`.
     * @type {string}
     * @memberof Payout
     */
    'status': PayoutStatusEnum;
    /**
     * Error code explaining the reason for a payout failure, if available.
     * @type {string}
     * @memberof Payout
     */
    'failure_code'?: PayoutFailureCodeEnum;
    /**
     * 
     * @type {PayoutBalanceTransaction}
     * @memberof Payout
     */
    'balance_transaction': PayoutBalanceTransaction;
    /**
     * The date the payout was paid.
     * @type {string}
     * @memberof Payout
     */
    'paid_at'?: string;
    /**
     * An optional property that is included when specified in a query parameter on request. It represents the number of balance_transaction objects associated with the payout (aside from the payout balance transaction itself).
     * @type {number}
     * @memberof Payout
     */
    'transaction_count'?: number;
}

export const PayoutCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type PayoutCurrencyEnum = typeof PayoutCurrencyEnum[keyof typeof PayoutCurrencyEnum];
export const PayoutStatusEnum = {
    Canceled: 'canceled',
    Failed: 'failed',
    InTransit: 'in_transit',
    Paid: 'paid',
    Pending: 'pending'
} as const;

export type PayoutStatusEnum = typeof PayoutStatusEnum[keyof typeof PayoutStatusEnum];
export const PayoutFailureCodeEnum = {
    AccountClosed: 'account_closed',
    AccountFrozen: 'account_frozen',
    BankAccountRestricted: 'bank_account_restricted',
    BankOwnershipChanged: 'bank_ownership_changed',
    CouldNotProcess: 'could_not_process',
    DebitNotAuthorized: 'debit_not_authorized',
    Declined: 'declined',
    InvalidAccountNumber: 'invalid_account_number',
    IncorrectAccountHolderName: 'incorrect_account_holder_name',
    IncorrectAccountHolderAddress: 'incorrect_account_holder_address',
    IncorrectAccountHolderTaxId: 'incorrect_account_holder_tax_id',
    InvalidCurrency: 'invalid_currency',
    NoAccount: 'no_account'
} as const;

export type PayoutFailureCodeEnum = typeof PayoutFailureCodeEnum[keyof typeof PayoutFailureCodeEnum];

/**
 * The balance transaction that describes the impact of this payout on your account balance.
 * @export
 * @interface PayoutBalanceTransaction
 */
export interface PayoutBalanceTransaction {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof PayoutBalanceTransaction
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof PayoutBalanceTransaction
     */
    'created_at': string;
    /**
     * Detailed breakdown of the fees paid for this transaction.
     * @type {Array<BalanceTransactionFeeDetail>}
     * @memberof PayoutBalanceTransaction
     */
    'fee_details': Array<BalanceTransactionFeeDetail>;
    /**
     * If the transaction’s net funds are available in the Tilled balance yet. Either `available` or `pending`.
     * @type {string}
     * @memberof PayoutBalanceTransaction
     */
    'status': PayoutBalanceTransactionStatusEnum;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof PayoutBalanceTransaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PayoutBalanceTransaction
     */
    'account_id': string;
    /**
     * Gross amount of the transaction, in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). Can be negative for certain transaction types (e.g. `payout`, `refund`).
     * @type {number}
     * @memberof PayoutBalanceTransaction
     */
    'amount': number;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof PayoutBalanceTransaction
     */
    'currency': PayoutBalanceTransactionCurrencyEnum;
    /**
     * An arbitrary string attached to the object. Often useful for displaying to users.
     * @type {string}
     * @memberof PayoutBalanceTransaction
     */
    'description'?: string;
    /**
     * Fees (in smallest currency unit) paid for this transaction.
     * @type {number}
     * @memberof PayoutBalanceTransaction
     */
    'fee': number;
    /**
     * Net amount of the transaction, in smallest currency unit.
     * @type {number}
     * @memberof PayoutBalanceTransaction
     */
    'net': number;
    /**
     * Tilled id to which this transaction is related
     * @type {string}
     * @memberof PayoutBalanceTransaction
     */
    'source_id': string;
    /**
     * Transaction type.
     * @type {string}
     * @memberof PayoutBalanceTransaction
     */
    'type': PayoutBalanceTransactionTypeEnum;
    /**
     * The date the transaction\'s net funds will become avaiable in the Tilled balance.
     * @type {string}
     * @memberof PayoutBalanceTransaction
     */
    'available_on': string;
}

export const PayoutBalanceTransactionStatusEnum = {
    Available: 'available',
    Pending: 'pending'
} as const;

export type PayoutBalanceTransactionStatusEnum = typeof PayoutBalanceTransactionStatusEnum[keyof typeof PayoutBalanceTransactionStatusEnum];
export const PayoutBalanceTransactionCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type PayoutBalanceTransactionCurrencyEnum = typeof PayoutBalanceTransactionCurrencyEnum[keyof typeof PayoutBalanceTransactionCurrencyEnum];
export const PayoutBalanceTransactionTypeEnum = {
    Charge: 'charge',
    ChargeFee: 'charge_fee',
    ChargeFailureRefund: 'charge_failure_refund',
    Dispute: 'dispute',
    DisputeWon: 'dispute_won',
    Refund: 'refund',
    RefundFee: 'refund_fee',
    RefundFailure: 'refund_failure',
    PlatformFee: 'platform_fee',
    PlatformFeeRefund: 'platform_fee_refund',
    TilledFee: 'tilled_fee',
    AccountFee: 'account_fee',
    PaymentMethodFee: 'payment_method_fee',
    Adjustment: 'adjustment',
    Commission: 'commission',
    Payout: 'payout',
    PayoutCancel: 'payout_cancel',
    PayoutFailure: 'payout_failure'
} as const;

export type PayoutBalanceTransactionTypeEnum = typeof PayoutBalanceTransactionTypeEnum[keyof typeof PayoutBalanceTransactionTypeEnum];

/**
 * 
 * @export
 * @interface PayoutSummary
 */
export interface PayoutSummary {
    /**
     * The type of balance transaction aggregated in this payout summary object (currently either charge, refund, or payout)
     * @type {string}
     * @memberof PayoutSummary
     */
    'type': string;
    /**
     * The currency this summary is aggregated by
     * @type {string}
     * @memberof PayoutSummary
     */
    'currency': PayoutSummaryCurrencyEnum;
    /**
     * The sum of all balance transactions of the same type and currency in this summary
     * @type {number}
     * @memberof PayoutSummary
     */
    'amount': number;
    /**
     * The count of balance transactions that are present in this summary
     * @type {number}
     * @memberof PayoutSummary
     */
    'count': number;
    /**
     * An array of objects each representing the sum of all fees of the same type in this summary
     * @type {Array<PayoutSummaryItem>}
     * @memberof PayoutSummary
     */
    'fee_details': Array<PayoutSummaryItem>;
}

export const PayoutSummaryCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type PayoutSummaryCurrencyEnum = typeof PayoutSummaryCurrencyEnum[keyof typeof PayoutSummaryCurrencyEnum];

/**
 * 
 * @export
 * @interface PayoutSummaryItem
 */
export interface PayoutSummaryItem {
    /**
     * The type of fee represented by this fee summary
     * @type {string}
     * @memberof PayoutSummaryItem
     */
    'type': string;
    /**
     * The currency of the fees in this fee summary
     * @type {string}
     * @memberof PayoutSummaryItem
     */
    'currency': PayoutSummaryItemCurrencyEnum;
    /**
     * The sum of fees of the same type in this fee summary
     * @type {number}
     * @memberof PayoutSummaryItem
     */
    'amount': number;
    /**
     * The count of the number of fees that are aggregated together in this fee summary
     * @type {number}
     * @memberof PayoutSummaryItem
     */
    'count': number;
}

export const PayoutSummaryItemCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type PayoutSummaryItemCurrencyEnum = typeof PayoutSummaryItemCurrencyEnum[keyof typeof PayoutSummaryItemCurrencyEnum];

/**
 * 
 * @export
 * @interface PlatformFee
 */
export interface PlatformFee {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof PlatformFee
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof PlatformFee
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof PlatformFee
     */
    'id': string;
    /**
     * Id of the Tilled account that earned this fee. This is generally an account of `type` `partner`.
     * @type {string}
     * @memberof PlatformFee
     */
    'payee_account_id': string;
    /**
     * Id of the Tilled account this fee was taken from. This is generally an account of `type` `merchant`.
     * @type {string}
     * @memberof PlatformFee
     */
    'payer_account_id': string;
    /**
     * Amount earned, in minor currency units.
     * @type {number}
     * @memberof PlatformFee
     */
    'amount': number;
    /**
     * Amount refunded, in minor currency units. Can be less than the amount attribute if a partial refund was issued.
     * @type {number}
     * @memberof PlatformFee
     */
    'amount_refunded': number;
    /**
     * Id of the charge this fee was taken from.
     * @type {string}
     * @memberof PlatformFee
     */
    'charge_id': string;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof PlatformFee
     */
    'currency': PlatformFeeCurrencyEnum;
    /**
     * Whether the fee has been fully refunded. If the fee is only partially refunded, this attribute will be false.
     * @type {boolean}
     * @memberof PlatformFee
     */
    'refunded': boolean;
    /**
     * A list of refunds that have been applied to the fee.
     * @type {Array<PlatformFeeRefund>}
     * @memberof PlatformFee
     */
    'refunds': Array<PlatformFeeRefund>;
    /**
     * 
     * @type {PlatformFeeBalanceTransaction}
     * @memberof PlatformFee
     */
    'balance_transaction': PlatformFeeBalanceTransaction;
}

export const PlatformFeeCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type PlatformFeeCurrencyEnum = typeof PlatformFeeCurrencyEnum[keyof typeof PlatformFeeCurrencyEnum];

/**
 * The balance transaction that describes the impact of this collected platform fee on your account balance (not including refunds).
 * @export
 * @interface PlatformFeeBalanceTransaction
 */
export interface PlatformFeeBalanceTransaction {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof PlatformFeeBalanceTransaction
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof PlatformFeeBalanceTransaction
     */
    'created_at': string;
    /**
     * Detailed breakdown of the fees paid for this transaction.
     * @type {Array<BalanceTransactionFeeDetail>}
     * @memberof PlatformFeeBalanceTransaction
     */
    'fee_details': Array<BalanceTransactionFeeDetail>;
    /**
     * If the transaction’s net funds are available in the Tilled balance yet. Either `available` or `pending`.
     * @type {string}
     * @memberof PlatformFeeBalanceTransaction
     */
    'status': PlatformFeeBalanceTransactionStatusEnum;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof PlatformFeeBalanceTransaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlatformFeeBalanceTransaction
     */
    'account_id': string;
    /**
     * Gross amount of the transaction, in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). Can be negative for certain transaction types (e.g. `payout`, `refund`).
     * @type {number}
     * @memberof PlatformFeeBalanceTransaction
     */
    'amount': number;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof PlatformFeeBalanceTransaction
     */
    'currency': PlatformFeeBalanceTransactionCurrencyEnum;
    /**
     * An arbitrary string attached to the object. Often useful for displaying to users.
     * @type {string}
     * @memberof PlatformFeeBalanceTransaction
     */
    'description'?: string;
    /**
     * Fees (in smallest currency unit) paid for this transaction.
     * @type {number}
     * @memberof PlatformFeeBalanceTransaction
     */
    'fee': number;
    /**
     * Net amount of the transaction, in smallest currency unit.
     * @type {number}
     * @memberof PlatformFeeBalanceTransaction
     */
    'net': number;
    /**
     * Tilled id to which this transaction is related
     * @type {string}
     * @memberof PlatformFeeBalanceTransaction
     */
    'source_id': string;
    /**
     * Transaction type.
     * @type {string}
     * @memberof PlatformFeeBalanceTransaction
     */
    'type': PlatformFeeBalanceTransactionTypeEnum;
    /**
     * The date the transaction\'s net funds will become avaiable in the Tilled balance.
     * @type {string}
     * @memberof PlatformFeeBalanceTransaction
     */
    'available_on': string;
}

export const PlatformFeeBalanceTransactionStatusEnum = {
    Available: 'available',
    Pending: 'pending'
} as const;

export type PlatformFeeBalanceTransactionStatusEnum = typeof PlatformFeeBalanceTransactionStatusEnum[keyof typeof PlatformFeeBalanceTransactionStatusEnum];
export const PlatformFeeBalanceTransactionCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type PlatformFeeBalanceTransactionCurrencyEnum = typeof PlatformFeeBalanceTransactionCurrencyEnum[keyof typeof PlatformFeeBalanceTransactionCurrencyEnum];
export const PlatformFeeBalanceTransactionTypeEnum = {
    Charge: 'charge',
    ChargeFee: 'charge_fee',
    ChargeFailureRefund: 'charge_failure_refund',
    Dispute: 'dispute',
    DisputeWon: 'dispute_won',
    Refund: 'refund',
    RefundFee: 'refund_fee',
    RefundFailure: 'refund_failure',
    PlatformFee: 'platform_fee',
    PlatformFeeRefund: 'platform_fee_refund',
    TilledFee: 'tilled_fee',
    AccountFee: 'account_fee',
    PaymentMethodFee: 'payment_method_fee',
    Adjustment: 'adjustment',
    Commission: 'commission',
    Payout: 'payout',
    PayoutCancel: 'payout_cancel',
    PayoutFailure: 'payout_failure'
} as const;

export type PlatformFeeBalanceTransactionTypeEnum = typeof PlatformFeeBalanceTransactionTypeEnum[keyof typeof PlatformFeeBalanceTransactionTypeEnum];

/**
 * 
 * @export
 * @interface PlatformFeeRefund
 */
export interface PlatformFeeRefund {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof PlatformFeeRefund
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof PlatformFeeRefund
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof PlatformFeeRefund
     */
    'id': string;
    /**
     * Amount in the smallest currency unit.
     * @type {number}
     * @memberof PlatformFeeRefund
     */
    'amount': number;
    /**
     * ID of the platform fee that was refunded.
     * @type {string}
     * @memberof PlatformFeeRefund
     */
    'platform_fee_id': string;
    /**
     * 
     * @type {PlatformFeeRefundBalanceTransaction}
     * @memberof PlatformFeeRefund
     */
    'balance_transaction': PlatformFeeRefundBalanceTransaction;
}
/**
 * The balance transaction that describes the impact of this refund on your account balance.
 * @export
 * @interface PlatformFeeRefundBalanceTransaction
 */
export interface PlatformFeeRefundBalanceTransaction {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'created_at': string;
    /**
     * Detailed breakdown of the fees paid for this transaction.
     * @type {Array<BalanceTransactionFeeDetail>}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'fee_details': Array<BalanceTransactionFeeDetail>;
    /**
     * If the transaction’s net funds are available in the Tilled balance yet. Either `available` or `pending`.
     * @type {string}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'status': PlatformFeeRefundBalanceTransactionStatusEnum;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'account_id': string;
    /**
     * Gross amount of the transaction, in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). Can be negative for certain transaction types (e.g. `payout`, `refund`).
     * @type {number}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'amount': number;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'currency': PlatformFeeRefundBalanceTransactionCurrencyEnum;
    /**
     * An arbitrary string attached to the object. Often useful for displaying to users.
     * @type {string}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'description'?: string;
    /**
     * Fees (in smallest currency unit) paid for this transaction.
     * @type {number}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'fee': number;
    /**
     * Net amount of the transaction, in smallest currency unit.
     * @type {number}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'net': number;
    /**
     * Tilled id to which this transaction is related
     * @type {string}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'source_id': string;
    /**
     * Transaction type.
     * @type {string}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'type': PlatformFeeRefundBalanceTransactionTypeEnum;
    /**
     * The date the transaction\'s net funds will become avaiable in the Tilled balance.
     * @type {string}
     * @memberof PlatformFeeRefundBalanceTransaction
     */
    'available_on': string;
}

export const PlatformFeeRefundBalanceTransactionStatusEnum = {
    Available: 'available',
    Pending: 'pending'
} as const;

export type PlatformFeeRefundBalanceTransactionStatusEnum = typeof PlatformFeeRefundBalanceTransactionStatusEnum[keyof typeof PlatformFeeRefundBalanceTransactionStatusEnum];
export const PlatformFeeRefundBalanceTransactionCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type PlatformFeeRefundBalanceTransactionCurrencyEnum = typeof PlatformFeeRefundBalanceTransactionCurrencyEnum[keyof typeof PlatformFeeRefundBalanceTransactionCurrencyEnum];
export const PlatformFeeRefundBalanceTransactionTypeEnum = {
    Charge: 'charge',
    ChargeFee: 'charge_fee',
    ChargeFailureRefund: 'charge_failure_refund',
    Dispute: 'dispute',
    DisputeWon: 'dispute_won',
    Refund: 'refund',
    RefundFee: 'refund_fee',
    RefundFailure: 'refund_failure',
    PlatformFee: 'platform_fee',
    PlatformFeeRefund: 'platform_fee_refund',
    TilledFee: 'tilled_fee',
    AccountFee: 'account_fee',
    PaymentMethodFee: 'payment_method_fee',
    Adjustment: 'adjustment',
    Commission: 'commission',
    Payout: 'payout',
    PayoutCancel: 'payout_cancel',
    PayoutFailure: 'payout_failure'
} as const;

export type PlatformFeeRefundBalanceTransactionTypeEnum = typeof PlatformFeeRefundBalanceTransactionTypeEnum[keyof typeof PlatformFeeRefundBalanceTransactionTypeEnum];

/**
 * 
 * @export
 * @interface Principal
 */
export interface Principal {
    /**
     * The unique identifier for this principal. It is not required upon initial submission. The `ssn` property is redacted in any responses, so if the principal needs to be updated then provide this identifier that was generated during the initial request.
     * @type {string}
     * @memberof Principal
     */
    'id'?: string;
    /**
     * Indicates whether this principal is the applicant for the merchant account. For US merchant accounts (`region = US`) it is required that _exactly_ one of the principals is specified as the applicant.
     * @type {boolean}
     * @memberof Principal
     */
    'is_applicant': boolean;
    /**
     * This indicates whether the principal is the Control Prong. Control Prong is an individual with significant responsibility for managing the legal entity customer (e.g., a CEO, CFO, COO, Managing Member, General Partner, President, Vice-President, or Treasurer). For US merchant accounts (`region = US`) it is required that _exactly_ one of the principals is specified as the Control Prong.
     * @type {boolean}
     * @memberof Principal
     */
    'is_control_prong'?: boolean;
    /**
     * Job title of the principal (e.g. CEO, CFO, President, VP)
     * @type {string}
     * @memberof Principal
     */
    'job_title': string;
    /**
     * First name of the principal.
     * @type {string}
     * @memberof Principal
     */
    'first_name': string;
    /**
     * Middle name of the principal.
     * @type {string}
     * @memberof Principal
     */
    'middle_name'?: string;
    /**
     * Last name of the principal.
     * @type {string}
     * @memberof Principal
     */
    'last_name': string;
    /**
     * Email address of the principal
     * @type {string}
     * @memberof Principal
     */
    'email'?: string;
    /**
     * Phone number of the principal.
     * @type {string}
     * @memberof Principal
     */
    'phone': string;
    /**
     * Social Security Number (US) or Social Insurance Number (CA). Optional when business type is `NPCORP`, `CHARITY`, or `GOV`. Expected format: 9-digit string of numbers (e.g. \"111444777\"). Optional in CA.
     * @type {string}
     * @memberof Principal
     */
    'ssn'?: string;
    /**
     * Date of birth of the principal. Format must be ISO8601 (e.g. \'2000-01-25\'; format \'YYYY-MM-DD\'). Currently the principal must be older than 18 years of age.
     * @type {string}
     * @memberof Principal
     */
    'date_of_birth': string;
    /**
     * 
     * @type {PrincipalAddress}
     * @memberof Principal
     */
    'address': PrincipalAddress;
    /**
     * 
     * @type {PrincipalPreviousAddress}
     * @memberof Principal
     */
    'previous_address'?: PrincipalPreviousAddress;
    /**
     * Percentage of ownership of the company.
     * @type {number}
     * @memberof Principal
     */
    'percentage_shareholding': number;
    /**
     * Nationality of the principal
     * @type {string}
     * @memberof Principal
     */
    'nationality'?: PrincipalNationalityEnum;
}

export const PrincipalNationalityEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    Us: 'US',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    Bl: 'BL',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Ba: 'BA',
    Br: 'BR',
    Gb: 'GB',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Nl: 'NL',
    Ec: 'EC',
    Eg: 'EG',
    Ae: 'AE',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Ph: 'PH',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gw: 'GW',
    Gn: 'GN',
    Gy: 'GY',
    Ht: 'HT',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Ki: 'KI',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Il: 'IL',
    It: 'IT',
    Ci: 'CI',
    Jm: 'JM',
    Jp: 'JP',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Kn: 'KN',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Yt: 'YT',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Im: 'IM',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Ls: 'LS',
    Bw: 'BW',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nc: 'NC',
    Nz: 'NZ',
    Vu: 'VU',
    Ni: 'NI',
    Ng: 'NG',
    Ne: 'NE',
    Nu: 'NU',
    Nf: 'NF',
    Kp: 'KP',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Sh: 'SH',
    Lc: 'LC',
    Vc: 'VC',
    Pm: 'PM',
    Sv: 'SV',
    Ws: 'WS',
    Sm: 'SM',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Kr: 'KR',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Ss: 'SS',
    Sr: 'SR',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    St: 'ST',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Uy: 'UY',
    Uz: 'UZ',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Ax: 'AX'
} as const;

export type PrincipalNationalityEnum = typeof PrincipalNationalityEnum[keyof typeof PrincipalNationalityEnum];

/**
 * Registered *residential* address for this principal
 * @export
 * @interface PrincipalAddress
 */
export interface PrincipalAddress {
    /**
     * First line of the street address
     * @type {string}
     * @memberof PrincipalAddress
     */
    'street': string;
    /**
     * Second line of the street address, if required.
     * @type {string}
     * @memberof PrincipalAddress
     */
    'street2'?: string;
    /**
     * City where address is located.
     * @type {string}
     * @memberof PrincipalAddress
     */
    'city': string;
    /**
     * State/province/region of the address. For US and CA use 2-digit state/province codes (e.g. \'AL\', \'AK\', \'BC\', \'ON\', \'etc\'.)
     * @type {string}
     * @memberof PrincipalAddress
     */
    'state': string;
    /**
     * Zip code or postal code of the address. No special characters.
     * @type {string}
     * @memberof PrincipalAddress
     */
    'zip': string;
    /**
     * 2-digit Country code (e.g. \'US\', \'CA\') [See ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     * @type {string}
     * @memberof PrincipalAddress
     */
    'country': string;
    /**
     * Years at given address. Required for CA merchant accounts (`region = CA`).
     * @type {number}
     * @memberof PrincipalAddress
     */
    'years_at_address'?: number;
}
/**
 * Previous registered *residential* address for this principal. Require for Canadian principals and have lived at their current address for fewer than 3 years.
 * @export
 * @interface PrincipalPreviousAddress
 */
export interface PrincipalPreviousAddress {
    /**
     * First line of the street address
     * @type {string}
     * @memberof PrincipalPreviousAddress
     */
    'street': string;
    /**
     * Second line of the street address, if required.
     * @type {string}
     * @memberof PrincipalPreviousAddress
     */
    'street2'?: string;
    /**
     * City where address is located.
     * @type {string}
     * @memberof PrincipalPreviousAddress
     */
    'city': string;
    /**
     * State/province/region of the address. For US and CA use 2-digit state/province codes (e.g. \'AL\', \'AK\', \'BC\', \'ON\', \'etc\'.)
     * @type {string}
     * @memberof PrincipalPreviousAddress
     */
    'state': string;
    /**
     * Zip code or postal code of the address. No special characters.
     * @type {string}
     * @memberof PrincipalPreviousAddress
     */
    'zip': string;
    /**
     * 2-digit Country code (e.g. \'US\', \'CA\') [See ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     * @type {string}
     * @memberof PrincipalPreviousAddress
     */
    'country': string;
    /**
     * Years at given address. Required for CA merchant accounts (`region = CA`).
     * @type {number}
     * @memberof PrincipalPreviousAddress
     */
    'years_at_address'?: number;
}
/**
 * 
 * @export
 * @interface ProductCode
 */
export interface ProductCode {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof ProductCode
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof ProductCode
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof ProductCode
     */
    'id': string;
    /**
     * The user friendly description. Example: *2.90% | $0.30 TXN | $10 CHBK/Reversals/Retrievals | $0 Monthly*
     * @type {string}
     * @memberof ProductCode
     */
    'description': string;
    /**
     * The payment method type that this product code is valid for.
     * @type {string}
     * @memberof ProductCode
     */
    'payment_method_type': ProductCodePaymentMethodTypeEnum;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof ProductCode
     */
    'currency': ProductCodeCurrencyEnum;
    /**
     * The Region in which the product code is usable
     * @type {string}
     * @memberof ProductCode
     */
    'region'?: ProductCodeRegionEnum;
}

export const ProductCodePaymentMethodTypeEnum = {
    Card: 'card',
    AchDebit: 'ach_debit',
    CardPresent: 'card_present',
    EftDebit: 'eft_debit'
} as const;

export type ProductCodePaymentMethodTypeEnum = typeof ProductCodePaymentMethodTypeEnum[keyof typeof ProductCodePaymentMethodTypeEnum];
export const ProductCodeCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type ProductCodeCurrencyEnum = typeof ProductCodeCurrencyEnum[keyof typeof ProductCodeCurrencyEnum];
export const ProductCodeRegionEnum = {
    Us: 'US',
    Ca: 'CA'
} as const;

export type ProductCodeRegionEnum = typeof ProductCodeRegionEnum[keyof typeof ProductCodeRegionEnum];

/**
 * 
 * @export
 * @interface Refund
 */
export interface Refund {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof Refund
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof Refund
     */
    'created_at': string;
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof Refund
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof Refund
     */
    'id': string;
    /**
     * Amount to be refunded. A positive integer representing how much to refund in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency).
     * @type {number}
     * @memberof Refund
     */
    'amount': number;
    /**
     * ID of the PaymentIntent that was refunded.
     * @type {string}
     * @memberof Refund
     */
    'payment_intent_id': string;
    /**
     * ID of the Charge that was refunded.
     * @type {string}
     * @memberof Refund
     */
    'charge_id': string;
    /**
     * Reason for the refund, either user-provided (`duplicate`, `fraudulent`, or `requested_by_customer`) or generated  by Tilled (`expired_uncaptured_charge`)
     * @type {string}
     * @memberof Refund
     */
    'reason'?: RefundReasonEnum;
    /**
     * Status of the refund, one of `pending`, `succeeded`, `failed`, or `canceled`.
     * @type {string}
     * @memberof Refund
     */
    'status': RefundStatusEnum;
    /**
     * 
     * @type {PlatformFeeRefundBalanceTransaction}
     * @memberof Refund
     */
    'balance_transaction': PlatformFeeRefundBalanceTransaction;
}

export const RefundReasonEnum = {
    Duplicate: 'duplicate',
    Fraudulent: 'fraudulent',
    RequestedByCustomer: 'requested_by_customer',
    ExpiredUncapturedCharge: 'expired_uncaptured_charge',
    PartialCapture: 'partial_capture'
} as const;

export type RefundReasonEnum = typeof RefundReasonEnum[keyof typeof RefundReasonEnum];
export const RefundStatusEnum = {
    Canceled: 'canceled',
    Pending: 'pending',
    Succeeded: 'succeeded',
    Failed: 'failed'
} as const;

export type RefundStatusEnum = typeof RefundStatusEnum[keyof typeof RefundStatusEnum];

/**
 * 
 * @export
 * @interface RefundCreateParams
 */
export interface RefundCreateParams {
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value (i.e. `\'\'` or `null`) to them. All keys can be unset by posting an empty value (i.e. `{}` or `null`) to `metadata`.
     * @type {{ [key: string]: string; }}
     * @memberof RefundCreateParams
     */
    'metadata'?: { [key: string]: string; };
    /**
     * String indicating the reason for the refund. If set, possible values are `duplicate`, `fraudulent`, and `requested_by_customer`.
     * @type {string}
     * @memberof RefundCreateParams
     */
    'reason'?: RefundCreateParamsReasonEnum;
    /**
     * ID of the PaymentIntent to refund.
     * @type {string}
     * @memberof RefundCreateParams
     */
    'payment_intent_id': string;
    /**
     * A positive integer representing how much of this charge to refund in the smallest currency unit (e.g., 100 cents to charge $1.00). *The default is the entire charge.*
     * @type {number}
     * @memberof RefundCreateParams
     */
    'amount'?: number;
    /**
     * Boolean indicating whether the platform fee should be refunded when refunding this charge. If a full charge refund is given, the full platform fee will be refunded. Otherwise, the platform fee will be refunded in an amount proportional to the amount of the charge refunded.
     * @type {boolean}
     * @memberof RefundCreateParams
     */
    'refund_platform_fee'?: boolean;
}

export const RefundCreateParamsReasonEnum = {
    Duplicate: 'duplicate',
    Fraudulent: 'fraudulent',
    RequestedByCustomer: 'requested_by_customer'
} as const;

export type RefundCreateParamsReasonEnum = typeof RefundCreateParamsReasonEnum[keyof typeof RefundCreateParamsReasonEnum];

/**
 * 
 * @export
 * @interface RegisterDto
 */
export interface RegisterDto {
    /**
     * 
     * @type {RegisterDtoUser}
     * @memberof RegisterDto
     */
    'user': RegisterDtoUser;
    /**
     * 
     * @type {RegisterDtoAccount}
     * @memberof RegisterDto
     */
    'account': RegisterDtoAccount;
    /**
     * JSON Web Token used for authentication.
     * @type {string}
     * @memberof RegisterDto
     */
    'token': string;
}
/**
 * The created account (may be empty when registering via invitation)
 * @export
 * @interface RegisterDtoAccount
 */
export interface RegisterDtoAccount {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof RegisterDtoAccount
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof RegisterDtoAccount
     */
    'created_at': string;
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
     * @type {{ [key: string]: string; }}
     * @memberof RegisterDtoAccount
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof RegisterDtoAccount
     */
    'id': string;
    /**
     * The Tilled account type. Can be `partner` or `merchant`.
     * @type {string}
     * @memberof RegisterDtoAccount
     */
    'type': RegisterDtoAccountTypeEnum;
    /**
     * The business name or individual name.
     * @type {string}
     * @memberof RegisterDtoAccount
     */
    'name'?: string;
    /**
     * The primary user\'s email address.
     * @type {string}
     * @memberof RegisterDtoAccount
     */
    'email'?: string;
    /**
     * Capabilities represent the assigned product codes to a given merchant account and their status.
     * @type {Array<AccountCapability>}
     * @memberof RegisterDtoAccount
     */
    'capabilities'?: Array<AccountCapability>;
    /**
     * Bank accounts attached to this account. Primarily used for payouts.
     * @type {Array<BankAccount>}
     * @memberof RegisterDtoAccount
     */
    'bank_accounts': Array<BankAccount>;
    /**
     * Terminal Readers attached to this account.
     * @type {Array<TerminalReader>}
     * @memberof RegisterDtoAccount
     */
    'terminal_readers': Array<TerminalReader>;
    /**
     * 
     * @type {AccountBusinessProfile}
     * @memberof RegisterDtoAccount
     */
    'business_profile'?: AccountBusinessProfile;
    /**
     * 
     * @type {AccountSettings}
     * @memberof RegisterDtoAccount
     */
    'settings'?: AccountSettings;
    /**
     * The `partner` white label domain.
     * @type {string}
     * @memberof RegisterDtoAccount
     */
    'white_label_domain'?: string;
}

export const RegisterDtoAccountTypeEnum = {
    Partner: 'partner',
    Merchant: 'merchant'
} as const;

export type RegisterDtoAccountTypeEnum = typeof RegisterDtoAccountTypeEnum[keyof typeof RegisterDtoAccountTypeEnum];

/**
 * The created user.
 * @export
 * @interface RegisterDtoUser
 */
export interface RegisterDtoUser {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof RegisterDtoUser
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof RegisterDtoUser
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof RegisterDtoUser
     */
    'id': string;
    /**
     * The full name of the user.
     * @type {string}
     * @memberof RegisterDtoUser
     */
    'name': string;
    /**
     * The user email.
     * @type {string}
     * @memberof RegisterDtoUser
     */
    'email': string;
    /**
     * The ID of the Account associated with this user.
     * @type {string}
     * @memberof RegisterDtoUser
     */
    'account_id': string;
    /**
     * The user\'s role, primarily used in the Tilled Dashboard. The roles have varied restrictions on the actions they can take.
     * @type {string}
     * @memberof RegisterDtoUser
     */
    'role': RegisterDtoUserRoleEnum;
    /**
     * Time at which the user last successfully logged in via the API.
     * @type {string}
     * @memberof RegisterDtoUser
     */
    'last_login_at'?: string;
    /**
     * Time at which the user\'s token was last used to authenticate a request to the API.
     * @type {string}
     * @memberof RegisterDtoUser
     */
    'last_request_at'?: string;
    /**
     * Six digit verification code of the user.
     * @type {string}
     * @memberof RegisterDtoUser
     */
    'verification_code'?: string;
}

export const RegisterDtoUserRoleEnum = {
    Owner: 'owner',
    Admin: 'admin',
    Developer: 'developer',
    Analyst: 'analyst',
    ViewOnly: 'view_only',
    MerchantOwner: 'merchant_owner',
    MerchantAdmin: 'merchant_admin'
} as const;

export type RegisterDtoUserRoleEnum = typeof RegisterDtoUserRoleEnum[keyof typeof RegisterDtoUserRoleEnum];

/**
 * 
 * @export
 * @interface RegisterParams
 */
export interface RegisterParams {
    /**
     * Password. Requires 1 alphabetic and 1 numeric character and a minimum length of 7.
     * @type {string}
     * @memberof RegisterParams
     */
    'password': string;
    /**
     * The business name or individual name.
     * @type {string}
     * @memberof RegisterParams
     */
    'account_name'?: string;
    /**
     * ID of the user invitation associated with this registration.
     * @type {string}
     * @memberof RegisterParams
     */
    'user_invitation_id'?: string;
    /**
     * Full name
     * @type {string}
     * @memberof RegisterParams
     */
    'name': string;
    /**
     * Email address
     * @type {string}
     * @memberof RegisterParams
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ReportRun
 */
export interface ReportRun {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof ReportRun
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof ReportRun
     */
    'created_at': string;
    /**
     * 
     * @type {ReportRunRequestParameters}
     * @memberof ReportRun
     */
    'parameters': ReportRunRequestParameters;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof ReportRun
     */
    'id': string;
    /**
     * The id of the associated account.
     * @type {string}
     * @memberof ReportRun
     */
    'account_id': string;
    /**
     * The type of a report run.
     * @type {string}
     * @memberof ReportRun
     */
    'type': ReportRunTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof ReportRun
     */
    'result'?: any;
    /**
     * The status of a report run.  \'queued\' \'finished\' \'failed\'
     * @type {string}
     * @memberof ReportRun
     */
    'status': ReportRunStatusEnum;
    /**
     * The failure message of the report run, if status is \'failed\'.
     * @type {string}
     * @memberof ReportRun
     */
    'failure_message'?: string;
}

export const ReportRunTypeEnum = {
    PaymentsSummary1: 'payments_summary_1'
} as const;

export type ReportRunTypeEnum = typeof ReportRunTypeEnum[keyof typeof ReportRunTypeEnum];
export const ReportRunStatusEnum = {
    Queued: 'queued',
    Finished: 'finished',
    Failed: 'failed'
} as const;

export type ReportRunStatusEnum = typeof ReportRunStatusEnum[keyof typeof ReportRunStatusEnum];

/**
 * 
 * @export
 * @interface ReportRunCreateParams
 */
export interface ReportRunCreateParams {
    /**
     * The name of the report. Can only be alphanumeric, and include hyphens (-), underscores (_), and periods (.)
     * @type {string}
     * @memberof ReportRunCreateParams
     */
    'report_name'?: string;
    /**
     * The type of a Report Run.
     * @type {string}
     * @memberof ReportRunCreateParams
     */
    'type': ReportRunCreateParamsTypeEnum;
    /**
     * 
     * @type {ReportRunCreateParamsParameters}
     * @memberof ReportRunCreateParams
     */
    'parameters': ReportRunCreateParamsParameters;
}

export const ReportRunCreateParamsTypeEnum = {
    PaymentsSummary1: 'payments_summary_1'
} as const;

export type ReportRunCreateParamsTypeEnum = typeof ReportRunCreateParamsTypeEnum[keyof typeof ReportRunCreateParamsTypeEnum];

/**
 * The request paramaters of a Report Run
 * @export
 * @interface ReportRunCreateParamsParameters
 */
export interface ReportRunCreateParamsParameters {
    /**
     * Timezone of the Report Run
     * @type {string}
     * @memberof ReportRunCreateParamsParameters
     */
    'time_zone'?: ReportRunCreateParamsParametersTimeZoneEnum;
    /**
     * Date of the start of the data to include in the Report Run
     * @type {string}
     * @memberof ReportRunCreateParamsParameters
     */
    'start_at': string;
    /**
     * Date of the end of the data to include in the Report Run
     * @type {string}
     * @memberof ReportRunCreateParamsParameters
     */
    'end_at': string;
    /**
     * The specific child Account Id to run a report on
     * @type {string}
     * @memberof ReportRunCreateParamsParameters
     */
    'account_id'?: string;
}

export const ReportRunCreateParamsParametersTimeZoneEnum = {
    AfricaAbidjan: 'Africa/Abidjan',
    AfricaAccra: 'Africa/Accra',
    AfricaAddisAbaba: 'Africa/Addis_Ababa',
    AfricaAlgiers: 'Africa/Algiers',
    AfricaAsmara: 'Africa/Asmara',
    AfricaAsmera: 'Africa/Asmera',
    AfricaBamako: 'Africa/Bamako',
    AfricaBangui: 'Africa/Bangui',
    AfricaBanjul: 'Africa/Banjul',
    AfricaBissau: 'Africa/Bissau',
    AfricaBlantyre: 'Africa/Blantyre',
    AfricaBrazzaville: 'Africa/Brazzaville',
    AfricaBujumbura: 'Africa/Bujumbura',
    AfricaCairo: 'Africa/Cairo',
    AfricaCasablanca: 'Africa/Casablanca',
    AfricaCeuta: 'Africa/Ceuta',
    AfricaConakry: 'Africa/Conakry',
    AfricaDakar: 'Africa/Dakar',
    AfricaDarEsSalaam: 'Africa/Dar_es_Salaam',
    AfricaDjibouti: 'Africa/Djibouti',
    AfricaDouala: 'Africa/Douala',
    AfricaElAaiun: 'Africa/El_Aaiun',
    AfricaFreetown: 'Africa/Freetown',
    AfricaGaborone: 'Africa/Gaborone',
    AfricaHarare: 'Africa/Harare',
    AfricaJohannesburg: 'Africa/Johannesburg',
    AfricaJuba: 'Africa/Juba',
    AfricaKampala: 'Africa/Kampala',
    AfricaKhartoum: 'Africa/Khartoum',
    AfricaKigali: 'Africa/Kigali',
    AfricaKinshasa: 'Africa/Kinshasa',
    AfricaLagos: 'Africa/Lagos',
    AfricaLibreville: 'Africa/Libreville',
    AfricaLome: 'Africa/Lome',
    AfricaLuanda: 'Africa/Luanda',
    AfricaLubumbashi: 'Africa/Lubumbashi',
    AfricaLusaka: 'Africa/Lusaka',
    AfricaMalabo: 'Africa/Malabo',
    AfricaMaputo: 'Africa/Maputo',
    AfricaMaseru: 'Africa/Maseru',
    AfricaMbabane: 'Africa/Mbabane',
    AfricaMogadishu: 'Africa/Mogadishu',
    AfricaMonrovia: 'Africa/Monrovia',
    AfricaNairobi: 'Africa/Nairobi',
    AfricaNdjamena: 'Africa/Ndjamena',
    AfricaNiamey: 'Africa/Niamey',
    AfricaNouakchott: 'Africa/Nouakchott',
    AfricaOuagadougou: 'Africa/Ouagadougou',
    AfricaPortoNovo: 'Africa/Porto-Novo',
    AfricaSaoTome: 'Africa/Sao_Tome',
    AfricaTimbuktu: 'Africa/Timbuktu',
    AfricaTripoli: 'Africa/Tripoli',
    AfricaTunis: 'Africa/Tunis',
    AfricaWindhoek: 'Africa/Windhoek',
    AmericaAdak: 'America/Adak',
    AmericaAnchorage: 'America/Anchorage',
    AmericaAnguilla: 'America/Anguilla',
    AmericaAntigua: 'America/Antigua',
    AmericaAraguaina: 'America/Araguaina',
    AmericaArgentinaBuenosAires: 'America/Argentina/Buenos_Aires',
    AmericaArgentinaCatamarca: 'America/Argentina/Catamarca',
    AmericaArgentinaComodRivadavia: 'America/Argentina/ComodRivadavia',
    AmericaArgentinaCordoba: 'America/Argentina/Cordoba',
    AmericaArgentinaJujuy: 'America/Argentina/Jujuy',
    AmericaArgentinaLaRioja: 'America/Argentina/La_Rioja',
    AmericaArgentinaMendoza: 'America/Argentina/Mendoza',
    AmericaArgentinaRioGallegos: 'America/Argentina/Rio_Gallegos',
    AmericaArgentinaSalta: 'America/Argentina/Salta',
    AmericaArgentinaSanJuan: 'America/Argentina/San_Juan',
    AmericaArgentinaSanLuis: 'America/Argentina/San_Luis',
    AmericaArgentinaTucuman: 'America/Argentina/Tucuman',
    AmericaArgentinaUshuaia: 'America/Argentina/Ushuaia',
    AmericaAruba: 'America/Aruba',
    AmericaAsuncion: 'America/Asuncion',
    AmericaAtikokan: 'America/Atikokan',
    AmericaAtka: 'America/Atka',
    AmericaBahia: 'America/Bahia',
    AmericaBahiaBanderas: 'America/Bahia_Banderas',
    AmericaBarbados: 'America/Barbados',
    AmericaBelem: 'America/Belem',
    AmericaBelize: 'America/Belize',
    AmericaBlancSablon: 'America/Blanc-Sablon',
    AmericaBoaVista: 'America/Boa_Vista',
    AmericaBogota: 'America/Bogota',
    AmericaBoise: 'America/Boise',
    AmericaBuenosAires: 'America/Buenos_Aires',
    AmericaCambridgeBay: 'America/Cambridge_Bay',
    AmericaCampoGrande: 'America/Campo_Grande',
    AmericaCancun: 'America/Cancun',
    AmericaCaracas: 'America/Caracas',
    AmericaCatamarca: 'America/Catamarca',
    AmericaCayenne: 'America/Cayenne',
    AmericaCayman: 'America/Cayman',
    AmericaChicago: 'America/Chicago',
    AmericaChihuahua: 'America/Chihuahua',
    AmericaCoralHarbour: 'America/Coral_Harbour',
    AmericaCordoba: 'America/Cordoba',
    AmericaCostaRica: 'America/Costa_Rica',
    AmericaCreston: 'America/Creston',
    AmericaCuiaba: 'America/Cuiaba',
    AmericaCuracao: 'America/Curacao',
    AmericaDanmarkshavn: 'America/Danmarkshavn',
    AmericaDawson: 'America/Dawson',
    AmericaDawsonCreek: 'America/Dawson_Creek',
    AmericaDenver: 'America/Denver',
    AmericaDetroit: 'America/Detroit',
    AmericaDominica: 'America/Dominica',
    AmericaEdmonton: 'America/Edmonton',
    AmericaEirunepe: 'America/Eirunepe',
    AmericaElSalvador: 'America/El_Salvador',
    AmericaEnsenada: 'America/Ensenada',
    AmericaFortWayne: 'America/Fort_Wayne',
    AmericaFortaleza: 'America/Fortaleza',
    AmericaGlaceBay: 'America/Glace_Bay',
    AmericaGodthab: 'America/Godthab',
    AmericaGooseBay: 'America/Goose_Bay',
    AmericaGrandTurk: 'America/Grand_Turk',
    AmericaGrenada: 'America/Grenada',
    AmericaGuadeloupe: 'America/Guadeloupe',
    AmericaGuatemala: 'America/Guatemala',
    AmericaGuayaquil: 'America/Guayaquil',
    AmericaGuyana: 'America/Guyana',
    AmericaHalifax: 'America/Halifax',
    AmericaHavana: 'America/Havana',
    AmericaHermosillo: 'America/Hermosillo',
    AmericaIndianaIndianapolis: 'America/Indiana/Indianapolis',
    AmericaIndianaKnox: 'America/Indiana/Knox',
    AmericaIndianaMarengo: 'America/Indiana/Marengo',
    AmericaIndianaPetersburg: 'America/Indiana/Petersburg',
    AmericaIndianaTellCity: 'America/Indiana/Tell_City',
    AmericaIndianaVevay: 'America/Indiana/Vevay',
    AmericaIndianaVincennes: 'America/Indiana/Vincennes',
    AmericaIndianaWinamac: 'America/Indiana/Winamac',
    AmericaIndianapolis: 'America/Indianapolis',
    AmericaInuvik: 'America/Inuvik',
    AmericaIqaluit: 'America/Iqaluit',
    AmericaJamaica: 'America/Jamaica',
    AmericaJujuy: 'America/Jujuy',
    AmericaJuneau: 'America/Juneau',
    AmericaKentuckyLouisville: 'America/Kentucky/Louisville',
    AmericaKentuckyMonticello: 'America/Kentucky/Monticello',
    AmericaKnoxIn: 'America/Knox_IN',
    AmericaKralendijk: 'America/Kralendijk',
    AmericaLaPaz: 'America/La_Paz',
    AmericaLima: 'America/Lima',
    AmericaLosAngeles: 'America/Los_Angeles',
    AmericaLouisville: 'America/Louisville',
    AmericaLowerPrinces: 'America/Lower_Princes',
    AmericaMaceio: 'America/Maceio',
    AmericaManagua: 'America/Managua',
    AmericaManaus: 'America/Manaus',
    AmericaMarigot: 'America/Marigot',
    AmericaMartinique: 'America/Martinique',
    AmericaMatamoros: 'America/Matamoros',
    AmericaMazatlan: 'America/Mazatlan',
    AmericaMendoza: 'America/Mendoza',
    AmericaMenominee: 'America/Menominee',
    AmericaMerida: 'America/Merida',
    AmericaMetlakatla: 'America/Metlakatla',
    AmericaMexicoCity: 'America/Mexico_City',
    AmericaMiquelon: 'America/Miquelon',
    AmericaMoncton: 'America/Moncton',
    AmericaMonterrey: 'America/Monterrey',
    AmericaMontevideo: 'America/Montevideo',
    AmericaMontreal: 'America/Montreal',
    AmericaMontserrat: 'America/Montserrat',
    AmericaNassau: 'America/Nassau',
    AmericaNewYork: 'America/New_York',
    AmericaNipigon: 'America/Nipigon',
    AmericaNome: 'America/Nome',
    AmericaNoronha: 'America/Noronha',
    AmericaNorthDakotaBeulah: 'America/North_Dakota/Beulah',
    AmericaNorthDakotaCenter: 'America/North_Dakota/Center',
    AmericaNorthDakotaNewSalem: 'America/North_Dakota/New_Salem',
    AmericaOjinaga: 'America/Ojinaga',
    AmericaPanama: 'America/Panama',
    AmericaPangnirtung: 'America/Pangnirtung',
    AmericaParamaribo: 'America/Paramaribo',
    AmericaPhoenix: 'America/Phoenix',
    AmericaPortAuPrince: 'America/Port-au-Prince',
    AmericaPortOfSpain: 'America/Port_of_Spain',
    AmericaPortoAcre: 'America/Porto_Acre',
    AmericaPortoVelho: 'America/Porto_Velho',
    AmericaPuertoRico: 'America/Puerto_Rico',
    AmericaRainyRiver: 'America/Rainy_River',
    AmericaRankinInlet: 'America/Rankin_Inlet',
    AmericaRecife: 'America/Recife',
    AmericaRegina: 'America/Regina',
    AmericaResolute: 'America/Resolute',
    AmericaRioBranco: 'America/Rio_Branco',
    AmericaRosario: 'America/Rosario',
    AmericaSantaIsabel: 'America/Santa_Isabel',
    AmericaSantarem: 'America/Santarem',
    AmericaSantiago: 'America/Santiago',
    AmericaSantoDomingo: 'America/Santo_Domingo',
    AmericaSaoPaulo: 'America/Sao_Paulo',
    AmericaScoresbysund: 'America/Scoresbysund',
    AmericaShiprock: 'America/Shiprock',
    AmericaSitka: 'America/Sitka',
    AmericaStBarthelemy: 'America/St_Barthelemy',
    AmericaStJohns: 'America/St_Johns',
    AmericaStKitts: 'America/St_Kitts',
    AmericaStLucia: 'America/St_Lucia',
    AmericaStThomas: 'America/St_Thomas',
    AmericaStVincent: 'America/St_Vincent',
    AmericaSwiftCurrent: 'America/Swift_Current',
    AmericaTegucigalpa: 'America/Tegucigalpa',
    AmericaThule: 'America/Thule',
    AmericaThunderBay: 'America/Thunder_Bay',
    AmericaTijuana: 'America/Tijuana',
    AmericaToronto: 'America/Toronto',
    AmericaTortola: 'America/Tortola',
    AmericaVancouver: 'America/Vancouver',
    AmericaVirgin: 'America/Virgin',
    AmericaWhitehorse: 'America/Whitehorse',
    AmericaWinnipeg: 'America/Winnipeg',
    AmericaYakutat: 'America/Yakutat',
    AmericaYellowknife: 'America/Yellowknife',
    AntarcticaCasey: 'Antarctica/Casey',
    AntarcticaDavis: 'Antarctica/Davis',
    AntarcticaDumontDUrville: 'Antarctica/DumontDUrville',
    AntarcticaMacquarie: 'Antarctica/Macquarie',
    AntarcticaMawson: 'Antarctica/Mawson',
    AntarcticaMcMurdo: 'Antarctica/McMurdo',
    AntarcticaPalmer: 'Antarctica/Palmer',
    AntarcticaRothera: 'Antarctica/Rothera',
    AntarcticaSouthPole: 'Antarctica/South_Pole',
    AntarcticaSyowa: 'Antarctica/Syowa',
    AntarcticaTroll: 'Antarctica/Troll',
    AntarcticaVostok: 'Antarctica/Vostok',
    ArcticLongyearbyen: 'Arctic/Longyearbyen',
    AsiaAden: 'Asia/Aden',
    AsiaAlmaty: 'Asia/Almaty',
    AsiaAmman: 'Asia/Amman',
    AsiaAnadyr: 'Asia/Anadyr',
    AsiaAqtau: 'Asia/Aqtau',
    AsiaAqtobe: 'Asia/Aqtobe',
    AsiaAshgabat: 'Asia/Ashgabat',
    AsiaAshkhabad: 'Asia/Ashkhabad',
    AsiaBaghdad: 'Asia/Baghdad',
    AsiaBahrain: 'Asia/Bahrain',
    AsiaBaku: 'Asia/Baku',
    AsiaBangkok: 'Asia/Bangkok',
    AsiaBeirut: 'Asia/Beirut',
    AsiaBishkek: 'Asia/Bishkek',
    AsiaBrunei: 'Asia/Brunei',
    AsiaCalcutta: 'Asia/Calcutta',
    AsiaChita: 'Asia/Chita',
    AsiaChoibalsan: 'Asia/Choibalsan',
    AsiaChongqing: 'Asia/Chongqing',
    AsiaChungking: 'Asia/Chungking',
    AsiaColombo: 'Asia/Colombo',
    AsiaDacca: 'Asia/Dacca',
    AsiaDamascus: 'Asia/Damascus',
    AsiaDhaka: 'Asia/Dhaka',
    AsiaDili: 'Asia/Dili',
    AsiaDubai: 'Asia/Dubai',
    AsiaDushanbe: 'Asia/Dushanbe',
    AsiaGaza: 'Asia/Gaza',
    AsiaHarbin: 'Asia/Harbin',
    AsiaHebron: 'Asia/Hebron',
    AsiaHoChiMinh: 'Asia/Ho_Chi_Minh',
    AsiaHongKong: 'Asia/Hong_Kong',
    AsiaHovd: 'Asia/Hovd',
    AsiaIrkutsk: 'Asia/Irkutsk',
    AsiaIstanbul: 'Asia/Istanbul',
    AsiaJakarta: 'Asia/Jakarta',
    AsiaJayapura: 'Asia/Jayapura',
    AsiaJerusalem: 'Asia/Jerusalem',
    AsiaKabul: 'Asia/Kabul',
    AsiaKamchatka: 'Asia/Kamchatka',
    AsiaKarachi: 'Asia/Karachi',
    AsiaKashgar: 'Asia/Kashgar',
    AsiaKathmandu: 'Asia/Kathmandu',
    AsiaKatmandu: 'Asia/Katmandu',
    AsiaKhandyga: 'Asia/Khandyga',
    AsiaKolkata: 'Asia/Kolkata',
    AsiaKrasnoyarsk: 'Asia/Krasnoyarsk',
    AsiaKualaLumpur: 'Asia/Kuala_Lumpur',
    AsiaKuching: 'Asia/Kuching',
    AsiaKuwait: 'Asia/Kuwait',
    AsiaMacao: 'Asia/Macao',
    AsiaMacau: 'Asia/Macau',
    AsiaMagadan: 'Asia/Magadan',
    AsiaMakassar: 'Asia/Makassar',
    AsiaManila: 'Asia/Manila',
    AsiaMuscat: 'Asia/Muscat',
    AsiaNicosia: 'Asia/Nicosia',
    AsiaNovokuznetsk: 'Asia/Novokuznetsk',
    AsiaNovosibirsk: 'Asia/Novosibirsk',
    AsiaOmsk: 'Asia/Omsk',
    AsiaOral: 'Asia/Oral',
    AsiaPhnomPenh: 'Asia/Phnom_Penh',
    AsiaPontianak: 'Asia/Pontianak',
    AsiaPyongyang: 'Asia/Pyongyang',
    AsiaQatar: 'Asia/Qatar',
    AsiaQyzylorda: 'Asia/Qyzylorda',
    AsiaRangoon: 'Asia/Rangoon',
    AsiaRiyadh: 'Asia/Riyadh',
    AsiaSaigon: 'Asia/Saigon',
    AsiaSakhalin: 'Asia/Sakhalin',
    AsiaSamarkand: 'Asia/Samarkand',
    AsiaSeoul: 'Asia/Seoul',
    AsiaShanghai: 'Asia/Shanghai',
    AsiaSingapore: 'Asia/Singapore',
    AsiaSrednekolymsk: 'Asia/Srednekolymsk',
    AsiaTaipei: 'Asia/Taipei',
    AsiaTashkent: 'Asia/Tashkent',
    AsiaTbilisi: 'Asia/Tbilisi',
    AsiaTehran: 'Asia/Tehran',
    AsiaTelAviv: 'Asia/Tel_Aviv',
    AsiaThimbu: 'Asia/Thimbu',
    AsiaThimphu: 'Asia/Thimphu',
    AsiaTokyo: 'Asia/Tokyo',
    AsiaUjungPandang: 'Asia/Ujung_Pandang',
    AsiaUlaanbaatar: 'Asia/Ulaanbaatar',
    AsiaUlanBator: 'Asia/Ulan_Bator',
    AsiaUrumqi: 'Asia/Urumqi',
    AsiaUstNera: 'Asia/Ust-Nera',
    AsiaVientiane: 'Asia/Vientiane',
    AsiaVladivostok: 'Asia/Vladivostok',
    AsiaYakutsk: 'Asia/Yakutsk',
    AsiaYekaterinburg: 'Asia/Yekaterinburg',
    AsiaYerevan: 'Asia/Yerevan',
    AtlanticAzores: 'Atlantic/Azores',
    AtlanticBermuda: 'Atlantic/Bermuda',
    AtlanticCanary: 'Atlantic/Canary',
    AtlanticCapeVerde: 'Atlantic/Cape_Verde',
    AtlanticFaeroe: 'Atlantic/Faeroe',
    AtlanticFaroe: 'Atlantic/Faroe',
    AtlanticJanMayen: 'Atlantic/Jan_Mayen',
    AtlanticMadeira: 'Atlantic/Madeira',
    AtlanticReykjavik: 'Atlantic/Reykjavik',
    AtlanticSouthGeorgia: 'Atlantic/South_Georgia',
    AtlanticStHelena: 'Atlantic/St_Helena',
    AtlanticStanley: 'Atlantic/Stanley',
    AustraliaAct: 'Australia/ACT',
    AustraliaAdelaide: 'Australia/Adelaide',
    AustraliaBrisbane: 'Australia/Brisbane',
    AustraliaBrokenHill: 'Australia/Broken_Hill',
    AustraliaCanberra: 'Australia/Canberra',
    AustraliaCurrie: 'Australia/Currie',
    AustraliaDarwin: 'Australia/Darwin',
    AustraliaEucla: 'Australia/Eucla',
    AustraliaHobart: 'Australia/Hobart',
    AustraliaLhi: 'Australia/LHI',
    AustraliaLindeman: 'Australia/Lindeman',
    AustraliaLordHowe: 'Australia/Lord_Howe',
    AustraliaMelbourne: 'Australia/Melbourne',
    AustraliaNsw: 'Australia/NSW',
    AustraliaNorth: 'Australia/North',
    AustraliaPerth: 'Australia/Perth',
    AustraliaQueensland: 'Australia/Queensland',
    AustraliaSouth: 'Australia/South',
    AustraliaSydney: 'Australia/Sydney',
    AustraliaTasmania: 'Australia/Tasmania',
    AustraliaVictoria: 'Australia/Victoria',
    AustraliaWest: 'Australia/West',
    AustraliaYancowinna: 'Australia/Yancowinna',
    BrazilAcre: 'Brazil/Acre',
    BrazilDeNoronha: 'Brazil/DeNoronha',
    BrazilEast: 'Brazil/East',
    BrazilWest: 'Brazil/West',
    CanadaAtlantic: 'Canada/Atlantic',
    CanadaCentral: 'Canada/Central',
    CanadaEastSaskatchewan: 'Canada/East-Saskatchewan',
    CanadaEastern: 'Canada/Eastern',
    CanadaMountain: 'Canada/Mountain',
    CanadaNewfoundland: 'Canada/Newfoundland',
    CanadaPacific: 'Canada/Pacific',
    CanadaSaskatchewan: 'Canada/Saskatchewan',
    CanadaYukon: 'Canada/Yukon',
    ChileContinental: 'Chile/Continental',
    ChileEasterIsland: 'Chile/EasterIsland',
    EtcGmt: 'Etc/GMT',
    EtcGmt0: 'Etc/GMT+0',
    EtcGmt1: 'Etc/GMT+1',
    EtcGmt10: 'Etc/GMT+10',
    EtcGmt11: 'Etc/GMT+11',
    EtcGmt12: 'Etc/GMT+12',
    EtcGmt2: 'Etc/GMT+2',
    EtcGmt3: 'Etc/GMT+3',
    EtcGmt4: 'Etc/GMT+4',
    EtcGmt5: 'Etc/GMT+5',
    EtcGmt6: 'Etc/GMT+6',
    EtcGmt7: 'Etc/GMT+7',
    EtcGmt8: 'Etc/GMT+8',
    EtcGmt9: 'Etc/GMT+9',
    EtcGmt13: 'Etc/GMT-13',
    EtcGmt14: 'Etc/GMT-14',
    EtcGreenwich: 'Etc/Greenwich',
    EtcUct: 'Etc/UCT',
    EtcUtc: 'Etc/UTC',
    EtcUniversal: 'Etc/Universal',
    EtcZulu: 'Etc/Zulu',
    EuropeAmsterdam: 'Europe/Amsterdam',
    EuropeAndorra: 'Europe/Andorra',
    EuropeAthens: 'Europe/Athens',
    EuropeBelfast: 'Europe/Belfast',
    EuropeBelgrade: 'Europe/Belgrade',
    EuropeBerlin: 'Europe/Berlin',
    EuropeBratislava: 'Europe/Bratislava',
    EuropeBrussels: 'Europe/Brussels',
    EuropeBucharest: 'Europe/Bucharest',
    EuropeBudapest: 'Europe/Budapest',
    EuropeBusingen: 'Europe/Busingen',
    EuropeChisinau: 'Europe/Chisinau',
    EuropeCopenhagen: 'Europe/Copenhagen',
    EuropeDublin: 'Europe/Dublin',
    EuropeGibraltar: 'Europe/Gibraltar',
    EuropeGuernsey: 'Europe/Guernsey',
    EuropeHelsinki: 'Europe/Helsinki',
    EuropeIsleOfMan: 'Europe/Isle_of_Man',
    EuropeIstanbul: 'Europe/Istanbul',
    EuropeJersey: 'Europe/Jersey',
    EuropeKaliningrad: 'Europe/Kaliningrad',
    EuropeKiev: 'Europe/Kiev',
    EuropeLisbon: 'Europe/Lisbon',
    EuropeLjubljana: 'Europe/Ljubljana',
    EuropeLondon: 'Europe/London',
    EuropeLuxembourg: 'Europe/Luxembourg',
    EuropeMadrid: 'Europe/Madrid',
    EuropeMalta: 'Europe/Malta',
    EuropeMariehamn: 'Europe/Mariehamn',
    EuropeMinsk: 'Europe/Minsk',
    EuropeMonaco: 'Europe/Monaco',
    EuropeMoscow: 'Europe/Moscow',
    EuropeNicosia: 'Europe/Nicosia',
    EuropeOslo: 'Europe/Oslo',
    EuropeParis: 'Europe/Paris',
    EuropePodgorica: 'Europe/Podgorica',
    EuropePrague: 'Europe/Prague',
    EuropeRiga: 'Europe/Riga',
    EuropeRome: 'Europe/Rome',
    EuropeSamara: 'Europe/Samara',
    EuropeSanMarino: 'Europe/San_Marino',
    EuropeSarajevo: 'Europe/Sarajevo',
    EuropeSimferopol: 'Europe/Simferopol',
    EuropeSkopje: 'Europe/Skopje',
    EuropeSofia: 'Europe/Sofia',
    EuropeStockholm: 'Europe/Stockholm',
    EuropeTallinn: 'Europe/Tallinn',
    EuropeTirane: 'Europe/Tirane',
    EuropeTiraspol: 'Europe/Tiraspol',
    EuropeUzhgorod: 'Europe/Uzhgorod',
    EuropeVaduz: 'Europe/Vaduz',
    EuropeVatican: 'Europe/Vatican',
    EuropeVienna: 'Europe/Vienna',
    EuropeVilnius: 'Europe/Vilnius',
    EuropeVolgograd: 'Europe/Volgograd',
    EuropeWarsaw: 'Europe/Warsaw',
    EuropeZagreb: 'Europe/Zagreb',
    EuropeZaporozhye: 'Europe/Zaporozhye',
    EuropeZurich: 'Europe/Zurich',
    IndianAntananarivo: 'Indian/Antananarivo',
    IndianChagos: 'Indian/Chagos',
    IndianChristmas: 'Indian/Christmas',
    IndianCocos: 'Indian/Cocos',
    IndianComoro: 'Indian/Comoro',
    IndianKerguelen: 'Indian/Kerguelen',
    IndianMahe: 'Indian/Mahe',
    IndianMaldives: 'Indian/Maldives',
    IndianMauritius: 'Indian/Mauritius',
    IndianMayotte: 'Indian/Mayotte',
    IndianReunion: 'Indian/Reunion',
    MexicoBajaNorte: 'Mexico/BajaNorte',
    MexicoBajaSur: 'Mexico/BajaSur',
    MexicoGeneral: 'Mexico/General',
    PacificApia: 'Pacific/Apia',
    PacificAuckland: 'Pacific/Auckland',
    PacificChatham: 'Pacific/Chatham',
    PacificChuuk: 'Pacific/Chuuk',
    PacificEaster: 'Pacific/Easter',
    PacificEfate: 'Pacific/Efate',
    PacificEnderbury: 'Pacific/Enderbury',
    PacificFakaofo: 'Pacific/Fakaofo',
    PacificFiji: 'Pacific/Fiji',
    PacificFunafuti: 'Pacific/Funafuti',
    PacificGalapagos: 'Pacific/Galapagos',
    PacificGambier: 'Pacific/Gambier',
    PacificGuadalcanal: 'Pacific/Guadalcanal',
    PacificGuam: 'Pacific/Guam',
    PacificHonolulu: 'Pacific/Honolulu',
    PacificJohnston: 'Pacific/Johnston',
    PacificKiritimati: 'Pacific/Kiritimati',
    PacificKosrae: 'Pacific/Kosrae',
    PacificKwajalein: 'Pacific/Kwajalein',
    PacificMajuro: 'Pacific/Majuro',
    PacificMarquesas: 'Pacific/Marquesas',
    PacificMidway: 'Pacific/Midway',
    PacificNauru: 'Pacific/Nauru',
    PacificNiue: 'Pacific/Niue',
    PacificNorfolk: 'Pacific/Norfolk',
    PacificNoumea: 'Pacific/Noumea',
    PacificPagoPago: 'Pacific/Pago_Pago',
    PacificPalau: 'Pacific/Palau',
    PacificPitcairn: 'Pacific/Pitcairn',
    PacificPohnpei: 'Pacific/Pohnpei',
    PacificPonape: 'Pacific/Ponape',
    PacificPortMoresby: 'Pacific/Port_Moresby',
    PacificRarotonga: 'Pacific/Rarotonga',
    PacificSaipan: 'Pacific/Saipan',
    PacificSamoa: 'Pacific/Samoa',
    PacificTahiti: 'Pacific/Tahiti',
    PacificTarawa: 'Pacific/Tarawa',
    PacificTongatapu: 'Pacific/Tongatapu',
    PacificTruk: 'Pacific/Truk',
    PacificWake: 'Pacific/Wake',
    PacificWallis: 'Pacific/Wallis',
    PacificYap: 'Pacific/Yap'
} as const;

export type ReportRunCreateParamsParametersTimeZoneEnum = typeof ReportRunCreateParamsParametersTimeZoneEnum[keyof typeof ReportRunCreateParamsParametersTimeZoneEnum];

/**
 * 
 * @export
 * @interface ReportRunRequestParameters
 */
export interface ReportRunRequestParameters {
    /**
     * Timezone of the Report Run
     * @type {string}
     * @memberof ReportRunRequestParameters
     */
    'time_zone'?: ReportRunRequestParametersTimeZoneEnum;
    /**
     * Date of the start of the data to include in the Report Run
     * @type {string}
     * @memberof ReportRunRequestParameters
     */
    'start_at': string;
    /**
     * Date of the end of the data to include in the Report Run
     * @type {string}
     * @memberof ReportRunRequestParameters
     */
    'end_at': string;
    /**
     * The specific child Account Id to run a report on
     * @type {string}
     * @memberof ReportRunRequestParameters
     */
    'account_id'?: string;
}

export const ReportRunRequestParametersTimeZoneEnum = {
    AfricaAbidjan: 'Africa/Abidjan',
    AfricaAccra: 'Africa/Accra',
    AfricaAddisAbaba: 'Africa/Addis_Ababa',
    AfricaAlgiers: 'Africa/Algiers',
    AfricaAsmara: 'Africa/Asmara',
    AfricaAsmera: 'Africa/Asmera',
    AfricaBamako: 'Africa/Bamako',
    AfricaBangui: 'Africa/Bangui',
    AfricaBanjul: 'Africa/Banjul',
    AfricaBissau: 'Africa/Bissau',
    AfricaBlantyre: 'Africa/Blantyre',
    AfricaBrazzaville: 'Africa/Brazzaville',
    AfricaBujumbura: 'Africa/Bujumbura',
    AfricaCairo: 'Africa/Cairo',
    AfricaCasablanca: 'Africa/Casablanca',
    AfricaCeuta: 'Africa/Ceuta',
    AfricaConakry: 'Africa/Conakry',
    AfricaDakar: 'Africa/Dakar',
    AfricaDarEsSalaam: 'Africa/Dar_es_Salaam',
    AfricaDjibouti: 'Africa/Djibouti',
    AfricaDouala: 'Africa/Douala',
    AfricaElAaiun: 'Africa/El_Aaiun',
    AfricaFreetown: 'Africa/Freetown',
    AfricaGaborone: 'Africa/Gaborone',
    AfricaHarare: 'Africa/Harare',
    AfricaJohannesburg: 'Africa/Johannesburg',
    AfricaJuba: 'Africa/Juba',
    AfricaKampala: 'Africa/Kampala',
    AfricaKhartoum: 'Africa/Khartoum',
    AfricaKigali: 'Africa/Kigali',
    AfricaKinshasa: 'Africa/Kinshasa',
    AfricaLagos: 'Africa/Lagos',
    AfricaLibreville: 'Africa/Libreville',
    AfricaLome: 'Africa/Lome',
    AfricaLuanda: 'Africa/Luanda',
    AfricaLubumbashi: 'Africa/Lubumbashi',
    AfricaLusaka: 'Africa/Lusaka',
    AfricaMalabo: 'Africa/Malabo',
    AfricaMaputo: 'Africa/Maputo',
    AfricaMaseru: 'Africa/Maseru',
    AfricaMbabane: 'Africa/Mbabane',
    AfricaMogadishu: 'Africa/Mogadishu',
    AfricaMonrovia: 'Africa/Monrovia',
    AfricaNairobi: 'Africa/Nairobi',
    AfricaNdjamena: 'Africa/Ndjamena',
    AfricaNiamey: 'Africa/Niamey',
    AfricaNouakchott: 'Africa/Nouakchott',
    AfricaOuagadougou: 'Africa/Ouagadougou',
    AfricaPortoNovo: 'Africa/Porto-Novo',
    AfricaSaoTome: 'Africa/Sao_Tome',
    AfricaTimbuktu: 'Africa/Timbuktu',
    AfricaTripoli: 'Africa/Tripoli',
    AfricaTunis: 'Africa/Tunis',
    AfricaWindhoek: 'Africa/Windhoek',
    AmericaAdak: 'America/Adak',
    AmericaAnchorage: 'America/Anchorage',
    AmericaAnguilla: 'America/Anguilla',
    AmericaAntigua: 'America/Antigua',
    AmericaAraguaina: 'America/Araguaina',
    AmericaArgentinaBuenosAires: 'America/Argentina/Buenos_Aires',
    AmericaArgentinaCatamarca: 'America/Argentina/Catamarca',
    AmericaArgentinaComodRivadavia: 'America/Argentina/ComodRivadavia',
    AmericaArgentinaCordoba: 'America/Argentina/Cordoba',
    AmericaArgentinaJujuy: 'America/Argentina/Jujuy',
    AmericaArgentinaLaRioja: 'America/Argentina/La_Rioja',
    AmericaArgentinaMendoza: 'America/Argentina/Mendoza',
    AmericaArgentinaRioGallegos: 'America/Argentina/Rio_Gallegos',
    AmericaArgentinaSalta: 'America/Argentina/Salta',
    AmericaArgentinaSanJuan: 'America/Argentina/San_Juan',
    AmericaArgentinaSanLuis: 'America/Argentina/San_Luis',
    AmericaArgentinaTucuman: 'America/Argentina/Tucuman',
    AmericaArgentinaUshuaia: 'America/Argentina/Ushuaia',
    AmericaAruba: 'America/Aruba',
    AmericaAsuncion: 'America/Asuncion',
    AmericaAtikokan: 'America/Atikokan',
    AmericaAtka: 'America/Atka',
    AmericaBahia: 'America/Bahia',
    AmericaBahiaBanderas: 'America/Bahia_Banderas',
    AmericaBarbados: 'America/Barbados',
    AmericaBelem: 'America/Belem',
    AmericaBelize: 'America/Belize',
    AmericaBlancSablon: 'America/Blanc-Sablon',
    AmericaBoaVista: 'America/Boa_Vista',
    AmericaBogota: 'America/Bogota',
    AmericaBoise: 'America/Boise',
    AmericaBuenosAires: 'America/Buenos_Aires',
    AmericaCambridgeBay: 'America/Cambridge_Bay',
    AmericaCampoGrande: 'America/Campo_Grande',
    AmericaCancun: 'America/Cancun',
    AmericaCaracas: 'America/Caracas',
    AmericaCatamarca: 'America/Catamarca',
    AmericaCayenne: 'America/Cayenne',
    AmericaCayman: 'America/Cayman',
    AmericaChicago: 'America/Chicago',
    AmericaChihuahua: 'America/Chihuahua',
    AmericaCoralHarbour: 'America/Coral_Harbour',
    AmericaCordoba: 'America/Cordoba',
    AmericaCostaRica: 'America/Costa_Rica',
    AmericaCreston: 'America/Creston',
    AmericaCuiaba: 'America/Cuiaba',
    AmericaCuracao: 'America/Curacao',
    AmericaDanmarkshavn: 'America/Danmarkshavn',
    AmericaDawson: 'America/Dawson',
    AmericaDawsonCreek: 'America/Dawson_Creek',
    AmericaDenver: 'America/Denver',
    AmericaDetroit: 'America/Detroit',
    AmericaDominica: 'America/Dominica',
    AmericaEdmonton: 'America/Edmonton',
    AmericaEirunepe: 'America/Eirunepe',
    AmericaElSalvador: 'America/El_Salvador',
    AmericaEnsenada: 'America/Ensenada',
    AmericaFortWayne: 'America/Fort_Wayne',
    AmericaFortaleza: 'America/Fortaleza',
    AmericaGlaceBay: 'America/Glace_Bay',
    AmericaGodthab: 'America/Godthab',
    AmericaGooseBay: 'America/Goose_Bay',
    AmericaGrandTurk: 'America/Grand_Turk',
    AmericaGrenada: 'America/Grenada',
    AmericaGuadeloupe: 'America/Guadeloupe',
    AmericaGuatemala: 'America/Guatemala',
    AmericaGuayaquil: 'America/Guayaquil',
    AmericaGuyana: 'America/Guyana',
    AmericaHalifax: 'America/Halifax',
    AmericaHavana: 'America/Havana',
    AmericaHermosillo: 'America/Hermosillo',
    AmericaIndianaIndianapolis: 'America/Indiana/Indianapolis',
    AmericaIndianaKnox: 'America/Indiana/Knox',
    AmericaIndianaMarengo: 'America/Indiana/Marengo',
    AmericaIndianaPetersburg: 'America/Indiana/Petersburg',
    AmericaIndianaTellCity: 'America/Indiana/Tell_City',
    AmericaIndianaVevay: 'America/Indiana/Vevay',
    AmericaIndianaVincennes: 'America/Indiana/Vincennes',
    AmericaIndianaWinamac: 'America/Indiana/Winamac',
    AmericaIndianapolis: 'America/Indianapolis',
    AmericaInuvik: 'America/Inuvik',
    AmericaIqaluit: 'America/Iqaluit',
    AmericaJamaica: 'America/Jamaica',
    AmericaJujuy: 'America/Jujuy',
    AmericaJuneau: 'America/Juneau',
    AmericaKentuckyLouisville: 'America/Kentucky/Louisville',
    AmericaKentuckyMonticello: 'America/Kentucky/Monticello',
    AmericaKnoxIn: 'America/Knox_IN',
    AmericaKralendijk: 'America/Kralendijk',
    AmericaLaPaz: 'America/La_Paz',
    AmericaLima: 'America/Lima',
    AmericaLosAngeles: 'America/Los_Angeles',
    AmericaLouisville: 'America/Louisville',
    AmericaLowerPrinces: 'America/Lower_Princes',
    AmericaMaceio: 'America/Maceio',
    AmericaManagua: 'America/Managua',
    AmericaManaus: 'America/Manaus',
    AmericaMarigot: 'America/Marigot',
    AmericaMartinique: 'America/Martinique',
    AmericaMatamoros: 'America/Matamoros',
    AmericaMazatlan: 'America/Mazatlan',
    AmericaMendoza: 'America/Mendoza',
    AmericaMenominee: 'America/Menominee',
    AmericaMerida: 'America/Merida',
    AmericaMetlakatla: 'America/Metlakatla',
    AmericaMexicoCity: 'America/Mexico_City',
    AmericaMiquelon: 'America/Miquelon',
    AmericaMoncton: 'America/Moncton',
    AmericaMonterrey: 'America/Monterrey',
    AmericaMontevideo: 'America/Montevideo',
    AmericaMontreal: 'America/Montreal',
    AmericaMontserrat: 'America/Montserrat',
    AmericaNassau: 'America/Nassau',
    AmericaNewYork: 'America/New_York',
    AmericaNipigon: 'America/Nipigon',
    AmericaNome: 'America/Nome',
    AmericaNoronha: 'America/Noronha',
    AmericaNorthDakotaBeulah: 'America/North_Dakota/Beulah',
    AmericaNorthDakotaCenter: 'America/North_Dakota/Center',
    AmericaNorthDakotaNewSalem: 'America/North_Dakota/New_Salem',
    AmericaOjinaga: 'America/Ojinaga',
    AmericaPanama: 'America/Panama',
    AmericaPangnirtung: 'America/Pangnirtung',
    AmericaParamaribo: 'America/Paramaribo',
    AmericaPhoenix: 'America/Phoenix',
    AmericaPortAuPrince: 'America/Port-au-Prince',
    AmericaPortOfSpain: 'America/Port_of_Spain',
    AmericaPortoAcre: 'America/Porto_Acre',
    AmericaPortoVelho: 'America/Porto_Velho',
    AmericaPuertoRico: 'America/Puerto_Rico',
    AmericaRainyRiver: 'America/Rainy_River',
    AmericaRankinInlet: 'America/Rankin_Inlet',
    AmericaRecife: 'America/Recife',
    AmericaRegina: 'America/Regina',
    AmericaResolute: 'America/Resolute',
    AmericaRioBranco: 'America/Rio_Branco',
    AmericaRosario: 'America/Rosario',
    AmericaSantaIsabel: 'America/Santa_Isabel',
    AmericaSantarem: 'America/Santarem',
    AmericaSantiago: 'America/Santiago',
    AmericaSantoDomingo: 'America/Santo_Domingo',
    AmericaSaoPaulo: 'America/Sao_Paulo',
    AmericaScoresbysund: 'America/Scoresbysund',
    AmericaShiprock: 'America/Shiprock',
    AmericaSitka: 'America/Sitka',
    AmericaStBarthelemy: 'America/St_Barthelemy',
    AmericaStJohns: 'America/St_Johns',
    AmericaStKitts: 'America/St_Kitts',
    AmericaStLucia: 'America/St_Lucia',
    AmericaStThomas: 'America/St_Thomas',
    AmericaStVincent: 'America/St_Vincent',
    AmericaSwiftCurrent: 'America/Swift_Current',
    AmericaTegucigalpa: 'America/Tegucigalpa',
    AmericaThule: 'America/Thule',
    AmericaThunderBay: 'America/Thunder_Bay',
    AmericaTijuana: 'America/Tijuana',
    AmericaToronto: 'America/Toronto',
    AmericaTortola: 'America/Tortola',
    AmericaVancouver: 'America/Vancouver',
    AmericaVirgin: 'America/Virgin',
    AmericaWhitehorse: 'America/Whitehorse',
    AmericaWinnipeg: 'America/Winnipeg',
    AmericaYakutat: 'America/Yakutat',
    AmericaYellowknife: 'America/Yellowknife',
    AntarcticaCasey: 'Antarctica/Casey',
    AntarcticaDavis: 'Antarctica/Davis',
    AntarcticaDumontDUrville: 'Antarctica/DumontDUrville',
    AntarcticaMacquarie: 'Antarctica/Macquarie',
    AntarcticaMawson: 'Antarctica/Mawson',
    AntarcticaMcMurdo: 'Antarctica/McMurdo',
    AntarcticaPalmer: 'Antarctica/Palmer',
    AntarcticaRothera: 'Antarctica/Rothera',
    AntarcticaSouthPole: 'Antarctica/South_Pole',
    AntarcticaSyowa: 'Antarctica/Syowa',
    AntarcticaTroll: 'Antarctica/Troll',
    AntarcticaVostok: 'Antarctica/Vostok',
    ArcticLongyearbyen: 'Arctic/Longyearbyen',
    AsiaAden: 'Asia/Aden',
    AsiaAlmaty: 'Asia/Almaty',
    AsiaAmman: 'Asia/Amman',
    AsiaAnadyr: 'Asia/Anadyr',
    AsiaAqtau: 'Asia/Aqtau',
    AsiaAqtobe: 'Asia/Aqtobe',
    AsiaAshgabat: 'Asia/Ashgabat',
    AsiaAshkhabad: 'Asia/Ashkhabad',
    AsiaBaghdad: 'Asia/Baghdad',
    AsiaBahrain: 'Asia/Bahrain',
    AsiaBaku: 'Asia/Baku',
    AsiaBangkok: 'Asia/Bangkok',
    AsiaBeirut: 'Asia/Beirut',
    AsiaBishkek: 'Asia/Bishkek',
    AsiaBrunei: 'Asia/Brunei',
    AsiaCalcutta: 'Asia/Calcutta',
    AsiaChita: 'Asia/Chita',
    AsiaChoibalsan: 'Asia/Choibalsan',
    AsiaChongqing: 'Asia/Chongqing',
    AsiaChungking: 'Asia/Chungking',
    AsiaColombo: 'Asia/Colombo',
    AsiaDacca: 'Asia/Dacca',
    AsiaDamascus: 'Asia/Damascus',
    AsiaDhaka: 'Asia/Dhaka',
    AsiaDili: 'Asia/Dili',
    AsiaDubai: 'Asia/Dubai',
    AsiaDushanbe: 'Asia/Dushanbe',
    AsiaGaza: 'Asia/Gaza',
    AsiaHarbin: 'Asia/Harbin',
    AsiaHebron: 'Asia/Hebron',
    AsiaHoChiMinh: 'Asia/Ho_Chi_Minh',
    AsiaHongKong: 'Asia/Hong_Kong',
    AsiaHovd: 'Asia/Hovd',
    AsiaIrkutsk: 'Asia/Irkutsk',
    AsiaIstanbul: 'Asia/Istanbul',
    AsiaJakarta: 'Asia/Jakarta',
    AsiaJayapura: 'Asia/Jayapura',
    AsiaJerusalem: 'Asia/Jerusalem',
    AsiaKabul: 'Asia/Kabul',
    AsiaKamchatka: 'Asia/Kamchatka',
    AsiaKarachi: 'Asia/Karachi',
    AsiaKashgar: 'Asia/Kashgar',
    AsiaKathmandu: 'Asia/Kathmandu',
    AsiaKatmandu: 'Asia/Katmandu',
    AsiaKhandyga: 'Asia/Khandyga',
    AsiaKolkata: 'Asia/Kolkata',
    AsiaKrasnoyarsk: 'Asia/Krasnoyarsk',
    AsiaKualaLumpur: 'Asia/Kuala_Lumpur',
    AsiaKuching: 'Asia/Kuching',
    AsiaKuwait: 'Asia/Kuwait',
    AsiaMacao: 'Asia/Macao',
    AsiaMacau: 'Asia/Macau',
    AsiaMagadan: 'Asia/Magadan',
    AsiaMakassar: 'Asia/Makassar',
    AsiaManila: 'Asia/Manila',
    AsiaMuscat: 'Asia/Muscat',
    AsiaNicosia: 'Asia/Nicosia',
    AsiaNovokuznetsk: 'Asia/Novokuznetsk',
    AsiaNovosibirsk: 'Asia/Novosibirsk',
    AsiaOmsk: 'Asia/Omsk',
    AsiaOral: 'Asia/Oral',
    AsiaPhnomPenh: 'Asia/Phnom_Penh',
    AsiaPontianak: 'Asia/Pontianak',
    AsiaPyongyang: 'Asia/Pyongyang',
    AsiaQatar: 'Asia/Qatar',
    AsiaQyzylorda: 'Asia/Qyzylorda',
    AsiaRangoon: 'Asia/Rangoon',
    AsiaRiyadh: 'Asia/Riyadh',
    AsiaSaigon: 'Asia/Saigon',
    AsiaSakhalin: 'Asia/Sakhalin',
    AsiaSamarkand: 'Asia/Samarkand',
    AsiaSeoul: 'Asia/Seoul',
    AsiaShanghai: 'Asia/Shanghai',
    AsiaSingapore: 'Asia/Singapore',
    AsiaSrednekolymsk: 'Asia/Srednekolymsk',
    AsiaTaipei: 'Asia/Taipei',
    AsiaTashkent: 'Asia/Tashkent',
    AsiaTbilisi: 'Asia/Tbilisi',
    AsiaTehran: 'Asia/Tehran',
    AsiaTelAviv: 'Asia/Tel_Aviv',
    AsiaThimbu: 'Asia/Thimbu',
    AsiaThimphu: 'Asia/Thimphu',
    AsiaTokyo: 'Asia/Tokyo',
    AsiaUjungPandang: 'Asia/Ujung_Pandang',
    AsiaUlaanbaatar: 'Asia/Ulaanbaatar',
    AsiaUlanBator: 'Asia/Ulan_Bator',
    AsiaUrumqi: 'Asia/Urumqi',
    AsiaUstNera: 'Asia/Ust-Nera',
    AsiaVientiane: 'Asia/Vientiane',
    AsiaVladivostok: 'Asia/Vladivostok',
    AsiaYakutsk: 'Asia/Yakutsk',
    AsiaYekaterinburg: 'Asia/Yekaterinburg',
    AsiaYerevan: 'Asia/Yerevan',
    AtlanticAzores: 'Atlantic/Azores',
    AtlanticBermuda: 'Atlantic/Bermuda',
    AtlanticCanary: 'Atlantic/Canary',
    AtlanticCapeVerde: 'Atlantic/Cape_Verde',
    AtlanticFaeroe: 'Atlantic/Faeroe',
    AtlanticFaroe: 'Atlantic/Faroe',
    AtlanticJanMayen: 'Atlantic/Jan_Mayen',
    AtlanticMadeira: 'Atlantic/Madeira',
    AtlanticReykjavik: 'Atlantic/Reykjavik',
    AtlanticSouthGeorgia: 'Atlantic/South_Georgia',
    AtlanticStHelena: 'Atlantic/St_Helena',
    AtlanticStanley: 'Atlantic/Stanley',
    AustraliaAct: 'Australia/ACT',
    AustraliaAdelaide: 'Australia/Adelaide',
    AustraliaBrisbane: 'Australia/Brisbane',
    AustraliaBrokenHill: 'Australia/Broken_Hill',
    AustraliaCanberra: 'Australia/Canberra',
    AustraliaCurrie: 'Australia/Currie',
    AustraliaDarwin: 'Australia/Darwin',
    AustraliaEucla: 'Australia/Eucla',
    AustraliaHobart: 'Australia/Hobart',
    AustraliaLhi: 'Australia/LHI',
    AustraliaLindeman: 'Australia/Lindeman',
    AustraliaLordHowe: 'Australia/Lord_Howe',
    AustraliaMelbourne: 'Australia/Melbourne',
    AustraliaNsw: 'Australia/NSW',
    AustraliaNorth: 'Australia/North',
    AustraliaPerth: 'Australia/Perth',
    AustraliaQueensland: 'Australia/Queensland',
    AustraliaSouth: 'Australia/South',
    AustraliaSydney: 'Australia/Sydney',
    AustraliaTasmania: 'Australia/Tasmania',
    AustraliaVictoria: 'Australia/Victoria',
    AustraliaWest: 'Australia/West',
    AustraliaYancowinna: 'Australia/Yancowinna',
    BrazilAcre: 'Brazil/Acre',
    BrazilDeNoronha: 'Brazil/DeNoronha',
    BrazilEast: 'Brazil/East',
    BrazilWest: 'Brazil/West',
    CanadaAtlantic: 'Canada/Atlantic',
    CanadaCentral: 'Canada/Central',
    CanadaEastSaskatchewan: 'Canada/East-Saskatchewan',
    CanadaEastern: 'Canada/Eastern',
    CanadaMountain: 'Canada/Mountain',
    CanadaNewfoundland: 'Canada/Newfoundland',
    CanadaPacific: 'Canada/Pacific',
    CanadaSaskatchewan: 'Canada/Saskatchewan',
    CanadaYukon: 'Canada/Yukon',
    ChileContinental: 'Chile/Continental',
    ChileEasterIsland: 'Chile/EasterIsland',
    EtcGmt: 'Etc/GMT',
    EtcGmt0: 'Etc/GMT+0',
    EtcGmt1: 'Etc/GMT+1',
    EtcGmt10: 'Etc/GMT+10',
    EtcGmt11: 'Etc/GMT+11',
    EtcGmt12: 'Etc/GMT+12',
    EtcGmt2: 'Etc/GMT+2',
    EtcGmt3: 'Etc/GMT+3',
    EtcGmt4: 'Etc/GMT+4',
    EtcGmt5: 'Etc/GMT+5',
    EtcGmt6: 'Etc/GMT+6',
    EtcGmt7: 'Etc/GMT+7',
    EtcGmt8: 'Etc/GMT+8',
    EtcGmt9: 'Etc/GMT+9',
    EtcGmt13: 'Etc/GMT-13',
    EtcGmt14: 'Etc/GMT-14',
    EtcGreenwich: 'Etc/Greenwich',
    EtcUct: 'Etc/UCT',
    EtcUtc: 'Etc/UTC',
    EtcUniversal: 'Etc/Universal',
    EtcZulu: 'Etc/Zulu',
    EuropeAmsterdam: 'Europe/Amsterdam',
    EuropeAndorra: 'Europe/Andorra',
    EuropeAthens: 'Europe/Athens',
    EuropeBelfast: 'Europe/Belfast',
    EuropeBelgrade: 'Europe/Belgrade',
    EuropeBerlin: 'Europe/Berlin',
    EuropeBratislava: 'Europe/Bratislava',
    EuropeBrussels: 'Europe/Brussels',
    EuropeBucharest: 'Europe/Bucharest',
    EuropeBudapest: 'Europe/Budapest',
    EuropeBusingen: 'Europe/Busingen',
    EuropeChisinau: 'Europe/Chisinau',
    EuropeCopenhagen: 'Europe/Copenhagen',
    EuropeDublin: 'Europe/Dublin',
    EuropeGibraltar: 'Europe/Gibraltar',
    EuropeGuernsey: 'Europe/Guernsey',
    EuropeHelsinki: 'Europe/Helsinki',
    EuropeIsleOfMan: 'Europe/Isle_of_Man',
    EuropeIstanbul: 'Europe/Istanbul',
    EuropeJersey: 'Europe/Jersey',
    EuropeKaliningrad: 'Europe/Kaliningrad',
    EuropeKiev: 'Europe/Kiev',
    EuropeLisbon: 'Europe/Lisbon',
    EuropeLjubljana: 'Europe/Ljubljana',
    EuropeLondon: 'Europe/London',
    EuropeLuxembourg: 'Europe/Luxembourg',
    EuropeMadrid: 'Europe/Madrid',
    EuropeMalta: 'Europe/Malta',
    EuropeMariehamn: 'Europe/Mariehamn',
    EuropeMinsk: 'Europe/Minsk',
    EuropeMonaco: 'Europe/Monaco',
    EuropeMoscow: 'Europe/Moscow',
    EuropeNicosia: 'Europe/Nicosia',
    EuropeOslo: 'Europe/Oslo',
    EuropeParis: 'Europe/Paris',
    EuropePodgorica: 'Europe/Podgorica',
    EuropePrague: 'Europe/Prague',
    EuropeRiga: 'Europe/Riga',
    EuropeRome: 'Europe/Rome',
    EuropeSamara: 'Europe/Samara',
    EuropeSanMarino: 'Europe/San_Marino',
    EuropeSarajevo: 'Europe/Sarajevo',
    EuropeSimferopol: 'Europe/Simferopol',
    EuropeSkopje: 'Europe/Skopje',
    EuropeSofia: 'Europe/Sofia',
    EuropeStockholm: 'Europe/Stockholm',
    EuropeTallinn: 'Europe/Tallinn',
    EuropeTirane: 'Europe/Tirane',
    EuropeTiraspol: 'Europe/Tiraspol',
    EuropeUzhgorod: 'Europe/Uzhgorod',
    EuropeVaduz: 'Europe/Vaduz',
    EuropeVatican: 'Europe/Vatican',
    EuropeVienna: 'Europe/Vienna',
    EuropeVilnius: 'Europe/Vilnius',
    EuropeVolgograd: 'Europe/Volgograd',
    EuropeWarsaw: 'Europe/Warsaw',
    EuropeZagreb: 'Europe/Zagreb',
    EuropeZaporozhye: 'Europe/Zaporozhye',
    EuropeZurich: 'Europe/Zurich',
    IndianAntananarivo: 'Indian/Antananarivo',
    IndianChagos: 'Indian/Chagos',
    IndianChristmas: 'Indian/Christmas',
    IndianCocos: 'Indian/Cocos',
    IndianComoro: 'Indian/Comoro',
    IndianKerguelen: 'Indian/Kerguelen',
    IndianMahe: 'Indian/Mahe',
    IndianMaldives: 'Indian/Maldives',
    IndianMauritius: 'Indian/Mauritius',
    IndianMayotte: 'Indian/Mayotte',
    IndianReunion: 'Indian/Reunion',
    MexicoBajaNorte: 'Mexico/BajaNorte',
    MexicoBajaSur: 'Mexico/BajaSur',
    MexicoGeneral: 'Mexico/General',
    PacificApia: 'Pacific/Apia',
    PacificAuckland: 'Pacific/Auckland',
    PacificChatham: 'Pacific/Chatham',
    PacificChuuk: 'Pacific/Chuuk',
    PacificEaster: 'Pacific/Easter',
    PacificEfate: 'Pacific/Efate',
    PacificEnderbury: 'Pacific/Enderbury',
    PacificFakaofo: 'Pacific/Fakaofo',
    PacificFiji: 'Pacific/Fiji',
    PacificFunafuti: 'Pacific/Funafuti',
    PacificGalapagos: 'Pacific/Galapagos',
    PacificGambier: 'Pacific/Gambier',
    PacificGuadalcanal: 'Pacific/Guadalcanal',
    PacificGuam: 'Pacific/Guam',
    PacificHonolulu: 'Pacific/Honolulu',
    PacificJohnston: 'Pacific/Johnston',
    PacificKiritimati: 'Pacific/Kiritimati',
    PacificKosrae: 'Pacific/Kosrae',
    PacificKwajalein: 'Pacific/Kwajalein',
    PacificMajuro: 'Pacific/Majuro',
    PacificMarquesas: 'Pacific/Marquesas',
    PacificMidway: 'Pacific/Midway',
    PacificNauru: 'Pacific/Nauru',
    PacificNiue: 'Pacific/Niue',
    PacificNorfolk: 'Pacific/Norfolk',
    PacificNoumea: 'Pacific/Noumea',
    PacificPagoPago: 'Pacific/Pago_Pago',
    PacificPalau: 'Pacific/Palau',
    PacificPitcairn: 'Pacific/Pitcairn',
    PacificPohnpei: 'Pacific/Pohnpei',
    PacificPonape: 'Pacific/Ponape',
    PacificPortMoresby: 'Pacific/Port_Moresby',
    PacificRarotonga: 'Pacific/Rarotonga',
    PacificSaipan: 'Pacific/Saipan',
    PacificSamoa: 'Pacific/Samoa',
    PacificTahiti: 'Pacific/Tahiti',
    PacificTarawa: 'Pacific/Tarawa',
    PacificTongatapu: 'Pacific/Tongatapu',
    PacificTruk: 'Pacific/Truk',
    PacificWake: 'Pacific/Wake',
    PacificWallis: 'Pacific/Wallis',
    PacificYap: 'Pacific/Yap'
} as const;

export type ReportRunRequestParametersTimeZoneEnum = typeof ReportRunRequestParametersTimeZoneEnum[keyof typeof ReportRunRequestParametersTimeZoneEnum];

/**
 * 
 * @export
 * @interface ReportRunRetrieveParams
 */
export interface ReportRunRetrieveParams {
    /**
     * Whether to included expired Report Runs or not
     * @type {boolean}
     * @memberof ReportRunRetrieveParams
     */
    'include_expired'?: boolean;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof Subscription
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof Subscription
     */
    'created_at': string;
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. This `metadata` will be copied to the `payment_intent.metadata` field when a payment is attempted.
     * @type {{ [key: string]: string; }}
     * @memberof Subscription
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof Subscription
     */
    'id': string;
    /**
     * The id of the associated account.
     * @type {string}
     * @memberof Subscription
     */
    'account_id': string;
    /**
     * Determines the date of the first payment and the day of week/month/year for subsequent payments. If a month doesn\'t have the anchor day, the subscription will be billed on the last day of the month. For example, a monthly subscription starting on January 31 bills on Feb 28/29, then March 31, April 30, etc.
     * @type {string}
     * @memberof Subscription
     */
    'billing_cycle_anchor': string;
    /**
     * A date in the future at which the subscription will automatically get canceled.
     * @type {string}
     * @memberof Subscription
     */
    'cancel_at'?: string;
    /**
     * If the subscription has been canceled, the date of that cancellation.
     * @type {string}
     * @memberof Subscription
     */
    'canceled_at'?: string;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase.
     * @type {string}
     * @memberof Subscription
     */
    'currency': SubscriptionCurrencyEnum;
    /**
     * The id of the customer who owns the subscription.
     * @type {string}
     * @memberof Subscription
     */
    'customer_id': string;
    /**
     * The number of intervals (specified in the `interval_unit` attribute) between subscription billings. For example, `interval_unit=month` and `interval_count=3` bills every 3 months.
     * @type {number}
     * @memberof Subscription
     */
    'interval_count': number;
    /**
     * The frequency at which a subscription is billed. One of `week`, `month` or `year`.
     * @type {string}
     * @memberof Subscription
     */
    'interval_unit': SubscriptionIntervalUnitEnum;
    /**
     * The date at which payment will next be attempted. The value will be `null` when no more payments are to be attempted. Examples: `canceled` and `paused` statuses or `cancel_at` is prior to what would be the next payment date. When a payment fails and the status changes to `past_due` this value can be manually updated to determine the next attempt.
     * @type {string}
     * @memberof Subscription
     */
    'next_payment_at'?: string;
    /**
     * A date in the future at which the subscription will automatically get paused.
     * @type {string}
     * @memberof Subscription
     */
    'pause_at'?: string;
    /**
     * If the subscription has been paused, the date of the most recent pausing.
     * @type {string}
     * @memberof Subscription
     */
    'paused_at'?: string;
    /**
     * The id of the PaymentMethod used for this subscription. It must belong to the customer associated with the subscription.
     * @type {string}
     * @memberof Subscription
     */
    'payment_method_id': string;
    /**
     * The amount of the fee (if any) that will be requested to be applied to the payment and transferred to the `partner` account. The amount of the fee collected will be capped a the total payment amount.
     * @type {number}
     * @memberof Subscription
     */
    'platform_fee_amount'?: number;
    /**
     * Amount intended to be collected by this subscription. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency).
     * @type {number}
     * @memberof Subscription
     */
    'price': number;
    /**
     * If the subscription has been paused, the date in the future at which the subscription will automatically return to active.
     * @type {string}
     * @memberof Subscription
     */
    'resume_at'?: string;
    /**
     * Status of this subscription, one of `active`, `canceled`, `past_due`, `paused`, or `pending`.
     * @type {string}
     * @memberof Subscription
     */
    'status': SubscriptionStatusEnum;
}

export const SubscriptionCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type SubscriptionCurrencyEnum = typeof SubscriptionCurrencyEnum[keyof typeof SubscriptionCurrencyEnum];
export const SubscriptionIntervalUnitEnum = {
    Week: 'week',
    Month: 'month',
    Year: 'year'
} as const;

export type SubscriptionIntervalUnitEnum = typeof SubscriptionIntervalUnitEnum[keyof typeof SubscriptionIntervalUnitEnum];
export const SubscriptionStatusEnum = {
    Active: 'active',
    Canceled: 'canceled',
    PastDue: 'past_due',
    Paused: 'paused',
    Pending: 'pending'
} as const;

export type SubscriptionStatusEnum = typeof SubscriptionStatusEnum[keyof typeof SubscriptionStatusEnum];

/**
 * 
 * @export
 * @interface SubscriptionCreateParams
 */
export interface SubscriptionCreateParams {
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value (i.e. `\'\'` or `null`) to them. All keys can be unset by posting an empty value (i.e. `{}` or `null`) to `metadata`.
     * @type {{ [key: string]: string; }}
     * @memberof SubscriptionCreateParams
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Determines the date of the first payment and the day of week/month/year for subsequent payments. If a month doesn\'t have the anchor day, the subscription will be billed on the last day of the month. For example, a monthly subscription starting on January 31 bills on Feb 28/29, then March 31, April 30, etc. Format must be ISO8601 (e.g. \'2000-01-25\'; format \'YYYY-MM-DD\').
     * @type {string}
     * @memberof SubscriptionCreateParams
     */
    'billing_cycle_anchor': string;
    /**
     * A date in the future at which the subscription will automatically get canceled.
     * @type {string}
     * @memberof SubscriptionCreateParams
     */
    'cancel_at'?: string;
    /**
     * Three-letter ISO currency code, in lowercase.
     * @type {string}
     * @memberof SubscriptionCreateParams
     */
    'currency': SubscriptionCreateParamsCurrencyEnum;
    /**
     * The id of the customer who owns the subscription.
     * @type {string}
     * @memberof SubscriptionCreateParams
     */
    'customer_id': string;
    /**
     * The id of the PaymentMethod used for this subscription. It must belong to the customer associated with the subscription.
     * @type {string}
     * @memberof SubscriptionCreateParams
     */
    'payment_method_id': string;
    /**
     * The number of intervals (specified in the `interval_unit` attribute) between subscription billings. For example, `interval_unit=month` and `interval_count=3` bills every 3 months.
     * @type {number}
     * @memberof SubscriptionCreateParams
     */
    'interval_count'?: number;
    /**
     * The frequency at which a subscription is billed. One of `week`, `month` or `year`.
     * @type {string}
     * @memberof SubscriptionCreateParams
     */
    'interval_unit': SubscriptionCreateParamsIntervalUnitEnum;
    /**
     * The amount of the fee (if any) that will be requested to be applied to the payment and transferred to the `partner` account. The amount of the fee collected will be capped a the total payment amount.
     * @type {number}
     * @memberof SubscriptionCreateParams
     */
    'platform_fee_amount'?: number;
    /**
     * Amount intended to be collected by this subscription. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency).
     * @type {number}
     * @memberof SubscriptionCreateParams
     */
    'price': number;
}

export const SubscriptionCreateParamsCurrencyEnum = {
    Aud: 'aud',
    Cad: 'cad',
    Dkk: 'dkk',
    Eur: 'eur',
    Hkd: 'hkd',
    Jpy: 'jpy',
    Nzd: 'nzd',
    Nok: 'nok',
    Gbp: 'gbp',
    Zar: 'zar',
    Sek: 'sek',
    Chf: 'chf',
    Usd: 'usd'
} as const;

export type SubscriptionCreateParamsCurrencyEnum = typeof SubscriptionCreateParamsCurrencyEnum[keyof typeof SubscriptionCreateParamsCurrencyEnum];
export const SubscriptionCreateParamsIntervalUnitEnum = {
    Week: 'week',
    Month: 'month',
    Year: 'year'
} as const;

export type SubscriptionCreateParamsIntervalUnitEnum = typeof SubscriptionCreateParamsIntervalUnitEnum[keyof typeof SubscriptionCreateParamsIntervalUnitEnum];

/**
 * 
 * @export
 * @interface SubscriptionPauseParams
 */
export interface SubscriptionPauseParams {
    /**
     * The date in the future at which the subscription will automatically return to active.
     * @type {string}
     * @memberof SubscriptionPauseParams
     */
    'resume_at'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionRetryParams
 */
export interface SubscriptionRetryParams {
    /**
     * The date in the future at which the subscription will attempt to retry payment. The default is today.
     * @type {string}
     * @memberof SubscriptionRetryParams
     */
    'next_payment_at'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionUpdateParams
 */
export interface SubscriptionUpdateParams {
    /**
     * Set of [key-value pairs](#section/Metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value (i.e. `\'\'` or `null`) to them. All keys can be unset by posting an empty value (i.e. `{}` or `null`) to `metadata`.
     * @type {{ [key: string]: string; }}
     * @memberof SubscriptionUpdateParams
     */
    'metadata'?: { [key: string]: string; };
    /**
     * The date in the future at which the subscription will automatically be paused.
     * @type {string}
     * @memberof SubscriptionUpdateParams
     */
    'pause_at'?: string;
    /**
     * The date in the future at which the subscription will automatically return to active.
     * @type {string}
     * @memberof SubscriptionUpdateParams
     */
    'resume_at'?: string;
    /**
     * A date in the future at which the subscription will automatically get canceled.
     * @type {string}
     * @memberof SubscriptionUpdateParams
     */
    'cancel_at'?: string;
    /**
     * The id of the PaymentMethod used for this subscription. It must belong to the customer associated with the subscription.
     * @type {string}
     * @memberof SubscriptionUpdateParams
     */
    'payment_method_id'?: string;
    /**
     * The amount of the fee (if any) that will be requested to be applied to the payment and transferred to the `partner` account. The amount of the fee collected will be capped a the total payment amount.
     * @type {number}
     * @memberof SubscriptionUpdateParams
     */
    'platform_fee_amount'?: number;
    /**
     * Amount intended to be collected by this subscription. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency).
     * @type {number}
     * @memberof SubscriptionUpdateParams
     */
    'price'?: number;
}
/**
 * 
 * @export
 * @interface TerminalReader
 */
export interface TerminalReader {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof TerminalReader
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof TerminalReader
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof TerminalReader
     */
    'id': string;
    /**
     * The Account that owns this terminal reader.
     * @type {string}
     * @memberof TerminalReader
     */
    'account_id': string;
    /**
     * The type of the terminal reader. Currently only Handpoint powered terminal readers are supported. https://www.handpoint.com/docs/device/Basics
     * @type {string}
     * @memberof TerminalReader
     */
    'type': TerminalReaderTypeEnum;
    /**
     * The serial number of the terminal reader.
     * @type {string}
     * @memberof TerminalReader
     */
    'serial_number': string;
    /**
     * The merchant provided description of the terminal reader
     * @type {string}
     * @memberof TerminalReader
     */
    'description'?: string;
}

export const TerminalReaderTypeEnum = {
    A920: 'pax_a920',
    A920Pro: 'pax_a920_pro',
    A60: 'pax_a60',
    A77: 'pax_a77',
    A80: 'pax_a80'
} as const;

export type TerminalReaderTypeEnum = typeof TerminalReaderTypeEnum[keyof typeof TerminalReaderTypeEnum];

/**
 * 
 * @export
 * @interface TermsAndConditionsDetail
 */
export interface TermsAndConditionsDetail {
    /**
     * 
     * @type {string}
     * @memberof TermsAndConditionsDetail
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TermsAndConditionsDetail
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TermsAndConditionsDetail
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof User
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof User
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * The full name of the user.
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * The user email.
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * The ID of the Account associated with this user.
     * @type {string}
     * @memberof User
     */
    'account_id': string;
    /**
     * The user\'s role, primarily used in the Tilled Dashboard. The roles have varied restrictions on the actions they can take.
     * @type {string}
     * @memberof User
     */
    'role': UserRoleEnum;
    /**
     * Time at which the user last successfully logged in via the API.
     * @type {string}
     * @memberof User
     */
    'last_login_at'?: string;
    /**
     * Time at which the user\'s token was last used to authenticate a request to the API.
     * @type {string}
     * @memberof User
     */
    'last_request_at'?: string;
    /**
     * Six digit verification code of the user.
     * @type {string}
     * @memberof User
     */
    'verification_code'?: string;
}

export const UserRoleEnum = {
    Owner: 'owner',
    Admin: 'admin',
    Developer: 'developer',
    Analyst: 'analyst',
    ViewOnly: 'view_only',
    MerchantOwner: 'merchant_owner',
    MerchantAdmin: 'merchant_admin'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface UserCreateParams
 */
export interface UserCreateParams {
    /**
     * Password. Requires 1 alphabetic and 1 numeric character and a minimum length of 7.
     * @type {string}
     * @memberof UserCreateParams
     */
    'password': string;
    /**
     * The user\'s role, primarily used in the Tilled Dashboard. The roles have varied restrictions on the actions they can take.  `admin` Best for business owners and company administrators.  `developer` Best for developers or people primarily using the Tilled API.  `analyst` Best for people who need full access to Tilled data, but don\'t need to update business settings.  `view_only` Best for people who need to view Tilled data, but don\'t need to make any updates.
     * @type {string}
     * @memberof UserCreateParams
     */
    'role': UserCreateParamsRoleEnum;
    /**
     * Full name
     * @type {string}
     * @memberof UserCreateParams
     */
    'name': string;
    /**
     * Email address
     * @type {string}
     * @memberof UserCreateParams
     */
    'email': string;
}

export const UserCreateParamsRoleEnum = {
    Admin: 'admin',
    Developer: 'developer',
    Analyst: 'analyst',
    ViewOnly: 'view_only',
    MerchantOwner: 'merchant_owner',
    MerchantAdmin: 'merchant_admin'
} as const;

export type UserCreateParamsRoleEnum = typeof UserCreateParamsRoleEnum[keyof typeof UserCreateParamsRoleEnum];

/**
 * 
 * @export
 * @interface UserInvitation
 */
export interface UserInvitation {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof UserInvitation
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof UserInvitation
     */
    'created_at': string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof UserInvitation
     */
    'id': string;
    /**
     * The pending user\'s email.
     * @type {string}
     * @memberof UserInvitation
     */
    'email': string;
    /**
     * The ID of the Account associated with this pending user.
     * @type {string}
     * @memberof UserInvitation
     */
    'account_id': string;
    /**
     * The pending user\'s role, primarily used in the Tilled Dashboard. The roles have varied restrictions on the actions they can take.
     * @type {string}
     * @memberof UserInvitation
     */
    'role': UserInvitationRoleEnum;
    /**
     * Time at which the invitation was last sent.
     * @type {string}
     * @memberof UserInvitation
     */
    'sent_at'?: string;
    /**
     * The ID of the user who sent the invitation.
     * @type {string}
     * @memberof UserInvitation
     */
    'inviter_user_id'?: string;
}

export const UserInvitationRoleEnum = {
    Owner: 'owner',
    Admin: 'admin',
    Developer: 'developer',
    Analyst: 'analyst',
    ViewOnly: 'view_only',
    MerchantOwner: 'merchant_owner',
    MerchantAdmin: 'merchant_admin'
} as const;

export type UserInvitationRoleEnum = typeof UserInvitationRoleEnum[keyof typeof UserInvitationRoleEnum];

/**
 * 
 * @export
 * @interface UserInvitationCheck
 */
export interface UserInvitationCheck {
    /**
     * The ID of the invitation.
     * @type {string}
     * @memberof UserInvitationCheck
     */
    'id': string;
    /**
     * The pending user\'s email.
     * @type {string}
     * @memberof UserInvitationCheck
     */
    'email': string;
    /**
     * The email address of the user who sent the invitation.
     * @type {string}
     * @memberof UserInvitationCheck
     */
    'inviter_email'?: string;
    /**
     * The name of the parent (ISV) account
     * @type {string}
     * @memberof UserInvitationCheck
     */
    'partner_account_name'?: string;
}
/**
 * 
 * @export
 * @interface UserInvitationCreateParams
 */
export interface UserInvitationCreateParams {
    /**
     * The user\'s role, primarily used in the Tilled Dashboard. The roles have varied restrictions on the actions they can take.  `admin` Best for business owners and company administrators.  `developer` Best for developers or people primarily using the Tilled API.  `analyst` Best for people who need full access to Tilled data, but don\'t need to update business settings.  `view_only` Best for people who need to view Tilled data, but don\'t need to make any updates.
     * @type {string}
     * @memberof UserInvitationCreateParams
     */
    'role': UserInvitationCreateParamsRoleEnum;
    /**
     * Email address
     * @type {string}
     * @memberof UserInvitationCreateParams
     */
    'email': string;
}

export const UserInvitationCreateParamsRoleEnum = {
    Admin: 'admin',
    Developer: 'developer',
    Analyst: 'analyst',
    ViewOnly: 'view_only',
    MerchantOwner: 'merchant_owner',
    MerchantAdmin: 'merchant_admin'
} as const;

export type UserInvitationCreateParamsRoleEnum = typeof UserInvitationCreateParamsRoleEnum[keyof typeof UserInvitationCreateParamsRoleEnum];

/**
 * 
 * @export
 * @interface UserResetPasswordParams
 */
export interface UserResetPasswordParams {
    /**
     * Password. Requires 1 alphabetic and 1 numeric character and a minimum length of 7.
     * @type {string}
     * @memberof UserResetPasswordParams
     */
    'password': string;
    /**
     * Password reset token
     * @type {string}
     * @memberof UserResetPasswordParams
     */
    'password_reset_token': string;
    /**
     * Email address
     * @type {string}
     * @memberof UserResetPasswordParams
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface UserUpdateParams
 */
export interface UserUpdateParams {
    /**
     * The user\'s role, primarily used in the Tilled Dashboard. The roles have varied restrictions on the actions they can take.  `admin` Best for business owners and company administrators.  `developer` Best for developers or people primarily using the Tilled API.  `analyst` Best for people who need full access to Tilled data, but don\'t need to update business settings.  `view_only` Best for people who need to view Tilled data, but don\'t need to make any updates.
     * @type {string}
     * @memberof UserUpdateParams
     */
    'role'?: UserUpdateParamsRoleEnum;
    /**
     * Full name
     * @type {string}
     * @memberof UserUpdateParams
     */
    'name'?: string;
    /**
     * Email address
     * @type {string}
     * @memberof UserUpdateParams
     */
    'email'?: string;
}

export const UserUpdateParamsRoleEnum = {
    Admin: 'admin',
    Developer: 'developer',
    Analyst: 'analyst',
    ViewOnly: 'view_only',
    MerchantOwner: 'merchant_owner',
    MerchantAdmin: 'merchant_admin'
} as const;

export type UserUpdateParamsRoleEnum = typeof UserUpdateParamsRoleEnum[keyof typeof UserUpdateParamsRoleEnum];

/**
 * 
 * @export
 * @interface WebhookEndpoint
 */
export interface WebhookEndpoint {
    /**
     * Time at which the object was last updated.
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'updated_at': string;
    /**
     * Time at which the object was created.
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'created_at': string;
    /**
     * The list of events to enable for this endpoint. You may specify `[\'*\']` to enable all events, except those that require explicit selection.
     * @type {Array<string>}
     * @memberof WebhookEndpoint
     */
    'enabled_events': Array<WebhookEndpointEnabledEventsEnum>;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'id': string;
    /**
     * The id of the associated account.
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'account_id': string;
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'url': string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'description'?: string;
    /**
     * The endpoint\'s secret, used to generate webhook signatures. Only returned at creation.
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'secret'?: string;
}

export const WebhookEndpointEnabledEventsEnum = {
    Star: '*',
    AccountUpdated: 'account.updated',
    ChargeCaptured: 'charge.captured',
    ChargeExpired: 'charge.expired',
    ChargeFailed: 'charge.failed',
    ChargeSucceeded: 'charge.succeeded',
    ChargePending: 'charge.pending',
    ChargeRefunded: 'charge.refunded',
    ChargeRefundUpdated: 'charge.refund.updated',
    ChargeUpdated: 'charge.updated',
    CustomerCreated: 'customer.created',
    CustomerDeleted: 'customer.deleted',
    CustomerUpdated: 'customer.updated',
    DisputeCreated: 'dispute.created',
    DisputeUpdated: 'dispute.updated',
    PaymentIntentCanceled: 'payment_intent.canceled',
    PaymentIntentCreated: 'payment_intent.created',
    PaymentIntentPaymentFailed: 'payment_intent.payment_failed',
    PaymentIntentProcessing: 'payment_intent.processing',
    PaymentIntentRequiresAction: 'payment_intent.requires_action',
    PaymentIntentSucceeded: 'payment_intent.succeeded',
    PaymentIntentAmountCapturableUpdated: 'payment_intent.amount_capturable_updated',
    PaymentMethodAttached: 'payment_method.attached',
    PaymentMethodDetached: 'payment_method.detached',
    PayoutCreated: 'payout.created',
    PayoutFailed: 'payout.failed',
    PayoutPaid: 'payout.paid',
    PayoutUpdated: 'payout.updated',
    PlatformFeeCreated: 'platform_fee.created',
    PlatformFeeRefunded: 'platform_fee.refunded',
    SubscriptionCreated: 'subscription.created',
    SubscriptionCanceled: 'subscription.canceled',
    SubscriptionUpdated: 'subscription.updated',
    ReportRunSucceeded: 'report_run.succeeded',
    ReportRunFailed: 'report_run.failed'
} as const;

export type WebhookEndpointEnabledEventsEnum = typeof WebhookEndpointEnabledEventsEnum[keyof typeof WebhookEndpointEnabledEventsEnum];

/**
 * 
 * @export
 * @interface WebhookEndpointCreateParams
 */
export interface WebhookEndpointCreateParams {
    /**
     * The list of events to enable for this endpoint. You may specify `[\'*\']` to enable all events, except those that require explicit selection.
     * @type {Array<string>}
     * @memberof WebhookEndpointCreateParams
     */
    'enabled_events': WebhookEndpointCreateParamsEnabledEventsEnum;
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof WebhookEndpointCreateParams
     */
    'url': string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof WebhookEndpointCreateParams
     */
    'description'?: string;
}

export const WebhookEndpointCreateParamsEnabledEventsEnum = {
    Star: '*',
    AccountUpdated: 'account.updated',
    ChargeCaptured: 'charge.captured',
    ChargeExpired: 'charge.expired',
    ChargeFailed: 'charge.failed',
    ChargeSucceeded: 'charge.succeeded',
    ChargePending: 'charge.pending',
    ChargeRefunded: 'charge.refunded',
    ChargeRefundUpdated: 'charge.refund.updated',
    ChargeUpdated: 'charge.updated',
    CustomerCreated: 'customer.created',
    CustomerDeleted: 'customer.deleted',
    CustomerUpdated: 'customer.updated',
    DisputeCreated: 'dispute.created',
    DisputeUpdated: 'dispute.updated',
    PaymentIntentCanceled: 'payment_intent.canceled',
    PaymentIntentCreated: 'payment_intent.created',
    PaymentIntentPaymentFailed: 'payment_intent.payment_failed',
    PaymentIntentProcessing: 'payment_intent.processing',
    PaymentIntentRequiresAction: 'payment_intent.requires_action',
    PaymentIntentSucceeded: 'payment_intent.succeeded',
    PaymentIntentAmountCapturableUpdated: 'payment_intent.amount_capturable_updated',
    PaymentMethodAttached: 'payment_method.attached',
    PaymentMethodDetached: 'payment_method.detached',
    PayoutCreated: 'payout.created',
    PayoutFailed: 'payout.failed',
    PayoutPaid: 'payout.paid',
    PayoutUpdated: 'payout.updated',
    PlatformFeeCreated: 'platform_fee.created',
    PlatformFeeRefunded: 'platform_fee.refunded',
    SubscriptionCreated: 'subscription.created',
    SubscriptionCanceled: 'subscription.canceled',
    SubscriptionUpdated: 'subscription.updated',
    ReportRunSucceeded: 'report_run.succeeded',
    ReportRunFailed: 'report_run.failed'
} as const;

export type WebhookEndpointCreateParamsEnabledEventsEnum = typeof WebhookEndpointCreateParamsEnabledEventsEnum[keyof typeof WebhookEndpointCreateParamsEnabledEventsEnum];

/**
 * 
 * @export
 * @interface WebhookEndpointUpdateParams
 */
export interface WebhookEndpointUpdateParams {
    /**
     * The list of events to enable for this endpoint. You may specify `[\'*\']` to enable all events, except those that require explicit selection.
     * @type {Array<string>}
     * @memberof WebhookEndpointUpdateParams
     */
    'enabled_events'?: WebhookEndpointUpdateParamsEnabledEventsEnum;
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof WebhookEndpointUpdateParams
     */
    'url'?: string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof WebhookEndpointUpdateParams
     */
    'description'?: string;
}

export const WebhookEndpointUpdateParamsEnabledEventsEnum = {
    Star: '*',
    AccountUpdated: 'account.updated',
    ChargeCaptured: 'charge.captured',
    ChargeExpired: 'charge.expired',
    ChargeFailed: 'charge.failed',
    ChargeSucceeded: 'charge.succeeded',
    ChargePending: 'charge.pending',
    ChargeRefunded: 'charge.refunded',
    ChargeRefundUpdated: 'charge.refund.updated',
    ChargeUpdated: 'charge.updated',
    CustomerCreated: 'customer.created',
    CustomerDeleted: 'customer.deleted',
    CustomerUpdated: 'customer.updated',
    DisputeCreated: 'dispute.created',
    DisputeUpdated: 'dispute.updated',
    PaymentIntentCanceled: 'payment_intent.canceled',
    PaymentIntentCreated: 'payment_intent.created',
    PaymentIntentPaymentFailed: 'payment_intent.payment_failed',
    PaymentIntentProcessing: 'payment_intent.processing',
    PaymentIntentRequiresAction: 'payment_intent.requires_action',
    PaymentIntentSucceeded: 'payment_intent.succeeded',
    PaymentIntentAmountCapturableUpdated: 'payment_intent.amount_capturable_updated',
    PaymentMethodAttached: 'payment_method.attached',
    PaymentMethodDetached: 'payment_method.detached',
    PayoutCreated: 'payout.created',
    PayoutFailed: 'payout.failed',
    PayoutPaid: 'payout.paid',
    PayoutUpdated: 'payout.updated',
    PlatformFeeCreated: 'platform_fee.created',
    PlatformFeeRefunded: 'platform_fee.refunded',
    SubscriptionCreated: 'subscription.created',
    SubscriptionCanceled: 'subscription.canceled',
    SubscriptionUpdated: 'subscription.updated',
    ReportRunSucceeded: 'report_run.succeeded',
    ReportRunFailed: 'report_run.failed'
} as const;

export type WebhookEndpointUpdateParamsEnabledEventsEnum = typeof WebhookEndpointUpdateParamsEnabledEventsEnum[keyof typeof WebhookEndpointUpdateParamsEnabledEventsEnum];


/**
 * APIKeysApi - axios parameter creator
 * @export
 */
export const APIKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new API key. For security reasons, keys of type `secret` will only be returned fully *here*, when the key is first created. Your application should store the key in a secure location to authenticate to the API.
         * @summary Create an API key
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {ApiKeyCreateParams} apiKeyCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPIKey: async (tilledAccount: string, apiKeyCreateParams: ApiKeyCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createAPIKey', 'tilledAccount', tilledAccount)
            // verify required parameter 'apiKeyCreateParams' is not null or undefined
            assertParamExists('createAPIKey', 'apiKeyCreateParams', apiKeyCreateParams)
            const localVarPath = `/v1/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes an API key. It cannot be undone.
         * @summary Delete an API key
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPIKey: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('deleteAPIKey', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAPIKey', 'id', id)
            const localVarPath = `/v1/api-keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all API keys
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAPIKeys: async (tilledAccount: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listAPIKeys', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the API key. Any parameters not provided will be left unchanged.
         * @summary Update an API key
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {ApiKeyUpdateParams} apiKeyUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPIKey: async (tilledAccount: string, id: string, apiKeyUpdateParams: ApiKeyUpdateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('updateAPIKey', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAPIKey', 'id', id)
            // verify required parameter 'apiKeyUpdateParams' is not null or undefined
            assertParamExists('updateAPIKey', 'apiKeyUpdateParams', apiKeyUpdateParams)
            const localVarPath = `/v1/api-keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeysApi - functional programming interface
 * @export
 */
export const APIKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new API key. For security reasons, keys of type `secret` will only be returned fully *here*, when the key is first created. Your application should store the key in a secure location to authenticate to the API.
         * @summary Create an API key
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {ApiKeyCreateParams} apiKeyCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAPIKey(tilledAccount: string, apiKeyCreateParams: ApiKeyCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAPIKey(tilledAccount, apiKeyCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes an API key. It cannot be undone.
         * @summary Delete an API key
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAPIKey(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAPIKey(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all API keys
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAPIKeys(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAPIKeys200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAPIKeys(tilledAccount, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the API key. Any parameters not provided will be left unchanged.
         * @summary Update an API key
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {ApiKeyUpdateParams} apiKeyUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAPIKey(tilledAccount: string, id: string, apiKeyUpdateParams: ApiKeyUpdateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAPIKey(tilledAccount, id, apiKeyUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIKeysApi - factory interface
 * @export
 */
export const APIKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeysApiFp(configuration)
    return {
        /**
         * Creates a new API key. For security reasons, keys of type `secret` will only be returned fully *here*, when the key is first created. Your application should store the key in a secure location to authenticate to the API.
         * @summary Create an API key
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {ApiKeyCreateParams} apiKeyCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAPIKey(tilledAccount: string, apiKeyCreateParams: ApiKeyCreateParams, options?: any): AxiosPromise<ApiKey> {
            return localVarFp.createAPIKey(tilledAccount, apiKeyCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes an API key. It cannot be undone.
         * @summary Delete an API key
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAPIKey(tilledAccount: string, id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteAPIKey(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all API keys
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAPIKeys(tilledAccount: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListAPIKeys200Response> {
            return localVarFp.listAPIKeys(tilledAccount, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the API key. Any parameters not provided will be left unchanged.
         * @summary Update an API key
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {ApiKeyUpdateParams} apiKeyUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAPIKey(tilledAccount: string, id: string, apiKeyUpdateParams: ApiKeyUpdateParams, options?: any): AxiosPromise<ApiKey> {
            return localVarFp.updateAPIKey(tilledAccount, id, apiKeyUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeysApi - object-oriented interface
 * @export
 * @class APIKeysApi
 * @extends {BaseAPI}
 */
export class APIKeysApi extends BaseAPI {
    /**
     * Creates a new API key. For security reasons, keys of type `secret` will only be returned fully *here*, when the key is first created. Your application should store the key in a secure location to authenticate to the API.
     * @summary Create an API key
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {ApiKeyCreateParams} apiKeyCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public createAPIKey(tilledAccount: string, apiKeyCreateParams: ApiKeyCreateParams, options?: AxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).createAPIKey(tilledAccount, apiKeyCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes an API key. It cannot be undone.
     * @summary Delete an API key
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public deleteAPIKey(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).deleteAPIKey(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all API keys
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public listAPIKeys(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).listAPIKeys(tilledAccount, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the API key. Any parameters not provided will be left unchanged.
     * @summary Update an API key
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {ApiKeyUpdateParams} apiKeyUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public updateAPIKey(tilledAccount: string, id: string, apiKeyUpdateParams: ApiKeyUpdateParams, options?: AxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).updateAPIKey(tilledAccount, id, apiKeyUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a merchant account associated to your partner account.
         * @summary Create an account
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {AccountCreateParams} accountCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectedAccount: async (tilledAccount: string, accountCreateParams: AccountCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createConnectedAccount', 'tilledAccount', tilledAccount)
            // verify required parameter 'accountCreateParams' is not null or undefined
            assertParamExists('createConnectedAccount', 'accountCreateParams', accountCreateParams)
            const localVarPath = `/v1/accounts/connected`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an account.
         * @summary Retrieve account
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (tilledAccount: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getAccount', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of accounts connected to your account. For merchant accounts, the list is empty.
         * @summary List all connected accounts
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {string} [q] The partial search of text fields. Supports searching by &#x60;account.name&#x60;, &#x60;account.business_profile.legal_name&#x60;, &#x60;account.id&#x60;, &#x60;account.email&#x60;, &#x60;user.name&#x60;, &#x60;user.email&#x60;
         * @param {string} [sort] The sort parameters, value:direction. Possible values: &#x60;name&#x60;, &#x60;created_at&#x60;. Possible directions:  &#x60;asc&#x60;, &#x60;desc&#x60;  For example &#x60;name:asc&#x60;.  Default: &#x60;created_at:desc&#x60;
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectedAccounts: async (tilledAccount: string, metadata?: { [key: string]: string; }, q?: string, sort?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listConnectedAccounts', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/accounts/connected`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an account by setting the values of the parameters passed. Any parameters not provided are left unchanged.
         * @summary Update an account
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {AccountUpdateParams} accountUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (tilledAccount: string, accountUpdateParams: AccountUpdateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('updateAccount', 'tilledAccount', tilledAccount)
            // verify required parameter 'accountUpdateParams' is not null or undefined
            assertParamExists('updateAccount', 'accountUpdateParams', accountUpdateParams)
            const localVarPath = `/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a merchant account associated to your partner account.
         * @summary Create an account
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {AccountCreateParams} accountCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectedAccount(tilledAccount: string, accountCreateParams: AccountCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnectedAccount(tilledAccount, accountCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an account.
         * @summary Retrieve account
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(tilledAccount: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(tilledAccount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of accounts connected to your account. For merchant accounts, the list is empty.
         * @summary List all connected accounts
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {string} [q] The partial search of text fields. Supports searching by &#x60;account.name&#x60;, &#x60;account.business_profile.legal_name&#x60;, &#x60;account.id&#x60;, &#x60;account.email&#x60;, &#x60;user.name&#x60;, &#x60;user.email&#x60;
         * @param {string} [sort] The sort parameters, value:direction. Possible values: &#x60;name&#x60;, &#x60;created_at&#x60;. Possible directions:  &#x60;asc&#x60;, &#x60;desc&#x60;  For example &#x60;name:asc&#x60;.  Default: &#x60;created_at:desc&#x60;
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectedAccounts(tilledAccount: string, metadata?: { [key: string]: string; }, q?: string, sort?: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListConnectedAccounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectedAccounts(tilledAccount, metadata, q, sort, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates an account by setting the values of the parameters passed. Any parameters not provided are left unchanged.
         * @summary Update an account
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {AccountUpdateParams} accountUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(tilledAccount: string, accountUpdateParams: AccountUpdateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(tilledAccount, accountUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Creates a merchant account associated to your partner account.
         * @summary Create an account
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {AccountCreateParams} accountCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectedAccount(tilledAccount: string, accountCreateParams: AccountCreateParams, options?: any): AxiosPromise<Account> {
            return localVarFp.createConnectedAccount(tilledAccount, accountCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an account.
         * @summary Retrieve account
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(tilledAccount: string, options?: any): AxiosPromise<Account> {
            return localVarFp.getAccount(tilledAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts connected to your account. For merchant accounts, the list is empty.
         * @summary List all connected accounts
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {string} [q] The partial search of text fields. Supports searching by &#x60;account.name&#x60;, &#x60;account.business_profile.legal_name&#x60;, &#x60;account.id&#x60;, &#x60;account.email&#x60;, &#x60;user.name&#x60;, &#x60;user.email&#x60;
         * @param {string} [sort] The sort parameters, value:direction. Possible values: &#x60;name&#x60;, &#x60;created_at&#x60;. Possible directions:  &#x60;asc&#x60;, &#x60;desc&#x60;  For example &#x60;name:asc&#x60;.  Default: &#x60;created_at:desc&#x60;
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectedAccounts(tilledAccount: string, metadata?: { [key: string]: string; }, q?: string, sort?: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListConnectedAccounts200Response> {
            return localVarFp.listConnectedAccounts(tilledAccount, metadata, q, sort, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an account by setting the values of the parameters passed. Any parameters not provided are left unchanged.
         * @summary Update an account
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {AccountUpdateParams} accountUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(tilledAccount: string, accountUpdateParams: AccountUpdateParams, options?: any): AxiosPromise<Account> {
            return localVarFp.updateAccount(tilledAccount, accountUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Creates a merchant account associated to your partner account.
     * @summary Create an account
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {AccountCreateParams} accountCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public createConnectedAccount(tilledAccount: string, accountCreateParams: AccountCreateParams, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).createConnectedAccount(tilledAccount, accountCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an account.
     * @summary Retrieve account
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(tilledAccount: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(tilledAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of accounts connected to your account. For merchant accounts, the list is empty.
     * @summary List all connected accounts
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
     * @param {string} [q] The partial search of text fields. Supports searching by &#x60;account.name&#x60;, &#x60;account.business_profile.legal_name&#x60;, &#x60;account.id&#x60;, &#x60;account.email&#x60;, &#x60;user.name&#x60;, &#x60;user.email&#x60;
     * @param {string} [sort] The sort parameters, value:direction. Possible values: &#x60;name&#x60;, &#x60;created_at&#x60;. Possible directions:  &#x60;asc&#x60;, &#x60;desc&#x60;  For example &#x60;name:asc&#x60;.  Default: &#x60;created_at:desc&#x60;
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listConnectedAccounts(tilledAccount: string, metadata?: { [key: string]: string; }, q?: string, sort?: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listConnectedAccounts(tilledAccount, metadata, q, sort, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an account by setting the values of the parameters passed. Any parameters not provided are left unchanged.
     * @summary Update an account
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {AccountUpdateParams} accountUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(tilledAccount: string, accountUpdateParams: AccountUpdateParams, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(tilledAccount, accountUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplePayDomainsApi - axios parameter creator
 * @export
 */
export const ApplePayDomainsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an Apple Pay Domain for verification
         * @summary Create an Apple Pay Domain
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {ApplePayDomainCreateParams} applePayDomainCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplePayDomain: async (tilledAccount: string, applePayDomainCreateParams: ApplePayDomainCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createApplePayDomain', 'tilledAccount', tilledAccount)
            // verify required parameter 'applePayDomainCreateParams' is not null or undefined
            assertParamExists('createApplePayDomain', 'applePayDomainCreateParams', applePayDomainCreateParams)
            const localVarPath = `/v1/apple-pay-domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applePayDomainCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes an Apple Pay Domain
         * @summary Delete an Apple Pay Domain
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplePayDomain: async (id: string, tilledAccount: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApplePayDomain', 'id', id)
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('deleteApplePayDomain', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/apple-pay-domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your registered Apple Pay Domains
         * @summary List all Apple Pay Domains
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllApplePayDomains: async (tilledAccount: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listAllApplePayDomains', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/apple-pay-domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the apple pay domain with the given ID.
         * @summary Retrieve an Apple Pay Domain
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveApplePayDomain: async (id: string, tilledAccount: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveApplePayDomain', 'id', id)
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('retrieveApplePayDomain', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/apple-pay-domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplePayDomainsApi - functional programming interface
 * @export
 */
export const ApplePayDomainsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplePayDomainsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an Apple Pay Domain for verification
         * @summary Create an Apple Pay Domain
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {ApplePayDomainCreateParams} applePayDomainCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplePayDomain(tilledAccount: string, applePayDomainCreateParams: ApplePayDomainCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplePayDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplePayDomain(tilledAccount, applePayDomainCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes an Apple Pay Domain
         * @summary Delete an Apple Pay Domain
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplePayDomain(id: string, tilledAccount: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplePayDomain(id, tilledAccount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your registered Apple Pay Domains
         * @summary List all Apple Pay Domains
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllApplePayDomains(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllApplePayDomains200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllApplePayDomains(tilledAccount, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the apple pay domain with the given ID.
         * @summary Retrieve an Apple Pay Domain
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveApplePayDomain(id: string, tilledAccount: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplePayDomain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveApplePayDomain(id, tilledAccount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplePayDomainsApi - factory interface
 * @export
 */
export const ApplePayDomainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplePayDomainsApiFp(configuration)
    return {
        /**
         * Creates an Apple Pay Domain for verification
         * @summary Create an Apple Pay Domain
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {ApplePayDomainCreateParams} applePayDomainCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplePayDomain(tilledAccount: string, applePayDomainCreateParams: ApplePayDomainCreateParams, options?: any): AxiosPromise<ApplePayDomain> {
            return localVarFp.createApplePayDomain(tilledAccount, applePayDomainCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes an Apple Pay Domain
         * @summary Delete an Apple Pay Domain
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplePayDomain(id: string, tilledAccount: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteApplePayDomain(id, tilledAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your registered Apple Pay Domains
         * @summary List all Apple Pay Domains
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllApplePayDomains(tilledAccount: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListAllApplePayDomains200Response> {
            return localVarFp.listAllApplePayDomains(tilledAccount, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the apple pay domain with the given ID.
         * @summary Retrieve an Apple Pay Domain
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveApplePayDomain(id: string, tilledAccount: string, options?: any): AxiosPromise<ApplePayDomain> {
            return localVarFp.retrieveApplePayDomain(id, tilledAccount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplePayDomainsApi - object-oriented interface
 * @export
 * @class ApplePayDomainsApi
 * @extends {BaseAPI}
 */
export class ApplePayDomainsApi extends BaseAPI {
    /**
     * Creates an Apple Pay Domain for verification
     * @summary Create an Apple Pay Domain
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {ApplePayDomainCreateParams} applePayDomainCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplePayDomainsApi
     */
    public createApplePayDomain(tilledAccount: string, applePayDomainCreateParams: ApplePayDomainCreateParams, options?: AxiosRequestConfig) {
        return ApplePayDomainsApiFp(this.configuration).createApplePayDomain(tilledAccount, applePayDomainCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes an Apple Pay Domain
     * @summary Delete an Apple Pay Domain
     * @param {string} id 
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplePayDomainsApi
     */
    public deleteApplePayDomain(id: string, tilledAccount: string, options?: AxiosRequestConfig) {
        return ApplePayDomainsApiFp(this.configuration).deleteApplePayDomain(id, tilledAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your registered Apple Pay Domains
     * @summary List all Apple Pay Domains
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplePayDomainsApi
     */
    public listAllApplePayDomains(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return ApplePayDomainsApiFp(this.configuration).listAllApplePayDomains(tilledAccount, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the apple pay domain with the given ID.
     * @summary Retrieve an Apple Pay Domain
     * @param {string} id 
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplePayDomainsApi
     */
    public retrieveApplePayDomain(id: string, tilledAccount: string, options?: AxiosRequestConfig) {
        return ApplePayDomainsApiFp(this.configuration).retrieveApplePayDomain(id, tilledAccount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BalanceTransactionsApi - axios parameter creator
 * @export
 */
export const BalanceTransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the balance transactioni with the given ID.
         * @summary Retrieve a balance transaction
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceTransaction: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getBalanceTransaction', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBalanceTransaction', 'id', id)
            const localVarPath = `/v1/balance-transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a summary of transactions grouped by `time_unit`, `type`, and `currency`.
         * @summary Get balance transactions summary
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {'day' | 'month'} [timeUnit] String indicating the unit of time to aggregate the summary of data.
         * @param {'Africa/Abidjan' | 'Africa/Accra' | 'Africa/Addis_Ababa' | 'Africa/Algiers' | 'Africa/Asmara' | 'Africa/Asmera' | 'Africa/Bamako' | 'Africa/Bangui' | 'Africa/Banjul' | 'Africa/Bissau' | 'Africa/Blantyre' | 'Africa/Brazzaville' | 'Africa/Bujumbura' | 'Africa/Cairo' | 'Africa/Casablanca' | 'Africa/Ceuta' | 'Africa/Conakry' | 'Africa/Dakar' | 'Africa/Dar_es_Salaam' | 'Africa/Djibouti' | 'Africa/Douala' | 'Africa/El_Aaiun' | 'Africa/Freetown' | 'Africa/Gaborone' | 'Africa/Harare' | 'Africa/Johannesburg' | 'Africa/Juba' | 'Africa/Kampala' | 'Africa/Khartoum' | 'Africa/Kigali' | 'Africa/Kinshasa' | 'Africa/Lagos' | 'Africa/Libreville' | 'Africa/Lome' | 'Africa/Luanda' | 'Africa/Lubumbashi' | 'Africa/Lusaka' | 'Africa/Malabo' | 'Africa/Maputo' | 'Africa/Maseru' | 'Africa/Mbabane' | 'Africa/Mogadishu' | 'Africa/Monrovia' | 'Africa/Nairobi' | 'Africa/Ndjamena' | 'Africa/Niamey' | 'Africa/Nouakchott' | 'Africa/Ouagadougou' | 'Africa/Porto-Novo' | 'Africa/Sao_Tome' | 'Africa/Timbuktu' | 'Africa/Tripoli' | 'Africa/Tunis' | 'Africa/Windhoek' | 'America/Adak' | 'America/Anchorage' | 'America/Anguilla' | 'America/Antigua' | 'America/Araguaina' | 'America/Argentina/Buenos_Aires' | 'America/Argentina/Catamarca' | 'America/Argentina/ComodRivadavia' | 'America/Argentina/Cordoba' | 'America/Argentina/Jujuy' | 'America/Argentina/La_Rioja' | 'America/Argentina/Mendoza' | 'America/Argentina/Rio_Gallegos' | 'America/Argentina/Salta' | 'America/Argentina/San_Juan' | 'America/Argentina/San_Luis' | 'America/Argentina/Tucuman' | 'America/Argentina/Ushuaia' | 'America/Aruba' | 'America/Asuncion' | 'America/Atikokan' | 'America/Atka' | 'America/Bahia' | 'America/Bahia_Banderas' | 'America/Barbados' | 'America/Belem' | 'America/Belize' | 'America/Blanc-Sablon' | 'America/Boa_Vista' | 'America/Bogota' | 'America/Boise' | 'America/Buenos_Aires' | 'America/Cambridge_Bay' | 'America/Campo_Grande' | 'America/Cancun' | 'America/Caracas' | 'America/Catamarca' | 'America/Cayenne' | 'America/Cayman' | 'America/Chicago' | 'America/Chihuahua' | 'America/Coral_Harbour' | 'America/Cordoba' | 'America/Costa_Rica' | 'America/Creston' | 'America/Cuiaba' | 'America/Curacao' | 'America/Danmarkshavn' | 'America/Dawson' | 'America/Dawson_Creek' | 'America/Denver' | 'America/Detroit' | 'America/Dominica' | 'America/Edmonton' | 'America/Eirunepe' | 'America/El_Salvador' | 'America/Ensenada' | 'America/Fort_Wayne' | 'America/Fortaleza' | 'America/Glace_Bay' | 'America/Godthab' | 'America/Goose_Bay' | 'America/Grand_Turk' | 'America/Grenada' | 'America/Guadeloupe' | 'America/Guatemala' | 'America/Guayaquil' | 'America/Guyana' | 'America/Halifax' | 'America/Havana' | 'America/Hermosillo' | 'America/Indiana/Indianapolis' | 'America/Indiana/Knox' | 'America/Indiana/Marengo' | 'America/Indiana/Petersburg' | 'America/Indiana/Tell_City' | 'America/Indiana/Vevay' | 'America/Indiana/Vincennes' | 'America/Indiana/Winamac' | 'America/Indianapolis' | 'America/Inuvik' | 'America/Iqaluit' | 'America/Jamaica' | 'America/Jujuy' | 'America/Juneau' | 'America/Kentucky/Louisville' | 'America/Kentucky/Monticello' | 'America/Knox_IN' | 'America/Kralendijk' | 'America/La_Paz' | 'America/Lima' | 'America/Los_Angeles' | 'America/Louisville' | 'America/Lower_Princes' | 'America/Maceio' | 'America/Managua' | 'America/Manaus' | 'America/Marigot' | 'America/Martinique' | 'America/Matamoros' | 'America/Mazatlan' | 'America/Mendoza' | 'America/Menominee' | 'America/Merida' | 'America/Metlakatla' | 'America/Mexico_City' | 'America/Miquelon' | 'America/Moncton' | 'America/Monterrey' | 'America/Montevideo' | 'America/Montreal' | 'America/Montserrat' | 'America/Nassau' | 'America/New_York' | 'America/Nipigon' | 'America/Nome' | 'America/Noronha' | 'America/North_Dakota/Beulah' | 'America/North_Dakota/Center' | 'America/North_Dakota/New_Salem' | 'America/Ojinaga' | 'America/Panama' | 'America/Pangnirtung' | 'America/Paramaribo' | 'America/Phoenix' | 'America/Port-au-Prince' | 'America/Port_of_Spain' | 'America/Porto_Acre' | 'America/Porto_Velho' | 'America/Puerto_Rico' | 'America/Rainy_River' | 'America/Rankin_Inlet' | 'America/Recife' | 'America/Regina' | 'America/Resolute' | 'America/Rio_Branco' | 'America/Rosario' | 'America/Santa_Isabel' | 'America/Santarem' | 'America/Santiago' | 'America/Santo_Domingo' | 'America/Sao_Paulo' | 'America/Scoresbysund' | 'America/Shiprock' | 'America/Sitka' | 'America/St_Barthelemy' | 'America/St_Johns' | 'America/St_Kitts' | 'America/St_Lucia' | 'America/St_Thomas' | 'America/St_Vincent' | 'America/Swift_Current' | 'America/Tegucigalpa' | 'America/Thule' | 'America/Thunder_Bay' | 'America/Tijuana' | 'America/Toronto' | 'America/Tortola' | 'America/Vancouver' | 'America/Virgin' | 'America/Whitehorse' | 'America/Winnipeg' | 'America/Yakutat' | 'America/Yellowknife' | 'Antarctica/Casey' | 'Antarctica/Davis' | 'Antarctica/DumontDUrville' | 'Antarctica/Macquarie' | 'Antarctica/Mawson' | 'Antarctica/McMurdo' | 'Antarctica/Palmer' | 'Antarctica/Rothera' | 'Antarctica/South_Pole' | 'Antarctica/Syowa' | 'Antarctica/Troll' | 'Antarctica/Vostok' | 'Arctic/Longyearbyen' | 'Asia/Aden' | 'Asia/Almaty' | 'Asia/Amman' | 'Asia/Anadyr' | 'Asia/Aqtau' | 'Asia/Aqtobe' | 'Asia/Ashgabat' | 'Asia/Ashkhabad' | 'Asia/Baghdad' | 'Asia/Bahrain' | 'Asia/Baku' | 'Asia/Bangkok' | 'Asia/Beirut' | 'Asia/Bishkek' | 'Asia/Brunei' | 'Asia/Calcutta' | 'Asia/Chita' | 'Asia/Choibalsan' | 'Asia/Chongqing' | 'Asia/Chungking' | 'Asia/Colombo' | 'Asia/Dacca' | 'Asia/Damascus' | 'Asia/Dhaka' | 'Asia/Dili' | 'Asia/Dubai' | 'Asia/Dushanbe' | 'Asia/Gaza' | 'Asia/Harbin' | 'Asia/Hebron' | 'Asia/Ho_Chi_Minh' | 'Asia/Hong_Kong' | 'Asia/Hovd' | 'Asia/Irkutsk' | 'Asia/Istanbul' | 'Asia/Jakarta' | 'Asia/Jayapura' | 'Asia/Jerusalem' | 'Asia/Kabul' | 'Asia/Kamchatka' | 'Asia/Karachi' | 'Asia/Kashgar' | 'Asia/Kathmandu' | 'Asia/Katmandu' | 'Asia/Khandyga' | 'Asia/Kolkata' | 'Asia/Krasnoyarsk' | 'Asia/Kuala_Lumpur' | 'Asia/Kuching' | 'Asia/Kuwait' | 'Asia/Macao' | 'Asia/Macau' | 'Asia/Magadan' | 'Asia/Makassar' | 'Asia/Manila' | 'Asia/Muscat' | 'Asia/Nicosia' | 'Asia/Novokuznetsk' | 'Asia/Novosibirsk' | 'Asia/Omsk' | 'Asia/Oral' | 'Asia/Phnom_Penh' | 'Asia/Pontianak' | 'Asia/Pyongyang' | 'Asia/Qatar' | 'Asia/Qyzylorda' | 'Asia/Rangoon' | 'Asia/Riyadh' | 'Asia/Saigon' | 'Asia/Sakhalin' | 'Asia/Samarkand' | 'Asia/Seoul' | 'Asia/Shanghai' | 'Asia/Singapore' | 'Asia/Srednekolymsk' | 'Asia/Taipei' | 'Asia/Tashkent' | 'Asia/Tbilisi' | 'Asia/Tehran' | 'Asia/Tel_Aviv' | 'Asia/Thimbu' | 'Asia/Thimphu' | 'Asia/Tokyo' | 'Asia/Ujung_Pandang' | 'Asia/Ulaanbaatar' | 'Asia/Ulan_Bator' | 'Asia/Urumqi' | 'Asia/Ust-Nera' | 'Asia/Vientiane' | 'Asia/Vladivostok' | 'Asia/Yakutsk' | 'Asia/Yekaterinburg' | 'Asia/Yerevan' | 'Atlantic/Azores' | 'Atlantic/Bermuda' | 'Atlantic/Canary' | 'Atlantic/Cape_Verde' | 'Atlantic/Faeroe' | 'Atlantic/Faroe' | 'Atlantic/Jan_Mayen' | 'Atlantic/Madeira' | 'Atlantic/Reykjavik' | 'Atlantic/South_Georgia' | 'Atlantic/St_Helena' | 'Atlantic/Stanley' | 'Australia/ACT' | 'Australia/Adelaide' | 'Australia/Brisbane' | 'Australia/Broken_Hill' | 'Australia/Canberra' | 'Australia/Currie' | 'Australia/Darwin' | 'Australia/Eucla' | 'Australia/Hobart' | 'Australia/LHI' | 'Australia/Lindeman' | 'Australia/Lord_Howe' | 'Australia/Melbourne' | 'Australia/NSW' | 'Australia/North' | 'Australia/Perth' | 'Australia/Queensland' | 'Australia/South' | 'Australia/Sydney' | 'Australia/Tasmania' | 'Australia/Victoria' | 'Australia/West' | 'Australia/Yancowinna' | 'Brazil/Acre' | 'Brazil/DeNoronha' | 'Brazil/East' | 'Brazil/West' | 'Canada/Atlantic' | 'Canada/Central' | 'Canada/East-Saskatchewan' | 'Canada/Eastern' | 'Canada/Mountain' | 'Canada/Newfoundland' | 'Canada/Pacific' | 'Canada/Saskatchewan' | 'Canada/Yukon' | 'Chile/Continental' | 'Chile/EasterIsland' | 'Etc/GMT' | 'Etc/GMT+0' | 'Etc/GMT+1' | 'Etc/GMT+10' | 'Etc/GMT+11' | 'Etc/GMT+12' | 'Etc/GMT+2' | 'Etc/GMT+3' | 'Etc/GMT+4' | 'Etc/GMT+5' | 'Etc/GMT+6' | 'Etc/GMT+7' | 'Etc/GMT+8' | 'Etc/GMT+9' | 'Etc/GMT-0' | 'Etc/GMT-1' | 'Etc/GMT-10' | 'Etc/GMT-11' | 'Etc/GMT-12' | 'Etc/GMT-13' | 'Etc/GMT-14' | 'Etc/GMT-2' | 'Etc/GMT-3' | 'Etc/GMT-4' | 'Etc/GMT-5' | 'Etc/GMT-6' | 'Etc/GMT-7' | 'Etc/GMT-8' | 'Etc/GMT-9' | 'Etc/GMT0' | 'Etc/Greenwich' | 'Etc/UCT' | 'Etc/UTC' | 'Etc/Universal' | 'Etc/Zulu' | 'Europe/Amsterdam' | 'Europe/Andorra' | 'Europe/Athens' | 'Europe/Belfast' | 'Europe/Belgrade' | 'Europe/Berlin' | 'Europe/Bratislava' | 'Europe/Brussels' | 'Europe/Bucharest' | 'Europe/Budapest' | 'Europe/Busingen' | 'Europe/Chisinau' | 'Europe/Copenhagen' | 'Europe/Dublin' | 'Europe/Gibraltar' | 'Europe/Guernsey' | 'Europe/Helsinki' | 'Europe/Isle_of_Man' | 'Europe/Istanbul' | 'Europe/Jersey' | 'Europe/Kaliningrad' | 'Europe/Kiev' | 'Europe/Lisbon' | 'Europe/Ljubljana' | 'Europe/London' | 'Europe/Luxembourg' | 'Europe/Madrid' | 'Europe/Malta' | 'Europe/Mariehamn' | 'Europe/Minsk' | 'Europe/Monaco' | 'Europe/Moscow' | 'Europe/Nicosia' | 'Europe/Oslo' | 'Europe/Paris' | 'Europe/Podgorica' | 'Europe/Prague' | 'Europe/Riga' | 'Europe/Rome' | 'Europe/Samara' | 'Europe/San_Marino' | 'Europe/Sarajevo' | 'Europe/Simferopol' | 'Europe/Skopje' | 'Europe/Sofia' | 'Europe/Stockholm' | 'Europe/Tallinn' | 'Europe/Tirane' | 'Europe/Tiraspol' | 'Europe/Uzhgorod' | 'Europe/Vaduz' | 'Europe/Vatican' | 'Europe/Vienna' | 'Europe/Vilnius' | 'Europe/Volgograd' | 'Europe/Warsaw' | 'Europe/Zagreb' | 'Europe/Zaporozhye' | 'Europe/Zurich' | 'Indian/Antananarivo' | 'Indian/Chagos' | 'Indian/Christmas' | 'Indian/Cocos' | 'Indian/Comoro' | 'Indian/Kerguelen' | 'Indian/Mahe' | 'Indian/Maldives' | 'Indian/Mauritius' | 'Indian/Mayotte' | 'Indian/Reunion' | 'Mexico/BajaNorte' | 'Mexico/BajaSur' | 'Mexico/General' | 'Pacific/Apia' | 'Pacific/Auckland' | 'Pacific/Chatham' | 'Pacific/Chuuk' | 'Pacific/Easter' | 'Pacific/Efate' | 'Pacific/Enderbury' | 'Pacific/Fakaofo' | 'Pacific/Fiji' | 'Pacific/Funafuti' | 'Pacific/Galapagos' | 'Pacific/Gambier' | 'Pacific/Guadalcanal' | 'Pacific/Guam' | 'Pacific/Honolulu' | 'Pacific/Johnston' | 'Pacific/Kiritimati' | 'Pacific/Kosrae' | 'Pacific/Kwajalein' | 'Pacific/Majuro' | 'Pacific/Marquesas' | 'Pacific/Midway' | 'Pacific/Nauru' | 'Pacific/Niue' | 'Pacific/Norfolk' | 'Pacific/Noumea' | 'Pacific/Pago_Pago' | 'Pacific/Palau' | 'Pacific/Pitcairn' | 'Pacific/Pohnpei' | 'Pacific/Ponape' | 'Pacific/Port_Moresby' | 'Pacific/Rarotonga' | 'Pacific/Saipan' | 'Pacific/Samoa' | 'Pacific/Tahiti' | 'Pacific/Tarawa' | 'Pacific/Tongatapu' | 'Pacific/Truk' | 'Pacific/Wake' | 'Pacific/Wallis' | 'Pacific/Yap'} [timeZone] Time Zone by which to aggregate the results.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to the beginning of the current month.
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to midnight tonight.
         * @param {Array<'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure'>} [types] An array containing specific balance transaction types. The data will be filtered to include only transactions with a matching type property.
         * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceTransactionsSummary: async (tilledAccount: string, timeUnit?: 'day' | 'month', timeZone?: 'Africa/Abidjan' | 'Africa/Accra' | 'Africa/Addis_Ababa' | 'Africa/Algiers' | 'Africa/Asmara' | 'Africa/Asmera' | 'Africa/Bamako' | 'Africa/Bangui' | 'Africa/Banjul' | 'Africa/Bissau' | 'Africa/Blantyre' | 'Africa/Brazzaville' | 'Africa/Bujumbura' | 'Africa/Cairo' | 'Africa/Casablanca' | 'Africa/Ceuta' | 'Africa/Conakry' | 'Africa/Dakar' | 'Africa/Dar_es_Salaam' | 'Africa/Djibouti' | 'Africa/Douala' | 'Africa/El_Aaiun' | 'Africa/Freetown' | 'Africa/Gaborone' | 'Africa/Harare' | 'Africa/Johannesburg' | 'Africa/Juba' | 'Africa/Kampala' | 'Africa/Khartoum' | 'Africa/Kigali' | 'Africa/Kinshasa' | 'Africa/Lagos' | 'Africa/Libreville' | 'Africa/Lome' | 'Africa/Luanda' | 'Africa/Lubumbashi' | 'Africa/Lusaka' | 'Africa/Malabo' | 'Africa/Maputo' | 'Africa/Maseru' | 'Africa/Mbabane' | 'Africa/Mogadishu' | 'Africa/Monrovia' | 'Africa/Nairobi' | 'Africa/Ndjamena' | 'Africa/Niamey' | 'Africa/Nouakchott' | 'Africa/Ouagadougou' | 'Africa/Porto-Novo' | 'Africa/Sao_Tome' | 'Africa/Timbuktu' | 'Africa/Tripoli' | 'Africa/Tunis' | 'Africa/Windhoek' | 'America/Adak' | 'America/Anchorage' | 'America/Anguilla' | 'America/Antigua' | 'America/Araguaina' | 'America/Argentina/Buenos_Aires' | 'America/Argentina/Catamarca' | 'America/Argentina/ComodRivadavia' | 'America/Argentina/Cordoba' | 'America/Argentina/Jujuy' | 'America/Argentina/La_Rioja' | 'America/Argentina/Mendoza' | 'America/Argentina/Rio_Gallegos' | 'America/Argentina/Salta' | 'America/Argentina/San_Juan' | 'America/Argentina/San_Luis' | 'America/Argentina/Tucuman' | 'America/Argentina/Ushuaia' | 'America/Aruba' | 'America/Asuncion' | 'America/Atikokan' | 'America/Atka' | 'America/Bahia' | 'America/Bahia_Banderas' | 'America/Barbados' | 'America/Belem' | 'America/Belize' | 'America/Blanc-Sablon' | 'America/Boa_Vista' | 'America/Bogota' | 'America/Boise' | 'America/Buenos_Aires' | 'America/Cambridge_Bay' | 'America/Campo_Grande' | 'America/Cancun' | 'America/Caracas' | 'America/Catamarca' | 'America/Cayenne' | 'America/Cayman' | 'America/Chicago' | 'America/Chihuahua' | 'America/Coral_Harbour' | 'America/Cordoba' | 'America/Costa_Rica' | 'America/Creston' | 'America/Cuiaba' | 'America/Curacao' | 'America/Danmarkshavn' | 'America/Dawson' | 'America/Dawson_Creek' | 'America/Denver' | 'America/Detroit' | 'America/Dominica' | 'America/Edmonton' | 'America/Eirunepe' | 'America/El_Salvador' | 'America/Ensenada' | 'America/Fort_Wayne' | 'America/Fortaleza' | 'America/Glace_Bay' | 'America/Godthab' | 'America/Goose_Bay' | 'America/Grand_Turk' | 'America/Grenada' | 'America/Guadeloupe' | 'America/Guatemala' | 'America/Guayaquil' | 'America/Guyana' | 'America/Halifax' | 'America/Havana' | 'America/Hermosillo' | 'America/Indiana/Indianapolis' | 'America/Indiana/Knox' | 'America/Indiana/Marengo' | 'America/Indiana/Petersburg' | 'America/Indiana/Tell_City' | 'America/Indiana/Vevay' | 'America/Indiana/Vincennes' | 'America/Indiana/Winamac' | 'America/Indianapolis' | 'America/Inuvik' | 'America/Iqaluit' | 'America/Jamaica' | 'America/Jujuy' | 'America/Juneau' | 'America/Kentucky/Louisville' | 'America/Kentucky/Monticello' | 'America/Knox_IN' | 'America/Kralendijk' | 'America/La_Paz' | 'America/Lima' | 'America/Los_Angeles' | 'America/Louisville' | 'America/Lower_Princes' | 'America/Maceio' | 'America/Managua' | 'America/Manaus' | 'America/Marigot' | 'America/Martinique' | 'America/Matamoros' | 'America/Mazatlan' | 'America/Mendoza' | 'America/Menominee' | 'America/Merida' | 'America/Metlakatla' | 'America/Mexico_City' | 'America/Miquelon' | 'America/Moncton' | 'America/Monterrey' | 'America/Montevideo' | 'America/Montreal' | 'America/Montserrat' | 'America/Nassau' | 'America/New_York' | 'America/Nipigon' | 'America/Nome' | 'America/Noronha' | 'America/North_Dakota/Beulah' | 'America/North_Dakota/Center' | 'America/North_Dakota/New_Salem' | 'America/Ojinaga' | 'America/Panama' | 'America/Pangnirtung' | 'America/Paramaribo' | 'America/Phoenix' | 'America/Port-au-Prince' | 'America/Port_of_Spain' | 'America/Porto_Acre' | 'America/Porto_Velho' | 'America/Puerto_Rico' | 'America/Rainy_River' | 'America/Rankin_Inlet' | 'America/Recife' | 'America/Regina' | 'America/Resolute' | 'America/Rio_Branco' | 'America/Rosario' | 'America/Santa_Isabel' | 'America/Santarem' | 'America/Santiago' | 'America/Santo_Domingo' | 'America/Sao_Paulo' | 'America/Scoresbysund' | 'America/Shiprock' | 'America/Sitka' | 'America/St_Barthelemy' | 'America/St_Johns' | 'America/St_Kitts' | 'America/St_Lucia' | 'America/St_Thomas' | 'America/St_Vincent' | 'America/Swift_Current' | 'America/Tegucigalpa' | 'America/Thule' | 'America/Thunder_Bay' | 'America/Tijuana' | 'America/Toronto' | 'America/Tortola' | 'America/Vancouver' | 'America/Virgin' | 'America/Whitehorse' | 'America/Winnipeg' | 'America/Yakutat' | 'America/Yellowknife' | 'Antarctica/Casey' | 'Antarctica/Davis' | 'Antarctica/DumontDUrville' | 'Antarctica/Macquarie' | 'Antarctica/Mawson' | 'Antarctica/McMurdo' | 'Antarctica/Palmer' | 'Antarctica/Rothera' | 'Antarctica/South_Pole' | 'Antarctica/Syowa' | 'Antarctica/Troll' | 'Antarctica/Vostok' | 'Arctic/Longyearbyen' | 'Asia/Aden' | 'Asia/Almaty' | 'Asia/Amman' | 'Asia/Anadyr' | 'Asia/Aqtau' | 'Asia/Aqtobe' | 'Asia/Ashgabat' | 'Asia/Ashkhabad' | 'Asia/Baghdad' | 'Asia/Bahrain' | 'Asia/Baku' | 'Asia/Bangkok' | 'Asia/Beirut' | 'Asia/Bishkek' | 'Asia/Brunei' | 'Asia/Calcutta' | 'Asia/Chita' | 'Asia/Choibalsan' | 'Asia/Chongqing' | 'Asia/Chungking' | 'Asia/Colombo' | 'Asia/Dacca' | 'Asia/Damascus' | 'Asia/Dhaka' | 'Asia/Dili' | 'Asia/Dubai' | 'Asia/Dushanbe' | 'Asia/Gaza' | 'Asia/Harbin' | 'Asia/Hebron' | 'Asia/Ho_Chi_Minh' | 'Asia/Hong_Kong' | 'Asia/Hovd' | 'Asia/Irkutsk' | 'Asia/Istanbul' | 'Asia/Jakarta' | 'Asia/Jayapura' | 'Asia/Jerusalem' | 'Asia/Kabul' | 'Asia/Kamchatka' | 'Asia/Karachi' | 'Asia/Kashgar' | 'Asia/Kathmandu' | 'Asia/Katmandu' | 'Asia/Khandyga' | 'Asia/Kolkata' | 'Asia/Krasnoyarsk' | 'Asia/Kuala_Lumpur' | 'Asia/Kuching' | 'Asia/Kuwait' | 'Asia/Macao' | 'Asia/Macau' | 'Asia/Magadan' | 'Asia/Makassar' | 'Asia/Manila' | 'Asia/Muscat' | 'Asia/Nicosia' | 'Asia/Novokuznetsk' | 'Asia/Novosibirsk' | 'Asia/Omsk' | 'Asia/Oral' | 'Asia/Phnom_Penh' | 'Asia/Pontianak' | 'Asia/Pyongyang' | 'Asia/Qatar' | 'Asia/Qyzylorda' | 'Asia/Rangoon' | 'Asia/Riyadh' | 'Asia/Saigon' | 'Asia/Sakhalin' | 'Asia/Samarkand' | 'Asia/Seoul' | 'Asia/Shanghai' | 'Asia/Singapore' | 'Asia/Srednekolymsk' | 'Asia/Taipei' | 'Asia/Tashkent' | 'Asia/Tbilisi' | 'Asia/Tehran' | 'Asia/Tel_Aviv' | 'Asia/Thimbu' | 'Asia/Thimphu' | 'Asia/Tokyo' | 'Asia/Ujung_Pandang' | 'Asia/Ulaanbaatar' | 'Asia/Ulan_Bator' | 'Asia/Urumqi' | 'Asia/Ust-Nera' | 'Asia/Vientiane' | 'Asia/Vladivostok' | 'Asia/Yakutsk' | 'Asia/Yekaterinburg' | 'Asia/Yerevan' | 'Atlantic/Azores' | 'Atlantic/Bermuda' | 'Atlantic/Canary' | 'Atlantic/Cape_Verde' | 'Atlantic/Faeroe' | 'Atlantic/Faroe' | 'Atlantic/Jan_Mayen' | 'Atlantic/Madeira' | 'Atlantic/Reykjavik' | 'Atlantic/South_Georgia' | 'Atlantic/St_Helena' | 'Atlantic/Stanley' | 'Australia/ACT' | 'Australia/Adelaide' | 'Australia/Brisbane' | 'Australia/Broken_Hill' | 'Australia/Canberra' | 'Australia/Currie' | 'Australia/Darwin' | 'Australia/Eucla' | 'Australia/Hobart' | 'Australia/LHI' | 'Australia/Lindeman' | 'Australia/Lord_Howe' | 'Australia/Melbourne' | 'Australia/NSW' | 'Australia/North' | 'Australia/Perth' | 'Australia/Queensland' | 'Australia/South' | 'Australia/Sydney' | 'Australia/Tasmania' | 'Australia/Victoria' | 'Australia/West' | 'Australia/Yancowinna' | 'Brazil/Acre' | 'Brazil/DeNoronha' | 'Brazil/East' | 'Brazil/West' | 'Canada/Atlantic' | 'Canada/Central' | 'Canada/East-Saskatchewan' | 'Canada/Eastern' | 'Canada/Mountain' | 'Canada/Newfoundland' | 'Canada/Pacific' | 'Canada/Saskatchewan' | 'Canada/Yukon' | 'Chile/Continental' | 'Chile/EasterIsland' | 'Etc/GMT' | 'Etc/GMT+0' | 'Etc/GMT+1' | 'Etc/GMT+10' | 'Etc/GMT+11' | 'Etc/GMT+12' | 'Etc/GMT+2' | 'Etc/GMT+3' | 'Etc/GMT+4' | 'Etc/GMT+5' | 'Etc/GMT+6' | 'Etc/GMT+7' | 'Etc/GMT+8' | 'Etc/GMT+9' | 'Etc/GMT-0' | 'Etc/GMT-1' | 'Etc/GMT-10' | 'Etc/GMT-11' | 'Etc/GMT-12' | 'Etc/GMT-13' | 'Etc/GMT-14' | 'Etc/GMT-2' | 'Etc/GMT-3' | 'Etc/GMT-4' | 'Etc/GMT-5' | 'Etc/GMT-6' | 'Etc/GMT-7' | 'Etc/GMT-8' | 'Etc/GMT-9' | 'Etc/GMT0' | 'Etc/Greenwich' | 'Etc/UCT' | 'Etc/UTC' | 'Etc/Universal' | 'Etc/Zulu' | 'Europe/Amsterdam' | 'Europe/Andorra' | 'Europe/Athens' | 'Europe/Belfast' | 'Europe/Belgrade' | 'Europe/Berlin' | 'Europe/Bratislava' | 'Europe/Brussels' | 'Europe/Bucharest' | 'Europe/Budapest' | 'Europe/Busingen' | 'Europe/Chisinau' | 'Europe/Copenhagen' | 'Europe/Dublin' | 'Europe/Gibraltar' | 'Europe/Guernsey' | 'Europe/Helsinki' | 'Europe/Isle_of_Man' | 'Europe/Istanbul' | 'Europe/Jersey' | 'Europe/Kaliningrad' | 'Europe/Kiev' | 'Europe/Lisbon' | 'Europe/Ljubljana' | 'Europe/London' | 'Europe/Luxembourg' | 'Europe/Madrid' | 'Europe/Malta' | 'Europe/Mariehamn' | 'Europe/Minsk' | 'Europe/Monaco' | 'Europe/Moscow' | 'Europe/Nicosia' | 'Europe/Oslo' | 'Europe/Paris' | 'Europe/Podgorica' | 'Europe/Prague' | 'Europe/Riga' | 'Europe/Rome' | 'Europe/Samara' | 'Europe/San_Marino' | 'Europe/Sarajevo' | 'Europe/Simferopol' | 'Europe/Skopje' | 'Europe/Sofia' | 'Europe/Stockholm' | 'Europe/Tallinn' | 'Europe/Tirane' | 'Europe/Tiraspol' | 'Europe/Uzhgorod' | 'Europe/Vaduz' | 'Europe/Vatican' | 'Europe/Vienna' | 'Europe/Vilnius' | 'Europe/Volgograd' | 'Europe/Warsaw' | 'Europe/Zagreb' | 'Europe/Zaporozhye' | 'Europe/Zurich' | 'Indian/Antananarivo' | 'Indian/Chagos' | 'Indian/Christmas' | 'Indian/Cocos' | 'Indian/Comoro' | 'Indian/Kerguelen' | 'Indian/Mahe' | 'Indian/Maldives' | 'Indian/Mauritius' | 'Indian/Mayotte' | 'Indian/Reunion' | 'Mexico/BajaNorte' | 'Mexico/BajaSur' | 'Mexico/General' | 'Pacific/Apia' | 'Pacific/Auckland' | 'Pacific/Chatham' | 'Pacific/Chuuk' | 'Pacific/Easter' | 'Pacific/Efate' | 'Pacific/Enderbury' | 'Pacific/Fakaofo' | 'Pacific/Fiji' | 'Pacific/Funafuti' | 'Pacific/Galapagos' | 'Pacific/Gambier' | 'Pacific/Guadalcanal' | 'Pacific/Guam' | 'Pacific/Honolulu' | 'Pacific/Johnston' | 'Pacific/Kiritimati' | 'Pacific/Kosrae' | 'Pacific/Kwajalein' | 'Pacific/Majuro' | 'Pacific/Marquesas' | 'Pacific/Midway' | 'Pacific/Nauru' | 'Pacific/Niue' | 'Pacific/Norfolk' | 'Pacific/Noumea' | 'Pacific/Pago_Pago' | 'Pacific/Palau' | 'Pacific/Pitcairn' | 'Pacific/Pohnpei' | 'Pacific/Ponape' | 'Pacific/Port_Moresby' | 'Pacific/Rarotonga' | 'Pacific/Saipan' | 'Pacific/Samoa' | 'Pacific/Tahiti' | 'Pacific/Tarawa' | 'Pacific/Tongatapu' | 'Pacific/Truk' | 'Pacific/Wake' | 'Pacific/Wallis' | 'Pacific/Yap', createdAtGte?: string, createdAtLte?: string, types?: Array<'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure'>, includeConnectedAccounts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getBalanceTransactionsSummary', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/balance-transactions/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (timeUnit !== undefined) {
                localVarQueryParameter['time_unit'] = timeUnit;
            }

            if (timeZone !== undefined) {
                localVarQueryParameter['time_zone'] = timeZone;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (includeConnectedAccounts !== undefined) {
                localVarQueryParameter['include_connected_accounts'] = includeConnectedAccounts;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of transactions that have contributed to the Tilled account balance (e.g. charges, refunds, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.
         * @summary List all balance transactions
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure'} [type] Only return transaction of the given type.
         * @param {string} [sourceId] Only returns the original transaction.
         * @param {string} [payoutId] Only returns transactions that were paid out on the specified payout ID.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalanceTransactions: async (tilledAccount: string, createdAtGte?: string, createdAtLte?: string, type?: 'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure', sourceId?: string, payoutId?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listBalanceTransactions', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/balance-transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source_id'] = sourceId;
            }

            if (payoutId !== undefined) {
                localVarQueryParameter['payout_id'] = payoutId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalanceTransactionsApi - functional programming interface
 * @export
 */
export const BalanceTransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalanceTransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the balance transactioni with the given ID.
         * @summary Retrieve a balance transaction
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalanceTransaction(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceTransaction(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a summary of transactions grouped by `time_unit`, `type`, and `currency`.
         * @summary Get balance transactions summary
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {'day' | 'month'} [timeUnit] String indicating the unit of time to aggregate the summary of data.
         * @param {'Africa/Abidjan' | 'Africa/Accra' | 'Africa/Addis_Ababa' | 'Africa/Algiers' | 'Africa/Asmara' | 'Africa/Asmera' | 'Africa/Bamako' | 'Africa/Bangui' | 'Africa/Banjul' | 'Africa/Bissau' | 'Africa/Blantyre' | 'Africa/Brazzaville' | 'Africa/Bujumbura' | 'Africa/Cairo' | 'Africa/Casablanca' | 'Africa/Ceuta' | 'Africa/Conakry' | 'Africa/Dakar' | 'Africa/Dar_es_Salaam' | 'Africa/Djibouti' | 'Africa/Douala' | 'Africa/El_Aaiun' | 'Africa/Freetown' | 'Africa/Gaborone' | 'Africa/Harare' | 'Africa/Johannesburg' | 'Africa/Juba' | 'Africa/Kampala' | 'Africa/Khartoum' | 'Africa/Kigali' | 'Africa/Kinshasa' | 'Africa/Lagos' | 'Africa/Libreville' | 'Africa/Lome' | 'Africa/Luanda' | 'Africa/Lubumbashi' | 'Africa/Lusaka' | 'Africa/Malabo' | 'Africa/Maputo' | 'Africa/Maseru' | 'Africa/Mbabane' | 'Africa/Mogadishu' | 'Africa/Monrovia' | 'Africa/Nairobi' | 'Africa/Ndjamena' | 'Africa/Niamey' | 'Africa/Nouakchott' | 'Africa/Ouagadougou' | 'Africa/Porto-Novo' | 'Africa/Sao_Tome' | 'Africa/Timbuktu' | 'Africa/Tripoli' | 'Africa/Tunis' | 'Africa/Windhoek' | 'America/Adak' | 'America/Anchorage' | 'America/Anguilla' | 'America/Antigua' | 'America/Araguaina' | 'America/Argentina/Buenos_Aires' | 'America/Argentina/Catamarca' | 'America/Argentina/ComodRivadavia' | 'America/Argentina/Cordoba' | 'America/Argentina/Jujuy' | 'America/Argentina/La_Rioja' | 'America/Argentina/Mendoza' | 'America/Argentina/Rio_Gallegos' | 'America/Argentina/Salta' | 'America/Argentina/San_Juan' | 'America/Argentina/San_Luis' | 'America/Argentina/Tucuman' | 'America/Argentina/Ushuaia' | 'America/Aruba' | 'America/Asuncion' | 'America/Atikokan' | 'America/Atka' | 'America/Bahia' | 'America/Bahia_Banderas' | 'America/Barbados' | 'America/Belem' | 'America/Belize' | 'America/Blanc-Sablon' | 'America/Boa_Vista' | 'America/Bogota' | 'America/Boise' | 'America/Buenos_Aires' | 'America/Cambridge_Bay' | 'America/Campo_Grande' | 'America/Cancun' | 'America/Caracas' | 'America/Catamarca' | 'America/Cayenne' | 'America/Cayman' | 'America/Chicago' | 'America/Chihuahua' | 'America/Coral_Harbour' | 'America/Cordoba' | 'America/Costa_Rica' | 'America/Creston' | 'America/Cuiaba' | 'America/Curacao' | 'America/Danmarkshavn' | 'America/Dawson' | 'America/Dawson_Creek' | 'America/Denver' | 'America/Detroit' | 'America/Dominica' | 'America/Edmonton' | 'America/Eirunepe' | 'America/El_Salvador' | 'America/Ensenada' | 'America/Fort_Wayne' | 'America/Fortaleza' | 'America/Glace_Bay' | 'America/Godthab' | 'America/Goose_Bay' | 'America/Grand_Turk' | 'America/Grenada' | 'America/Guadeloupe' | 'America/Guatemala' | 'America/Guayaquil' | 'America/Guyana' | 'America/Halifax' | 'America/Havana' | 'America/Hermosillo' | 'America/Indiana/Indianapolis' | 'America/Indiana/Knox' | 'America/Indiana/Marengo' | 'America/Indiana/Petersburg' | 'America/Indiana/Tell_City' | 'America/Indiana/Vevay' | 'America/Indiana/Vincennes' | 'America/Indiana/Winamac' | 'America/Indianapolis' | 'America/Inuvik' | 'America/Iqaluit' | 'America/Jamaica' | 'America/Jujuy' | 'America/Juneau' | 'America/Kentucky/Louisville' | 'America/Kentucky/Monticello' | 'America/Knox_IN' | 'America/Kralendijk' | 'America/La_Paz' | 'America/Lima' | 'America/Los_Angeles' | 'America/Louisville' | 'America/Lower_Princes' | 'America/Maceio' | 'America/Managua' | 'America/Manaus' | 'America/Marigot' | 'America/Martinique' | 'America/Matamoros' | 'America/Mazatlan' | 'America/Mendoza' | 'America/Menominee' | 'America/Merida' | 'America/Metlakatla' | 'America/Mexico_City' | 'America/Miquelon' | 'America/Moncton' | 'America/Monterrey' | 'America/Montevideo' | 'America/Montreal' | 'America/Montserrat' | 'America/Nassau' | 'America/New_York' | 'America/Nipigon' | 'America/Nome' | 'America/Noronha' | 'America/North_Dakota/Beulah' | 'America/North_Dakota/Center' | 'America/North_Dakota/New_Salem' | 'America/Ojinaga' | 'America/Panama' | 'America/Pangnirtung' | 'America/Paramaribo' | 'America/Phoenix' | 'America/Port-au-Prince' | 'America/Port_of_Spain' | 'America/Porto_Acre' | 'America/Porto_Velho' | 'America/Puerto_Rico' | 'America/Rainy_River' | 'America/Rankin_Inlet' | 'America/Recife' | 'America/Regina' | 'America/Resolute' | 'America/Rio_Branco' | 'America/Rosario' | 'America/Santa_Isabel' | 'America/Santarem' | 'America/Santiago' | 'America/Santo_Domingo' | 'America/Sao_Paulo' | 'America/Scoresbysund' | 'America/Shiprock' | 'America/Sitka' | 'America/St_Barthelemy' | 'America/St_Johns' | 'America/St_Kitts' | 'America/St_Lucia' | 'America/St_Thomas' | 'America/St_Vincent' | 'America/Swift_Current' | 'America/Tegucigalpa' | 'America/Thule' | 'America/Thunder_Bay' | 'America/Tijuana' | 'America/Toronto' | 'America/Tortola' | 'America/Vancouver' | 'America/Virgin' | 'America/Whitehorse' | 'America/Winnipeg' | 'America/Yakutat' | 'America/Yellowknife' | 'Antarctica/Casey' | 'Antarctica/Davis' | 'Antarctica/DumontDUrville' | 'Antarctica/Macquarie' | 'Antarctica/Mawson' | 'Antarctica/McMurdo' | 'Antarctica/Palmer' | 'Antarctica/Rothera' | 'Antarctica/South_Pole' | 'Antarctica/Syowa' | 'Antarctica/Troll' | 'Antarctica/Vostok' | 'Arctic/Longyearbyen' | 'Asia/Aden' | 'Asia/Almaty' | 'Asia/Amman' | 'Asia/Anadyr' | 'Asia/Aqtau' | 'Asia/Aqtobe' | 'Asia/Ashgabat' | 'Asia/Ashkhabad' | 'Asia/Baghdad' | 'Asia/Bahrain' | 'Asia/Baku' | 'Asia/Bangkok' | 'Asia/Beirut' | 'Asia/Bishkek' | 'Asia/Brunei' | 'Asia/Calcutta' | 'Asia/Chita' | 'Asia/Choibalsan' | 'Asia/Chongqing' | 'Asia/Chungking' | 'Asia/Colombo' | 'Asia/Dacca' | 'Asia/Damascus' | 'Asia/Dhaka' | 'Asia/Dili' | 'Asia/Dubai' | 'Asia/Dushanbe' | 'Asia/Gaza' | 'Asia/Harbin' | 'Asia/Hebron' | 'Asia/Ho_Chi_Minh' | 'Asia/Hong_Kong' | 'Asia/Hovd' | 'Asia/Irkutsk' | 'Asia/Istanbul' | 'Asia/Jakarta' | 'Asia/Jayapura' | 'Asia/Jerusalem' | 'Asia/Kabul' | 'Asia/Kamchatka' | 'Asia/Karachi' | 'Asia/Kashgar' | 'Asia/Kathmandu' | 'Asia/Katmandu' | 'Asia/Khandyga' | 'Asia/Kolkata' | 'Asia/Krasnoyarsk' | 'Asia/Kuala_Lumpur' | 'Asia/Kuching' | 'Asia/Kuwait' | 'Asia/Macao' | 'Asia/Macau' | 'Asia/Magadan' | 'Asia/Makassar' | 'Asia/Manila' | 'Asia/Muscat' | 'Asia/Nicosia' | 'Asia/Novokuznetsk' | 'Asia/Novosibirsk' | 'Asia/Omsk' | 'Asia/Oral' | 'Asia/Phnom_Penh' | 'Asia/Pontianak' | 'Asia/Pyongyang' | 'Asia/Qatar' | 'Asia/Qyzylorda' | 'Asia/Rangoon' | 'Asia/Riyadh' | 'Asia/Saigon' | 'Asia/Sakhalin' | 'Asia/Samarkand' | 'Asia/Seoul' | 'Asia/Shanghai' | 'Asia/Singapore' | 'Asia/Srednekolymsk' | 'Asia/Taipei' | 'Asia/Tashkent' | 'Asia/Tbilisi' | 'Asia/Tehran' | 'Asia/Tel_Aviv' | 'Asia/Thimbu' | 'Asia/Thimphu' | 'Asia/Tokyo' | 'Asia/Ujung_Pandang' | 'Asia/Ulaanbaatar' | 'Asia/Ulan_Bator' | 'Asia/Urumqi' | 'Asia/Ust-Nera' | 'Asia/Vientiane' | 'Asia/Vladivostok' | 'Asia/Yakutsk' | 'Asia/Yekaterinburg' | 'Asia/Yerevan' | 'Atlantic/Azores' | 'Atlantic/Bermuda' | 'Atlantic/Canary' | 'Atlantic/Cape_Verde' | 'Atlantic/Faeroe' | 'Atlantic/Faroe' | 'Atlantic/Jan_Mayen' | 'Atlantic/Madeira' | 'Atlantic/Reykjavik' | 'Atlantic/South_Georgia' | 'Atlantic/St_Helena' | 'Atlantic/Stanley' | 'Australia/ACT' | 'Australia/Adelaide' | 'Australia/Brisbane' | 'Australia/Broken_Hill' | 'Australia/Canberra' | 'Australia/Currie' | 'Australia/Darwin' | 'Australia/Eucla' | 'Australia/Hobart' | 'Australia/LHI' | 'Australia/Lindeman' | 'Australia/Lord_Howe' | 'Australia/Melbourne' | 'Australia/NSW' | 'Australia/North' | 'Australia/Perth' | 'Australia/Queensland' | 'Australia/South' | 'Australia/Sydney' | 'Australia/Tasmania' | 'Australia/Victoria' | 'Australia/West' | 'Australia/Yancowinna' | 'Brazil/Acre' | 'Brazil/DeNoronha' | 'Brazil/East' | 'Brazil/West' | 'Canada/Atlantic' | 'Canada/Central' | 'Canada/East-Saskatchewan' | 'Canada/Eastern' | 'Canada/Mountain' | 'Canada/Newfoundland' | 'Canada/Pacific' | 'Canada/Saskatchewan' | 'Canada/Yukon' | 'Chile/Continental' | 'Chile/EasterIsland' | 'Etc/GMT' | 'Etc/GMT+0' | 'Etc/GMT+1' | 'Etc/GMT+10' | 'Etc/GMT+11' | 'Etc/GMT+12' | 'Etc/GMT+2' | 'Etc/GMT+3' | 'Etc/GMT+4' | 'Etc/GMT+5' | 'Etc/GMT+6' | 'Etc/GMT+7' | 'Etc/GMT+8' | 'Etc/GMT+9' | 'Etc/GMT-0' | 'Etc/GMT-1' | 'Etc/GMT-10' | 'Etc/GMT-11' | 'Etc/GMT-12' | 'Etc/GMT-13' | 'Etc/GMT-14' | 'Etc/GMT-2' | 'Etc/GMT-3' | 'Etc/GMT-4' | 'Etc/GMT-5' | 'Etc/GMT-6' | 'Etc/GMT-7' | 'Etc/GMT-8' | 'Etc/GMT-9' | 'Etc/GMT0' | 'Etc/Greenwich' | 'Etc/UCT' | 'Etc/UTC' | 'Etc/Universal' | 'Etc/Zulu' | 'Europe/Amsterdam' | 'Europe/Andorra' | 'Europe/Athens' | 'Europe/Belfast' | 'Europe/Belgrade' | 'Europe/Berlin' | 'Europe/Bratislava' | 'Europe/Brussels' | 'Europe/Bucharest' | 'Europe/Budapest' | 'Europe/Busingen' | 'Europe/Chisinau' | 'Europe/Copenhagen' | 'Europe/Dublin' | 'Europe/Gibraltar' | 'Europe/Guernsey' | 'Europe/Helsinki' | 'Europe/Isle_of_Man' | 'Europe/Istanbul' | 'Europe/Jersey' | 'Europe/Kaliningrad' | 'Europe/Kiev' | 'Europe/Lisbon' | 'Europe/Ljubljana' | 'Europe/London' | 'Europe/Luxembourg' | 'Europe/Madrid' | 'Europe/Malta' | 'Europe/Mariehamn' | 'Europe/Minsk' | 'Europe/Monaco' | 'Europe/Moscow' | 'Europe/Nicosia' | 'Europe/Oslo' | 'Europe/Paris' | 'Europe/Podgorica' | 'Europe/Prague' | 'Europe/Riga' | 'Europe/Rome' | 'Europe/Samara' | 'Europe/San_Marino' | 'Europe/Sarajevo' | 'Europe/Simferopol' | 'Europe/Skopje' | 'Europe/Sofia' | 'Europe/Stockholm' | 'Europe/Tallinn' | 'Europe/Tirane' | 'Europe/Tiraspol' | 'Europe/Uzhgorod' | 'Europe/Vaduz' | 'Europe/Vatican' | 'Europe/Vienna' | 'Europe/Vilnius' | 'Europe/Volgograd' | 'Europe/Warsaw' | 'Europe/Zagreb' | 'Europe/Zaporozhye' | 'Europe/Zurich' | 'Indian/Antananarivo' | 'Indian/Chagos' | 'Indian/Christmas' | 'Indian/Cocos' | 'Indian/Comoro' | 'Indian/Kerguelen' | 'Indian/Mahe' | 'Indian/Maldives' | 'Indian/Mauritius' | 'Indian/Mayotte' | 'Indian/Reunion' | 'Mexico/BajaNorte' | 'Mexico/BajaSur' | 'Mexico/General' | 'Pacific/Apia' | 'Pacific/Auckland' | 'Pacific/Chatham' | 'Pacific/Chuuk' | 'Pacific/Easter' | 'Pacific/Efate' | 'Pacific/Enderbury' | 'Pacific/Fakaofo' | 'Pacific/Fiji' | 'Pacific/Funafuti' | 'Pacific/Galapagos' | 'Pacific/Gambier' | 'Pacific/Guadalcanal' | 'Pacific/Guam' | 'Pacific/Honolulu' | 'Pacific/Johnston' | 'Pacific/Kiritimati' | 'Pacific/Kosrae' | 'Pacific/Kwajalein' | 'Pacific/Majuro' | 'Pacific/Marquesas' | 'Pacific/Midway' | 'Pacific/Nauru' | 'Pacific/Niue' | 'Pacific/Norfolk' | 'Pacific/Noumea' | 'Pacific/Pago_Pago' | 'Pacific/Palau' | 'Pacific/Pitcairn' | 'Pacific/Pohnpei' | 'Pacific/Ponape' | 'Pacific/Port_Moresby' | 'Pacific/Rarotonga' | 'Pacific/Saipan' | 'Pacific/Samoa' | 'Pacific/Tahiti' | 'Pacific/Tarawa' | 'Pacific/Tongatapu' | 'Pacific/Truk' | 'Pacific/Wake' | 'Pacific/Wallis' | 'Pacific/Yap'} [timeZone] Time Zone by which to aggregate the results.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to the beginning of the current month.
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to midnight tonight.
         * @param {Array<'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure'>} [types] An array containing specific balance transaction types. The data will be filtered to include only transactions with a matching type property.
         * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalanceTransactionsSummary(tilledAccount: string, timeUnit?: 'day' | 'month', timeZone?: 'Africa/Abidjan' | 'Africa/Accra' | 'Africa/Addis_Ababa' | 'Africa/Algiers' | 'Africa/Asmara' | 'Africa/Asmera' | 'Africa/Bamako' | 'Africa/Bangui' | 'Africa/Banjul' | 'Africa/Bissau' | 'Africa/Blantyre' | 'Africa/Brazzaville' | 'Africa/Bujumbura' | 'Africa/Cairo' | 'Africa/Casablanca' | 'Africa/Ceuta' | 'Africa/Conakry' | 'Africa/Dakar' | 'Africa/Dar_es_Salaam' | 'Africa/Djibouti' | 'Africa/Douala' | 'Africa/El_Aaiun' | 'Africa/Freetown' | 'Africa/Gaborone' | 'Africa/Harare' | 'Africa/Johannesburg' | 'Africa/Juba' | 'Africa/Kampala' | 'Africa/Khartoum' | 'Africa/Kigali' | 'Africa/Kinshasa' | 'Africa/Lagos' | 'Africa/Libreville' | 'Africa/Lome' | 'Africa/Luanda' | 'Africa/Lubumbashi' | 'Africa/Lusaka' | 'Africa/Malabo' | 'Africa/Maputo' | 'Africa/Maseru' | 'Africa/Mbabane' | 'Africa/Mogadishu' | 'Africa/Monrovia' | 'Africa/Nairobi' | 'Africa/Ndjamena' | 'Africa/Niamey' | 'Africa/Nouakchott' | 'Africa/Ouagadougou' | 'Africa/Porto-Novo' | 'Africa/Sao_Tome' | 'Africa/Timbuktu' | 'Africa/Tripoli' | 'Africa/Tunis' | 'Africa/Windhoek' | 'America/Adak' | 'America/Anchorage' | 'America/Anguilla' | 'America/Antigua' | 'America/Araguaina' | 'America/Argentina/Buenos_Aires' | 'America/Argentina/Catamarca' | 'America/Argentina/ComodRivadavia' | 'America/Argentina/Cordoba' | 'America/Argentina/Jujuy' | 'America/Argentina/La_Rioja' | 'America/Argentina/Mendoza' | 'America/Argentina/Rio_Gallegos' | 'America/Argentina/Salta' | 'America/Argentina/San_Juan' | 'America/Argentina/San_Luis' | 'America/Argentina/Tucuman' | 'America/Argentina/Ushuaia' | 'America/Aruba' | 'America/Asuncion' | 'America/Atikokan' | 'America/Atka' | 'America/Bahia' | 'America/Bahia_Banderas' | 'America/Barbados' | 'America/Belem' | 'America/Belize' | 'America/Blanc-Sablon' | 'America/Boa_Vista' | 'America/Bogota' | 'America/Boise' | 'America/Buenos_Aires' | 'America/Cambridge_Bay' | 'America/Campo_Grande' | 'America/Cancun' | 'America/Caracas' | 'America/Catamarca' | 'America/Cayenne' | 'America/Cayman' | 'America/Chicago' | 'America/Chihuahua' | 'America/Coral_Harbour' | 'America/Cordoba' | 'America/Costa_Rica' | 'America/Creston' | 'America/Cuiaba' | 'America/Curacao' | 'America/Danmarkshavn' | 'America/Dawson' | 'America/Dawson_Creek' | 'America/Denver' | 'America/Detroit' | 'America/Dominica' | 'America/Edmonton' | 'America/Eirunepe' | 'America/El_Salvador' | 'America/Ensenada' | 'America/Fort_Wayne' | 'America/Fortaleza' | 'America/Glace_Bay' | 'America/Godthab' | 'America/Goose_Bay' | 'America/Grand_Turk' | 'America/Grenada' | 'America/Guadeloupe' | 'America/Guatemala' | 'America/Guayaquil' | 'America/Guyana' | 'America/Halifax' | 'America/Havana' | 'America/Hermosillo' | 'America/Indiana/Indianapolis' | 'America/Indiana/Knox' | 'America/Indiana/Marengo' | 'America/Indiana/Petersburg' | 'America/Indiana/Tell_City' | 'America/Indiana/Vevay' | 'America/Indiana/Vincennes' | 'America/Indiana/Winamac' | 'America/Indianapolis' | 'America/Inuvik' | 'America/Iqaluit' | 'America/Jamaica' | 'America/Jujuy' | 'America/Juneau' | 'America/Kentucky/Louisville' | 'America/Kentucky/Monticello' | 'America/Knox_IN' | 'America/Kralendijk' | 'America/La_Paz' | 'America/Lima' | 'America/Los_Angeles' | 'America/Louisville' | 'America/Lower_Princes' | 'America/Maceio' | 'America/Managua' | 'America/Manaus' | 'America/Marigot' | 'America/Martinique' | 'America/Matamoros' | 'America/Mazatlan' | 'America/Mendoza' | 'America/Menominee' | 'America/Merida' | 'America/Metlakatla' | 'America/Mexico_City' | 'America/Miquelon' | 'America/Moncton' | 'America/Monterrey' | 'America/Montevideo' | 'America/Montreal' | 'America/Montserrat' | 'America/Nassau' | 'America/New_York' | 'America/Nipigon' | 'America/Nome' | 'America/Noronha' | 'America/North_Dakota/Beulah' | 'America/North_Dakota/Center' | 'America/North_Dakota/New_Salem' | 'America/Ojinaga' | 'America/Panama' | 'America/Pangnirtung' | 'America/Paramaribo' | 'America/Phoenix' | 'America/Port-au-Prince' | 'America/Port_of_Spain' | 'America/Porto_Acre' | 'America/Porto_Velho' | 'America/Puerto_Rico' | 'America/Rainy_River' | 'America/Rankin_Inlet' | 'America/Recife' | 'America/Regina' | 'America/Resolute' | 'America/Rio_Branco' | 'America/Rosario' | 'America/Santa_Isabel' | 'America/Santarem' | 'America/Santiago' | 'America/Santo_Domingo' | 'America/Sao_Paulo' | 'America/Scoresbysund' | 'America/Shiprock' | 'America/Sitka' | 'America/St_Barthelemy' | 'America/St_Johns' | 'America/St_Kitts' | 'America/St_Lucia' | 'America/St_Thomas' | 'America/St_Vincent' | 'America/Swift_Current' | 'America/Tegucigalpa' | 'America/Thule' | 'America/Thunder_Bay' | 'America/Tijuana' | 'America/Toronto' | 'America/Tortola' | 'America/Vancouver' | 'America/Virgin' | 'America/Whitehorse' | 'America/Winnipeg' | 'America/Yakutat' | 'America/Yellowknife' | 'Antarctica/Casey' | 'Antarctica/Davis' | 'Antarctica/DumontDUrville' | 'Antarctica/Macquarie' | 'Antarctica/Mawson' | 'Antarctica/McMurdo' | 'Antarctica/Palmer' | 'Antarctica/Rothera' | 'Antarctica/South_Pole' | 'Antarctica/Syowa' | 'Antarctica/Troll' | 'Antarctica/Vostok' | 'Arctic/Longyearbyen' | 'Asia/Aden' | 'Asia/Almaty' | 'Asia/Amman' | 'Asia/Anadyr' | 'Asia/Aqtau' | 'Asia/Aqtobe' | 'Asia/Ashgabat' | 'Asia/Ashkhabad' | 'Asia/Baghdad' | 'Asia/Bahrain' | 'Asia/Baku' | 'Asia/Bangkok' | 'Asia/Beirut' | 'Asia/Bishkek' | 'Asia/Brunei' | 'Asia/Calcutta' | 'Asia/Chita' | 'Asia/Choibalsan' | 'Asia/Chongqing' | 'Asia/Chungking' | 'Asia/Colombo' | 'Asia/Dacca' | 'Asia/Damascus' | 'Asia/Dhaka' | 'Asia/Dili' | 'Asia/Dubai' | 'Asia/Dushanbe' | 'Asia/Gaza' | 'Asia/Harbin' | 'Asia/Hebron' | 'Asia/Ho_Chi_Minh' | 'Asia/Hong_Kong' | 'Asia/Hovd' | 'Asia/Irkutsk' | 'Asia/Istanbul' | 'Asia/Jakarta' | 'Asia/Jayapura' | 'Asia/Jerusalem' | 'Asia/Kabul' | 'Asia/Kamchatka' | 'Asia/Karachi' | 'Asia/Kashgar' | 'Asia/Kathmandu' | 'Asia/Katmandu' | 'Asia/Khandyga' | 'Asia/Kolkata' | 'Asia/Krasnoyarsk' | 'Asia/Kuala_Lumpur' | 'Asia/Kuching' | 'Asia/Kuwait' | 'Asia/Macao' | 'Asia/Macau' | 'Asia/Magadan' | 'Asia/Makassar' | 'Asia/Manila' | 'Asia/Muscat' | 'Asia/Nicosia' | 'Asia/Novokuznetsk' | 'Asia/Novosibirsk' | 'Asia/Omsk' | 'Asia/Oral' | 'Asia/Phnom_Penh' | 'Asia/Pontianak' | 'Asia/Pyongyang' | 'Asia/Qatar' | 'Asia/Qyzylorda' | 'Asia/Rangoon' | 'Asia/Riyadh' | 'Asia/Saigon' | 'Asia/Sakhalin' | 'Asia/Samarkand' | 'Asia/Seoul' | 'Asia/Shanghai' | 'Asia/Singapore' | 'Asia/Srednekolymsk' | 'Asia/Taipei' | 'Asia/Tashkent' | 'Asia/Tbilisi' | 'Asia/Tehran' | 'Asia/Tel_Aviv' | 'Asia/Thimbu' | 'Asia/Thimphu' | 'Asia/Tokyo' | 'Asia/Ujung_Pandang' | 'Asia/Ulaanbaatar' | 'Asia/Ulan_Bator' | 'Asia/Urumqi' | 'Asia/Ust-Nera' | 'Asia/Vientiane' | 'Asia/Vladivostok' | 'Asia/Yakutsk' | 'Asia/Yekaterinburg' | 'Asia/Yerevan' | 'Atlantic/Azores' | 'Atlantic/Bermuda' | 'Atlantic/Canary' | 'Atlantic/Cape_Verde' | 'Atlantic/Faeroe' | 'Atlantic/Faroe' | 'Atlantic/Jan_Mayen' | 'Atlantic/Madeira' | 'Atlantic/Reykjavik' | 'Atlantic/South_Georgia' | 'Atlantic/St_Helena' | 'Atlantic/Stanley' | 'Australia/ACT' | 'Australia/Adelaide' | 'Australia/Brisbane' | 'Australia/Broken_Hill' | 'Australia/Canberra' | 'Australia/Currie' | 'Australia/Darwin' | 'Australia/Eucla' | 'Australia/Hobart' | 'Australia/LHI' | 'Australia/Lindeman' | 'Australia/Lord_Howe' | 'Australia/Melbourne' | 'Australia/NSW' | 'Australia/North' | 'Australia/Perth' | 'Australia/Queensland' | 'Australia/South' | 'Australia/Sydney' | 'Australia/Tasmania' | 'Australia/Victoria' | 'Australia/West' | 'Australia/Yancowinna' | 'Brazil/Acre' | 'Brazil/DeNoronha' | 'Brazil/East' | 'Brazil/West' | 'Canada/Atlantic' | 'Canada/Central' | 'Canada/East-Saskatchewan' | 'Canada/Eastern' | 'Canada/Mountain' | 'Canada/Newfoundland' | 'Canada/Pacific' | 'Canada/Saskatchewan' | 'Canada/Yukon' | 'Chile/Continental' | 'Chile/EasterIsland' | 'Etc/GMT' | 'Etc/GMT+0' | 'Etc/GMT+1' | 'Etc/GMT+10' | 'Etc/GMT+11' | 'Etc/GMT+12' | 'Etc/GMT+2' | 'Etc/GMT+3' | 'Etc/GMT+4' | 'Etc/GMT+5' | 'Etc/GMT+6' | 'Etc/GMT+7' | 'Etc/GMT+8' | 'Etc/GMT+9' | 'Etc/GMT-0' | 'Etc/GMT-1' | 'Etc/GMT-10' | 'Etc/GMT-11' | 'Etc/GMT-12' | 'Etc/GMT-13' | 'Etc/GMT-14' | 'Etc/GMT-2' | 'Etc/GMT-3' | 'Etc/GMT-4' | 'Etc/GMT-5' | 'Etc/GMT-6' | 'Etc/GMT-7' | 'Etc/GMT-8' | 'Etc/GMT-9' | 'Etc/GMT0' | 'Etc/Greenwich' | 'Etc/UCT' | 'Etc/UTC' | 'Etc/Universal' | 'Etc/Zulu' | 'Europe/Amsterdam' | 'Europe/Andorra' | 'Europe/Athens' | 'Europe/Belfast' | 'Europe/Belgrade' | 'Europe/Berlin' | 'Europe/Bratislava' | 'Europe/Brussels' | 'Europe/Bucharest' | 'Europe/Budapest' | 'Europe/Busingen' | 'Europe/Chisinau' | 'Europe/Copenhagen' | 'Europe/Dublin' | 'Europe/Gibraltar' | 'Europe/Guernsey' | 'Europe/Helsinki' | 'Europe/Isle_of_Man' | 'Europe/Istanbul' | 'Europe/Jersey' | 'Europe/Kaliningrad' | 'Europe/Kiev' | 'Europe/Lisbon' | 'Europe/Ljubljana' | 'Europe/London' | 'Europe/Luxembourg' | 'Europe/Madrid' | 'Europe/Malta' | 'Europe/Mariehamn' | 'Europe/Minsk' | 'Europe/Monaco' | 'Europe/Moscow' | 'Europe/Nicosia' | 'Europe/Oslo' | 'Europe/Paris' | 'Europe/Podgorica' | 'Europe/Prague' | 'Europe/Riga' | 'Europe/Rome' | 'Europe/Samara' | 'Europe/San_Marino' | 'Europe/Sarajevo' | 'Europe/Simferopol' | 'Europe/Skopje' | 'Europe/Sofia' | 'Europe/Stockholm' | 'Europe/Tallinn' | 'Europe/Tirane' | 'Europe/Tiraspol' | 'Europe/Uzhgorod' | 'Europe/Vaduz' | 'Europe/Vatican' | 'Europe/Vienna' | 'Europe/Vilnius' | 'Europe/Volgograd' | 'Europe/Warsaw' | 'Europe/Zagreb' | 'Europe/Zaporozhye' | 'Europe/Zurich' | 'Indian/Antananarivo' | 'Indian/Chagos' | 'Indian/Christmas' | 'Indian/Cocos' | 'Indian/Comoro' | 'Indian/Kerguelen' | 'Indian/Mahe' | 'Indian/Maldives' | 'Indian/Mauritius' | 'Indian/Mayotte' | 'Indian/Reunion' | 'Mexico/BajaNorte' | 'Mexico/BajaSur' | 'Mexico/General' | 'Pacific/Apia' | 'Pacific/Auckland' | 'Pacific/Chatham' | 'Pacific/Chuuk' | 'Pacific/Easter' | 'Pacific/Efate' | 'Pacific/Enderbury' | 'Pacific/Fakaofo' | 'Pacific/Fiji' | 'Pacific/Funafuti' | 'Pacific/Galapagos' | 'Pacific/Gambier' | 'Pacific/Guadalcanal' | 'Pacific/Guam' | 'Pacific/Honolulu' | 'Pacific/Johnston' | 'Pacific/Kiritimati' | 'Pacific/Kosrae' | 'Pacific/Kwajalein' | 'Pacific/Majuro' | 'Pacific/Marquesas' | 'Pacific/Midway' | 'Pacific/Nauru' | 'Pacific/Niue' | 'Pacific/Norfolk' | 'Pacific/Noumea' | 'Pacific/Pago_Pago' | 'Pacific/Palau' | 'Pacific/Pitcairn' | 'Pacific/Pohnpei' | 'Pacific/Ponape' | 'Pacific/Port_Moresby' | 'Pacific/Rarotonga' | 'Pacific/Saipan' | 'Pacific/Samoa' | 'Pacific/Tahiti' | 'Pacific/Tarawa' | 'Pacific/Tongatapu' | 'Pacific/Truk' | 'Pacific/Wake' | 'Pacific/Wallis' | 'Pacific/Yap', createdAtGte?: string, createdAtLte?: string, types?: Array<'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure'>, includeConnectedAccounts?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceTransactionsSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalanceTransactionsSummary(tilledAccount, timeUnit, timeZone, createdAtGte, createdAtLte, types, includeConnectedAccounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of transactions that have contributed to the Tilled account balance (e.g. charges, refunds, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.
         * @summary List all balance transactions
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure'} [type] Only return transaction of the given type.
         * @param {string} [sourceId] Only returns the original transaction.
         * @param {string} [payoutId] Only returns transactions that were paid out on the specified payout ID.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBalanceTransactions(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, type?: 'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure', sourceId?: string, payoutId?: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBalanceTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBalanceTransactions(tilledAccount, createdAtGte, createdAtLte, type, sourceId, payoutId, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BalanceTransactionsApi - factory interface
 * @export
 */
export const BalanceTransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalanceTransactionsApiFp(configuration)
    return {
        /**
         * Retrieves the balance transactioni with the given ID.
         * @summary Retrieve a balance transaction
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceTransaction(tilledAccount: string, id: string, options?: any): AxiosPromise<BalanceTransaction> {
            return localVarFp.getBalanceTransaction(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a summary of transactions grouped by `time_unit`, `type`, and `currency`.
         * @summary Get balance transactions summary
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {'day' | 'month'} [timeUnit] String indicating the unit of time to aggregate the summary of data.
         * @param {'Africa/Abidjan' | 'Africa/Accra' | 'Africa/Addis_Ababa' | 'Africa/Algiers' | 'Africa/Asmara' | 'Africa/Asmera' | 'Africa/Bamako' | 'Africa/Bangui' | 'Africa/Banjul' | 'Africa/Bissau' | 'Africa/Blantyre' | 'Africa/Brazzaville' | 'Africa/Bujumbura' | 'Africa/Cairo' | 'Africa/Casablanca' | 'Africa/Ceuta' | 'Africa/Conakry' | 'Africa/Dakar' | 'Africa/Dar_es_Salaam' | 'Africa/Djibouti' | 'Africa/Douala' | 'Africa/El_Aaiun' | 'Africa/Freetown' | 'Africa/Gaborone' | 'Africa/Harare' | 'Africa/Johannesburg' | 'Africa/Juba' | 'Africa/Kampala' | 'Africa/Khartoum' | 'Africa/Kigali' | 'Africa/Kinshasa' | 'Africa/Lagos' | 'Africa/Libreville' | 'Africa/Lome' | 'Africa/Luanda' | 'Africa/Lubumbashi' | 'Africa/Lusaka' | 'Africa/Malabo' | 'Africa/Maputo' | 'Africa/Maseru' | 'Africa/Mbabane' | 'Africa/Mogadishu' | 'Africa/Monrovia' | 'Africa/Nairobi' | 'Africa/Ndjamena' | 'Africa/Niamey' | 'Africa/Nouakchott' | 'Africa/Ouagadougou' | 'Africa/Porto-Novo' | 'Africa/Sao_Tome' | 'Africa/Timbuktu' | 'Africa/Tripoli' | 'Africa/Tunis' | 'Africa/Windhoek' | 'America/Adak' | 'America/Anchorage' | 'America/Anguilla' | 'America/Antigua' | 'America/Araguaina' | 'America/Argentina/Buenos_Aires' | 'America/Argentina/Catamarca' | 'America/Argentina/ComodRivadavia' | 'America/Argentina/Cordoba' | 'America/Argentina/Jujuy' | 'America/Argentina/La_Rioja' | 'America/Argentina/Mendoza' | 'America/Argentina/Rio_Gallegos' | 'America/Argentina/Salta' | 'America/Argentina/San_Juan' | 'America/Argentina/San_Luis' | 'America/Argentina/Tucuman' | 'America/Argentina/Ushuaia' | 'America/Aruba' | 'America/Asuncion' | 'America/Atikokan' | 'America/Atka' | 'America/Bahia' | 'America/Bahia_Banderas' | 'America/Barbados' | 'America/Belem' | 'America/Belize' | 'America/Blanc-Sablon' | 'America/Boa_Vista' | 'America/Bogota' | 'America/Boise' | 'America/Buenos_Aires' | 'America/Cambridge_Bay' | 'America/Campo_Grande' | 'America/Cancun' | 'America/Caracas' | 'America/Catamarca' | 'America/Cayenne' | 'America/Cayman' | 'America/Chicago' | 'America/Chihuahua' | 'America/Coral_Harbour' | 'America/Cordoba' | 'America/Costa_Rica' | 'America/Creston' | 'America/Cuiaba' | 'America/Curacao' | 'America/Danmarkshavn' | 'America/Dawson' | 'America/Dawson_Creek' | 'America/Denver' | 'America/Detroit' | 'America/Dominica' | 'America/Edmonton' | 'America/Eirunepe' | 'America/El_Salvador' | 'America/Ensenada' | 'America/Fort_Wayne' | 'America/Fortaleza' | 'America/Glace_Bay' | 'America/Godthab' | 'America/Goose_Bay' | 'America/Grand_Turk' | 'America/Grenada' | 'America/Guadeloupe' | 'America/Guatemala' | 'America/Guayaquil' | 'America/Guyana' | 'America/Halifax' | 'America/Havana' | 'America/Hermosillo' | 'America/Indiana/Indianapolis' | 'America/Indiana/Knox' | 'America/Indiana/Marengo' | 'America/Indiana/Petersburg' | 'America/Indiana/Tell_City' | 'America/Indiana/Vevay' | 'America/Indiana/Vincennes' | 'America/Indiana/Winamac' | 'America/Indianapolis' | 'America/Inuvik' | 'America/Iqaluit' | 'America/Jamaica' | 'America/Jujuy' | 'America/Juneau' | 'America/Kentucky/Louisville' | 'America/Kentucky/Monticello' | 'America/Knox_IN' | 'America/Kralendijk' | 'America/La_Paz' | 'America/Lima' | 'America/Los_Angeles' | 'America/Louisville' | 'America/Lower_Princes' | 'America/Maceio' | 'America/Managua' | 'America/Manaus' | 'America/Marigot' | 'America/Martinique' | 'America/Matamoros' | 'America/Mazatlan' | 'America/Mendoza' | 'America/Menominee' | 'America/Merida' | 'America/Metlakatla' | 'America/Mexico_City' | 'America/Miquelon' | 'America/Moncton' | 'America/Monterrey' | 'America/Montevideo' | 'America/Montreal' | 'America/Montserrat' | 'America/Nassau' | 'America/New_York' | 'America/Nipigon' | 'America/Nome' | 'America/Noronha' | 'America/North_Dakota/Beulah' | 'America/North_Dakota/Center' | 'America/North_Dakota/New_Salem' | 'America/Ojinaga' | 'America/Panama' | 'America/Pangnirtung' | 'America/Paramaribo' | 'America/Phoenix' | 'America/Port-au-Prince' | 'America/Port_of_Spain' | 'America/Porto_Acre' | 'America/Porto_Velho' | 'America/Puerto_Rico' | 'America/Rainy_River' | 'America/Rankin_Inlet' | 'America/Recife' | 'America/Regina' | 'America/Resolute' | 'America/Rio_Branco' | 'America/Rosario' | 'America/Santa_Isabel' | 'America/Santarem' | 'America/Santiago' | 'America/Santo_Domingo' | 'America/Sao_Paulo' | 'America/Scoresbysund' | 'America/Shiprock' | 'America/Sitka' | 'America/St_Barthelemy' | 'America/St_Johns' | 'America/St_Kitts' | 'America/St_Lucia' | 'America/St_Thomas' | 'America/St_Vincent' | 'America/Swift_Current' | 'America/Tegucigalpa' | 'America/Thule' | 'America/Thunder_Bay' | 'America/Tijuana' | 'America/Toronto' | 'America/Tortola' | 'America/Vancouver' | 'America/Virgin' | 'America/Whitehorse' | 'America/Winnipeg' | 'America/Yakutat' | 'America/Yellowknife' | 'Antarctica/Casey' | 'Antarctica/Davis' | 'Antarctica/DumontDUrville' | 'Antarctica/Macquarie' | 'Antarctica/Mawson' | 'Antarctica/McMurdo' | 'Antarctica/Palmer' | 'Antarctica/Rothera' | 'Antarctica/South_Pole' | 'Antarctica/Syowa' | 'Antarctica/Troll' | 'Antarctica/Vostok' | 'Arctic/Longyearbyen' | 'Asia/Aden' | 'Asia/Almaty' | 'Asia/Amman' | 'Asia/Anadyr' | 'Asia/Aqtau' | 'Asia/Aqtobe' | 'Asia/Ashgabat' | 'Asia/Ashkhabad' | 'Asia/Baghdad' | 'Asia/Bahrain' | 'Asia/Baku' | 'Asia/Bangkok' | 'Asia/Beirut' | 'Asia/Bishkek' | 'Asia/Brunei' | 'Asia/Calcutta' | 'Asia/Chita' | 'Asia/Choibalsan' | 'Asia/Chongqing' | 'Asia/Chungking' | 'Asia/Colombo' | 'Asia/Dacca' | 'Asia/Damascus' | 'Asia/Dhaka' | 'Asia/Dili' | 'Asia/Dubai' | 'Asia/Dushanbe' | 'Asia/Gaza' | 'Asia/Harbin' | 'Asia/Hebron' | 'Asia/Ho_Chi_Minh' | 'Asia/Hong_Kong' | 'Asia/Hovd' | 'Asia/Irkutsk' | 'Asia/Istanbul' | 'Asia/Jakarta' | 'Asia/Jayapura' | 'Asia/Jerusalem' | 'Asia/Kabul' | 'Asia/Kamchatka' | 'Asia/Karachi' | 'Asia/Kashgar' | 'Asia/Kathmandu' | 'Asia/Katmandu' | 'Asia/Khandyga' | 'Asia/Kolkata' | 'Asia/Krasnoyarsk' | 'Asia/Kuala_Lumpur' | 'Asia/Kuching' | 'Asia/Kuwait' | 'Asia/Macao' | 'Asia/Macau' | 'Asia/Magadan' | 'Asia/Makassar' | 'Asia/Manila' | 'Asia/Muscat' | 'Asia/Nicosia' | 'Asia/Novokuznetsk' | 'Asia/Novosibirsk' | 'Asia/Omsk' | 'Asia/Oral' | 'Asia/Phnom_Penh' | 'Asia/Pontianak' | 'Asia/Pyongyang' | 'Asia/Qatar' | 'Asia/Qyzylorda' | 'Asia/Rangoon' | 'Asia/Riyadh' | 'Asia/Saigon' | 'Asia/Sakhalin' | 'Asia/Samarkand' | 'Asia/Seoul' | 'Asia/Shanghai' | 'Asia/Singapore' | 'Asia/Srednekolymsk' | 'Asia/Taipei' | 'Asia/Tashkent' | 'Asia/Tbilisi' | 'Asia/Tehran' | 'Asia/Tel_Aviv' | 'Asia/Thimbu' | 'Asia/Thimphu' | 'Asia/Tokyo' | 'Asia/Ujung_Pandang' | 'Asia/Ulaanbaatar' | 'Asia/Ulan_Bator' | 'Asia/Urumqi' | 'Asia/Ust-Nera' | 'Asia/Vientiane' | 'Asia/Vladivostok' | 'Asia/Yakutsk' | 'Asia/Yekaterinburg' | 'Asia/Yerevan' | 'Atlantic/Azores' | 'Atlantic/Bermuda' | 'Atlantic/Canary' | 'Atlantic/Cape_Verde' | 'Atlantic/Faeroe' | 'Atlantic/Faroe' | 'Atlantic/Jan_Mayen' | 'Atlantic/Madeira' | 'Atlantic/Reykjavik' | 'Atlantic/South_Georgia' | 'Atlantic/St_Helena' | 'Atlantic/Stanley' | 'Australia/ACT' | 'Australia/Adelaide' | 'Australia/Brisbane' | 'Australia/Broken_Hill' | 'Australia/Canberra' | 'Australia/Currie' | 'Australia/Darwin' | 'Australia/Eucla' | 'Australia/Hobart' | 'Australia/LHI' | 'Australia/Lindeman' | 'Australia/Lord_Howe' | 'Australia/Melbourne' | 'Australia/NSW' | 'Australia/North' | 'Australia/Perth' | 'Australia/Queensland' | 'Australia/South' | 'Australia/Sydney' | 'Australia/Tasmania' | 'Australia/Victoria' | 'Australia/West' | 'Australia/Yancowinna' | 'Brazil/Acre' | 'Brazil/DeNoronha' | 'Brazil/East' | 'Brazil/West' | 'Canada/Atlantic' | 'Canada/Central' | 'Canada/East-Saskatchewan' | 'Canada/Eastern' | 'Canada/Mountain' | 'Canada/Newfoundland' | 'Canada/Pacific' | 'Canada/Saskatchewan' | 'Canada/Yukon' | 'Chile/Continental' | 'Chile/EasterIsland' | 'Etc/GMT' | 'Etc/GMT+0' | 'Etc/GMT+1' | 'Etc/GMT+10' | 'Etc/GMT+11' | 'Etc/GMT+12' | 'Etc/GMT+2' | 'Etc/GMT+3' | 'Etc/GMT+4' | 'Etc/GMT+5' | 'Etc/GMT+6' | 'Etc/GMT+7' | 'Etc/GMT+8' | 'Etc/GMT+9' | 'Etc/GMT-0' | 'Etc/GMT-1' | 'Etc/GMT-10' | 'Etc/GMT-11' | 'Etc/GMT-12' | 'Etc/GMT-13' | 'Etc/GMT-14' | 'Etc/GMT-2' | 'Etc/GMT-3' | 'Etc/GMT-4' | 'Etc/GMT-5' | 'Etc/GMT-6' | 'Etc/GMT-7' | 'Etc/GMT-8' | 'Etc/GMT-9' | 'Etc/GMT0' | 'Etc/Greenwich' | 'Etc/UCT' | 'Etc/UTC' | 'Etc/Universal' | 'Etc/Zulu' | 'Europe/Amsterdam' | 'Europe/Andorra' | 'Europe/Athens' | 'Europe/Belfast' | 'Europe/Belgrade' | 'Europe/Berlin' | 'Europe/Bratislava' | 'Europe/Brussels' | 'Europe/Bucharest' | 'Europe/Budapest' | 'Europe/Busingen' | 'Europe/Chisinau' | 'Europe/Copenhagen' | 'Europe/Dublin' | 'Europe/Gibraltar' | 'Europe/Guernsey' | 'Europe/Helsinki' | 'Europe/Isle_of_Man' | 'Europe/Istanbul' | 'Europe/Jersey' | 'Europe/Kaliningrad' | 'Europe/Kiev' | 'Europe/Lisbon' | 'Europe/Ljubljana' | 'Europe/London' | 'Europe/Luxembourg' | 'Europe/Madrid' | 'Europe/Malta' | 'Europe/Mariehamn' | 'Europe/Minsk' | 'Europe/Monaco' | 'Europe/Moscow' | 'Europe/Nicosia' | 'Europe/Oslo' | 'Europe/Paris' | 'Europe/Podgorica' | 'Europe/Prague' | 'Europe/Riga' | 'Europe/Rome' | 'Europe/Samara' | 'Europe/San_Marino' | 'Europe/Sarajevo' | 'Europe/Simferopol' | 'Europe/Skopje' | 'Europe/Sofia' | 'Europe/Stockholm' | 'Europe/Tallinn' | 'Europe/Tirane' | 'Europe/Tiraspol' | 'Europe/Uzhgorod' | 'Europe/Vaduz' | 'Europe/Vatican' | 'Europe/Vienna' | 'Europe/Vilnius' | 'Europe/Volgograd' | 'Europe/Warsaw' | 'Europe/Zagreb' | 'Europe/Zaporozhye' | 'Europe/Zurich' | 'Indian/Antananarivo' | 'Indian/Chagos' | 'Indian/Christmas' | 'Indian/Cocos' | 'Indian/Comoro' | 'Indian/Kerguelen' | 'Indian/Mahe' | 'Indian/Maldives' | 'Indian/Mauritius' | 'Indian/Mayotte' | 'Indian/Reunion' | 'Mexico/BajaNorte' | 'Mexico/BajaSur' | 'Mexico/General' | 'Pacific/Apia' | 'Pacific/Auckland' | 'Pacific/Chatham' | 'Pacific/Chuuk' | 'Pacific/Easter' | 'Pacific/Efate' | 'Pacific/Enderbury' | 'Pacific/Fakaofo' | 'Pacific/Fiji' | 'Pacific/Funafuti' | 'Pacific/Galapagos' | 'Pacific/Gambier' | 'Pacific/Guadalcanal' | 'Pacific/Guam' | 'Pacific/Honolulu' | 'Pacific/Johnston' | 'Pacific/Kiritimati' | 'Pacific/Kosrae' | 'Pacific/Kwajalein' | 'Pacific/Majuro' | 'Pacific/Marquesas' | 'Pacific/Midway' | 'Pacific/Nauru' | 'Pacific/Niue' | 'Pacific/Norfolk' | 'Pacific/Noumea' | 'Pacific/Pago_Pago' | 'Pacific/Palau' | 'Pacific/Pitcairn' | 'Pacific/Pohnpei' | 'Pacific/Ponape' | 'Pacific/Port_Moresby' | 'Pacific/Rarotonga' | 'Pacific/Saipan' | 'Pacific/Samoa' | 'Pacific/Tahiti' | 'Pacific/Tarawa' | 'Pacific/Tongatapu' | 'Pacific/Truk' | 'Pacific/Wake' | 'Pacific/Wallis' | 'Pacific/Yap'} [timeZone] Time Zone by which to aggregate the results.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to the beginning of the current month.
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to midnight tonight.
         * @param {Array<'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure'>} [types] An array containing specific balance transaction types. The data will be filtered to include only transactions with a matching type property.
         * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalanceTransactionsSummary(tilledAccount: string, timeUnit?: 'day' | 'month', timeZone?: 'Africa/Abidjan' | 'Africa/Accra' | 'Africa/Addis_Ababa' | 'Africa/Algiers' | 'Africa/Asmara' | 'Africa/Asmera' | 'Africa/Bamako' | 'Africa/Bangui' | 'Africa/Banjul' | 'Africa/Bissau' | 'Africa/Blantyre' | 'Africa/Brazzaville' | 'Africa/Bujumbura' | 'Africa/Cairo' | 'Africa/Casablanca' | 'Africa/Ceuta' | 'Africa/Conakry' | 'Africa/Dakar' | 'Africa/Dar_es_Salaam' | 'Africa/Djibouti' | 'Africa/Douala' | 'Africa/El_Aaiun' | 'Africa/Freetown' | 'Africa/Gaborone' | 'Africa/Harare' | 'Africa/Johannesburg' | 'Africa/Juba' | 'Africa/Kampala' | 'Africa/Khartoum' | 'Africa/Kigali' | 'Africa/Kinshasa' | 'Africa/Lagos' | 'Africa/Libreville' | 'Africa/Lome' | 'Africa/Luanda' | 'Africa/Lubumbashi' | 'Africa/Lusaka' | 'Africa/Malabo' | 'Africa/Maputo' | 'Africa/Maseru' | 'Africa/Mbabane' | 'Africa/Mogadishu' | 'Africa/Monrovia' | 'Africa/Nairobi' | 'Africa/Ndjamena' | 'Africa/Niamey' | 'Africa/Nouakchott' | 'Africa/Ouagadougou' | 'Africa/Porto-Novo' | 'Africa/Sao_Tome' | 'Africa/Timbuktu' | 'Africa/Tripoli' | 'Africa/Tunis' | 'Africa/Windhoek' | 'America/Adak' | 'America/Anchorage' | 'America/Anguilla' | 'America/Antigua' | 'America/Araguaina' | 'America/Argentina/Buenos_Aires' | 'America/Argentina/Catamarca' | 'America/Argentina/ComodRivadavia' | 'America/Argentina/Cordoba' | 'America/Argentina/Jujuy' | 'America/Argentina/La_Rioja' | 'America/Argentina/Mendoza' | 'America/Argentina/Rio_Gallegos' | 'America/Argentina/Salta' | 'America/Argentina/San_Juan' | 'America/Argentina/San_Luis' | 'America/Argentina/Tucuman' | 'America/Argentina/Ushuaia' | 'America/Aruba' | 'America/Asuncion' | 'America/Atikokan' | 'America/Atka' | 'America/Bahia' | 'America/Bahia_Banderas' | 'America/Barbados' | 'America/Belem' | 'America/Belize' | 'America/Blanc-Sablon' | 'America/Boa_Vista' | 'America/Bogota' | 'America/Boise' | 'America/Buenos_Aires' | 'America/Cambridge_Bay' | 'America/Campo_Grande' | 'America/Cancun' | 'America/Caracas' | 'America/Catamarca' | 'America/Cayenne' | 'America/Cayman' | 'America/Chicago' | 'America/Chihuahua' | 'America/Coral_Harbour' | 'America/Cordoba' | 'America/Costa_Rica' | 'America/Creston' | 'America/Cuiaba' | 'America/Curacao' | 'America/Danmarkshavn' | 'America/Dawson' | 'America/Dawson_Creek' | 'America/Denver' | 'America/Detroit' | 'America/Dominica' | 'America/Edmonton' | 'America/Eirunepe' | 'America/El_Salvador' | 'America/Ensenada' | 'America/Fort_Wayne' | 'America/Fortaleza' | 'America/Glace_Bay' | 'America/Godthab' | 'America/Goose_Bay' | 'America/Grand_Turk' | 'America/Grenada' | 'America/Guadeloupe' | 'America/Guatemala' | 'America/Guayaquil' | 'America/Guyana' | 'America/Halifax' | 'America/Havana' | 'America/Hermosillo' | 'America/Indiana/Indianapolis' | 'America/Indiana/Knox' | 'America/Indiana/Marengo' | 'America/Indiana/Petersburg' | 'America/Indiana/Tell_City' | 'America/Indiana/Vevay' | 'America/Indiana/Vincennes' | 'America/Indiana/Winamac' | 'America/Indianapolis' | 'America/Inuvik' | 'America/Iqaluit' | 'America/Jamaica' | 'America/Jujuy' | 'America/Juneau' | 'America/Kentucky/Louisville' | 'America/Kentucky/Monticello' | 'America/Knox_IN' | 'America/Kralendijk' | 'America/La_Paz' | 'America/Lima' | 'America/Los_Angeles' | 'America/Louisville' | 'America/Lower_Princes' | 'America/Maceio' | 'America/Managua' | 'America/Manaus' | 'America/Marigot' | 'America/Martinique' | 'America/Matamoros' | 'America/Mazatlan' | 'America/Mendoza' | 'America/Menominee' | 'America/Merida' | 'America/Metlakatla' | 'America/Mexico_City' | 'America/Miquelon' | 'America/Moncton' | 'America/Monterrey' | 'America/Montevideo' | 'America/Montreal' | 'America/Montserrat' | 'America/Nassau' | 'America/New_York' | 'America/Nipigon' | 'America/Nome' | 'America/Noronha' | 'America/North_Dakota/Beulah' | 'America/North_Dakota/Center' | 'America/North_Dakota/New_Salem' | 'America/Ojinaga' | 'America/Panama' | 'America/Pangnirtung' | 'America/Paramaribo' | 'America/Phoenix' | 'America/Port-au-Prince' | 'America/Port_of_Spain' | 'America/Porto_Acre' | 'America/Porto_Velho' | 'America/Puerto_Rico' | 'America/Rainy_River' | 'America/Rankin_Inlet' | 'America/Recife' | 'America/Regina' | 'America/Resolute' | 'America/Rio_Branco' | 'America/Rosario' | 'America/Santa_Isabel' | 'America/Santarem' | 'America/Santiago' | 'America/Santo_Domingo' | 'America/Sao_Paulo' | 'America/Scoresbysund' | 'America/Shiprock' | 'America/Sitka' | 'America/St_Barthelemy' | 'America/St_Johns' | 'America/St_Kitts' | 'America/St_Lucia' | 'America/St_Thomas' | 'America/St_Vincent' | 'America/Swift_Current' | 'America/Tegucigalpa' | 'America/Thule' | 'America/Thunder_Bay' | 'America/Tijuana' | 'America/Toronto' | 'America/Tortola' | 'America/Vancouver' | 'America/Virgin' | 'America/Whitehorse' | 'America/Winnipeg' | 'America/Yakutat' | 'America/Yellowknife' | 'Antarctica/Casey' | 'Antarctica/Davis' | 'Antarctica/DumontDUrville' | 'Antarctica/Macquarie' | 'Antarctica/Mawson' | 'Antarctica/McMurdo' | 'Antarctica/Palmer' | 'Antarctica/Rothera' | 'Antarctica/South_Pole' | 'Antarctica/Syowa' | 'Antarctica/Troll' | 'Antarctica/Vostok' | 'Arctic/Longyearbyen' | 'Asia/Aden' | 'Asia/Almaty' | 'Asia/Amman' | 'Asia/Anadyr' | 'Asia/Aqtau' | 'Asia/Aqtobe' | 'Asia/Ashgabat' | 'Asia/Ashkhabad' | 'Asia/Baghdad' | 'Asia/Bahrain' | 'Asia/Baku' | 'Asia/Bangkok' | 'Asia/Beirut' | 'Asia/Bishkek' | 'Asia/Brunei' | 'Asia/Calcutta' | 'Asia/Chita' | 'Asia/Choibalsan' | 'Asia/Chongqing' | 'Asia/Chungking' | 'Asia/Colombo' | 'Asia/Dacca' | 'Asia/Damascus' | 'Asia/Dhaka' | 'Asia/Dili' | 'Asia/Dubai' | 'Asia/Dushanbe' | 'Asia/Gaza' | 'Asia/Harbin' | 'Asia/Hebron' | 'Asia/Ho_Chi_Minh' | 'Asia/Hong_Kong' | 'Asia/Hovd' | 'Asia/Irkutsk' | 'Asia/Istanbul' | 'Asia/Jakarta' | 'Asia/Jayapura' | 'Asia/Jerusalem' | 'Asia/Kabul' | 'Asia/Kamchatka' | 'Asia/Karachi' | 'Asia/Kashgar' | 'Asia/Kathmandu' | 'Asia/Katmandu' | 'Asia/Khandyga' | 'Asia/Kolkata' | 'Asia/Krasnoyarsk' | 'Asia/Kuala_Lumpur' | 'Asia/Kuching' | 'Asia/Kuwait' | 'Asia/Macao' | 'Asia/Macau' | 'Asia/Magadan' | 'Asia/Makassar' | 'Asia/Manila' | 'Asia/Muscat' | 'Asia/Nicosia' | 'Asia/Novokuznetsk' | 'Asia/Novosibirsk' | 'Asia/Omsk' | 'Asia/Oral' | 'Asia/Phnom_Penh' | 'Asia/Pontianak' | 'Asia/Pyongyang' | 'Asia/Qatar' | 'Asia/Qyzylorda' | 'Asia/Rangoon' | 'Asia/Riyadh' | 'Asia/Saigon' | 'Asia/Sakhalin' | 'Asia/Samarkand' | 'Asia/Seoul' | 'Asia/Shanghai' | 'Asia/Singapore' | 'Asia/Srednekolymsk' | 'Asia/Taipei' | 'Asia/Tashkent' | 'Asia/Tbilisi' | 'Asia/Tehran' | 'Asia/Tel_Aviv' | 'Asia/Thimbu' | 'Asia/Thimphu' | 'Asia/Tokyo' | 'Asia/Ujung_Pandang' | 'Asia/Ulaanbaatar' | 'Asia/Ulan_Bator' | 'Asia/Urumqi' | 'Asia/Ust-Nera' | 'Asia/Vientiane' | 'Asia/Vladivostok' | 'Asia/Yakutsk' | 'Asia/Yekaterinburg' | 'Asia/Yerevan' | 'Atlantic/Azores' | 'Atlantic/Bermuda' | 'Atlantic/Canary' | 'Atlantic/Cape_Verde' | 'Atlantic/Faeroe' | 'Atlantic/Faroe' | 'Atlantic/Jan_Mayen' | 'Atlantic/Madeira' | 'Atlantic/Reykjavik' | 'Atlantic/South_Georgia' | 'Atlantic/St_Helena' | 'Atlantic/Stanley' | 'Australia/ACT' | 'Australia/Adelaide' | 'Australia/Brisbane' | 'Australia/Broken_Hill' | 'Australia/Canberra' | 'Australia/Currie' | 'Australia/Darwin' | 'Australia/Eucla' | 'Australia/Hobart' | 'Australia/LHI' | 'Australia/Lindeman' | 'Australia/Lord_Howe' | 'Australia/Melbourne' | 'Australia/NSW' | 'Australia/North' | 'Australia/Perth' | 'Australia/Queensland' | 'Australia/South' | 'Australia/Sydney' | 'Australia/Tasmania' | 'Australia/Victoria' | 'Australia/West' | 'Australia/Yancowinna' | 'Brazil/Acre' | 'Brazil/DeNoronha' | 'Brazil/East' | 'Brazil/West' | 'Canada/Atlantic' | 'Canada/Central' | 'Canada/East-Saskatchewan' | 'Canada/Eastern' | 'Canada/Mountain' | 'Canada/Newfoundland' | 'Canada/Pacific' | 'Canada/Saskatchewan' | 'Canada/Yukon' | 'Chile/Continental' | 'Chile/EasterIsland' | 'Etc/GMT' | 'Etc/GMT+0' | 'Etc/GMT+1' | 'Etc/GMT+10' | 'Etc/GMT+11' | 'Etc/GMT+12' | 'Etc/GMT+2' | 'Etc/GMT+3' | 'Etc/GMT+4' | 'Etc/GMT+5' | 'Etc/GMT+6' | 'Etc/GMT+7' | 'Etc/GMT+8' | 'Etc/GMT+9' | 'Etc/GMT-0' | 'Etc/GMT-1' | 'Etc/GMT-10' | 'Etc/GMT-11' | 'Etc/GMT-12' | 'Etc/GMT-13' | 'Etc/GMT-14' | 'Etc/GMT-2' | 'Etc/GMT-3' | 'Etc/GMT-4' | 'Etc/GMT-5' | 'Etc/GMT-6' | 'Etc/GMT-7' | 'Etc/GMT-8' | 'Etc/GMT-9' | 'Etc/GMT0' | 'Etc/Greenwich' | 'Etc/UCT' | 'Etc/UTC' | 'Etc/Universal' | 'Etc/Zulu' | 'Europe/Amsterdam' | 'Europe/Andorra' | 'Europe/Athens' | 'Europe/Belfast' | 'Europe/Belgrade' | 'Europe/Berlin' | 'Europe/Bratislava' | 'Europe/Brussels' | 'Europe/Bucharest' | 'Europe/Budapest' | 'Europe/Busingen' | 'Europe/Chisinau' | 'Europe/Copenhagen' | 'Europe/Dublin' | 'Europe/Gibraltar' | 'Europe/Guernsey' | 'Europe/Helsinki' | 'Europe/Isle_of_Man' | 'Europe/Istanbul' | 'Europe/Jersey' | 'Europe/Kaliningrad' | 'Europe/Kiev' | 'Europe/Lisbon' | 'Europe/Ljubljana' | 'Europe/London' | 'Europe/Luxembourg' | 'Europe/Madrid' | 'Europe/Malta' | 'Europe/Mariehamn' | 'Europe/Minsk' | 'Europe/Monaco' | 'Europe/Moscow' | 'Europe/Nicosia' | 'Europe/Oslo' | 'Europe/Paris' | 'Europe/Podgorica' | 'Europe/Prague' | 'Europe/Riga' | 'Europe/Rome' | 'Europe/Samara' | 'Europe/San_Marino' | 'Europe/Sarajevo' | 'Europe/Simferopol' | 'Europe/Skopje' | 'Europe/Sofia' | 'Europe/Stockholm' | 'Europe/Tallinn' | 'Europe/Tirane' | 'Europe/Tiraspol' | 'Europe/Uzhgorod' | 'Europe/Vaduz' | 'Europe/Vatican' | 'Europe/Vienna' | 'Europe/Vilnius' | 'Europe/Volgograd' | 'Europe/Warsaw' | 'Europe/Zagreb' | 'Europe/Zaporozhye' | 'Europe/Zurich' | 'Indian/Antananarivo' | 'Indian/Chagos' | 'Indian/Christmas' | 'Indian/Cocos' | 'Indian/Comoro' | 'Indian/Kerguelen' | 'Indian/Mahe' | 'Indian/Maldives' | 'Indian/Mauritius' | 'Indian/Mayotte' | 'Indian/Reunion' | 'Mexico/BajaNorte' | 'Mexico/BajaSur' | 'Mexico/General' | 'Pacific/Apia' | 'Pacific/Auckland' | 'Pacific/Chatham' | 'Pacific/Chuuk' | 'Pacific/Easter' | 'Pacific/Efate' | 'Pacific/Enderbury' | 'Pacific/Fakaofo' | 'Pacific/Fiji' | 'Pacific/Funafuti' | 'Pacific/Galapagos' | 'Pacific/Gambier' | 'Pacific/Guadalcanal' | 'Pacific/Guam' | 'Pacific/Honolulu' | 'Pacific/Johnston' | 'Pacific/Kiritimati' | 'Pacific/Kosrae' | 'Pacific/Kwajalein' | 'Pacific/Majuro' | 'Pacific/Marquesas' | 'Pacific/Midway' | 'Pacific/Nauru' | 'Pacific/Niue' | 'Pacific/Norfolk' | 'Pacific/Noumea' | 'Pacific/Pago_Pago' | 'Pacific/Palau' | 'Pacific/Pitcairn' | 'Pacific/Pohnpei' | 'Pacific/Ponape' | 'Pacific/Port_Moresby' | 'Pacific/Rarotonga' | 'Pacific/Saipan' | 'Pacific/Samoa' | 'Pacific/Tahiti' | 'Pacific/Tarawa' | 'Pacific/Tongatapu' | 'Pacific/Truk' | 'Pacific/Wake' | 'Pacific/Wallis' | 'Pacific/Yap', createdAtGte?: string, createdAtLte?: string, types?: Array<'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure'>, includeConnectedAccounts?: boolean, options?: any): AxiosPromise<BalanceTransactionsSummary> {
            return localVarFp.getBalanceTransactionsSummary(tilledAccount, timeUnit, timeZone, createdAtGte, createdAtLte, types, includeConnectedAccounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of transactions that have contributed to the Tilled account balance (e.g. charges, refunds, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.
         * @summary List all balance transactions
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure'} [type] Only return transaction of the given type.
         * @param {string} [sourceId] Only returns the original transaction.
         * @param {string} [payoutId] Only returns transactions that were paid out on the specified payout ID.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalanceTransactions(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, type?: 'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure', sourceId?: string, payoutId?: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListBalanceTransactions200Response> {
            return localVarFp.listBalanceTransactions(tilledAccount, createdAtGte, createdAtLte, type, sourceId, payoutId, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalanceTransactionsApi - object-oriented interface
 * @export
 * @class BalanceTransactionsApi
 * @extends {BaseAPI}
 */
export class BalanceTransactionsApi extends BaseAPI {
    /**
     * Retrieves the balance transactioni with the given ID.
     * @summary Retrieve a balance transaction
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceTransactionsApi
     */
    public getBalanceTransaction(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return BalanceTransactionsApiFp(this.configuration).getBalanceTransaction(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a summary of transactions grouped by `time_unit`, `type`, and `currency`.
     * @summary Get balance transactions summary
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {'day' | 'month'} [timeUnit] String indicating the unit of time to aggregate the summary of data.
     * @param {'Africa/Abidjan' | 'Africa/Accra' | 'Africa/Addis_Ababa' | 'Africa/Algiers' | 'Africa/Asmara' | 'Africa/Asmera' | 'Africa/Bamako' | 'Africa/Bangui' | 'Africa/Banjul' | 'Africa/Bissau' | 'Africa/Blantyre' | 'Africa/Brazzaville' | 'Africa/Bujumbura' | 'Africa/Cairo' | 'Africa/Casablanca' | 'Africa/Ceuta' | 'Africa/Conakry' | 'Africa/Dakar' | 'Africa/Dar_es_Salaam' | 'Africa/Djibouti' | 'Africa/Douala' | 'Africa/El_Aaiun' | 'Africa/Freetown' | 'Africa/Gaborone' | 'Africa/Harare' | 'Africa/Johannesburg' | 'Africa/Juba' | 'Africa/Kampala' | 'Africa/Khartoum' | 'Africa/Kigali' | 'Africa/Kinshasa' | 'Africa/Lagos' | 'Africa/Libreville' | 'Africa/Lome' | 'Africa/Luanda' | 'Africa/Lubumbashi' | 'Africa/Lusaka' | 'Africa/Malabo' | 'Africa/Maputo' | 'Africa/Maseru' | 'Africa/Mbabane' | 'Africa/Mogadishu' | 'Africa/Monrovia' | 'Africa/Nairobi' | 'Africa/Ndjamena' | 'Africa/Niamey' | 'Africa/Nouakchott' | 'Africa/Ouagadougou' | 'Africa/Porto-Novo' | 'Africa/Sao_Tome' | 'Africa/Timbuktu' | 'Africa/Tripoli' | 'Africa/Tunis' | 'Africa/Windhoek' | 'America/Adak' | 'America/Anchorage' | 'America/Anguilla' | 'America/Antigua' | 'America/Araguaina' | 'America/Argentina/Buenos_Aires' | 'America/Argentina/Catamarca' | 'America/Argentina/ComodRivadavia' | 'America/Argentina/Cordoba' | 'America/Argentina/Jujuy' | 'America/Argentina/La_Rioja' | 'America/Argentina/Mendoza' | 'America/Argentina/Rio_Gallegos' | 'America/Argentina/Salta' | 'America/Argentina/San_Juan' | 'America/Argentina/San_Luis' | 'America/Argentina/Tucuman' | 'America/Argentina/Ushuaia' | 'America/Aruba' | 'America/Asuncion' | 'America/Atikokan' | 'America/Atka' | 'America/Bahia' | 'America/Bahia_Banderas' | 'America/Barbados' | 'America/Belem' | 'America/Belize' | 'America/Blanc-Sablon' | 'America/Boa_Vista' | 'America/Bogota' | 'America/Boise' | 'America/Buenos_Aires' | 'America/Cambridge_Bay' | 'America/Campo_Grande' | 'America/Cancun' | 'America/Caracas' | 'America/Catamarca' | 'America/Cayenne' | 'America/Cayman' | 'America/Chicago' | 'America/Chihuahua' | 'America/Coral_Harbour' | 'America/Cordoba' | 'America/Costa_Rica' | 'America/Creston' | 'America/Cuiaba' | 'America/Curacao' | 'America/Danmarkshavn' | 'America/Dawson' | 'America/Dawson_Creek' | 'America/Denver' | 'America/Detroit' | 'America/Dominica' | 'America/Edmonton' | 'America/Eirunepe' | 'America/El_Salvador' | 'America/Ensenada' | 'America/Fort_Wayne' | 'America/Fortaleza' | 'America/Glace_Bay' | 'America/Godthab' | 'America/Goose_Bay' | 'America/Grand_Turk' | 'America/Grenada' | 'America/Guadeloupe' | 'America/Guatemala' | 'America/Guayaquil' | 'America/Guyana' | 'America/Halifax' | 'America/Havana' | 'America/Hermosillo' | 'America/Indiana/Indianapolis' | 'America/Indiana/Knox' | 'America/Indiana/Marengo' | 'America/Indiana/Petersburg' | 'America/Indiana/Tell_City' | 'America/Indiana/Vevay' | 'America/Indiana/Vincennes' | 'America/Indiana/Winamac' | 'America/Indianapolis' | 'America/Inuvik' | 'America/Iqaluit' | 'America/Jamaica' | 'America/Jujuy' | 'America/Juneau' | 'America/Kentucky/Louisville' | 'America/Kentucky/Monticello' | 'America/Knox_IN' | 'America/Kralendijk' | 'America/La_Paz' | 'America/Lima' | 'America/Los_Angeles' | 'America/Louisville' | 'America/Lower_Princes' | 'America/Maceio' | 'America/Managua' | 'America/Manaus' | 'America/Marigot' | 'America/Martinique' | 'America/Matamoros' | 'America/Mazatlan' | 'America/Mendoza' | 'America/Menominee' | 'America/Merida' | 'America/Metlakatla' | 'America/Mexico_City' | 'America/Miquelon' | 'America/Moncton' | 'America/Monterrey' | 'America/Montevideo' | 'America/Montreal' | 'America/Montserrat' | 'America/Nassau' | 'America/New_York' | 'America/Nipigon' | 'America/Nome' | 'America/Noronha' | 'America/North_Dakota/Beulah' | 'America/North_Dakota/Center' | 'America/North_Dakota/New_Salem' | 'America/Ojinaga' | 'America/Panama' | 'America/Pangnirtung' | 'America/Paramaribo' | 'America/Phoenix' | 'America/Port-au-Prince' | 'America/Port_of_Spain' | 'America/Porto_Acre' | 'America/Porto_Velho' | 'America/Puerto_Rico' | 'America/Rainy_River' | 'America/Rankin_Inlet' | 'America/Recife' | 'America/Regina' | 'America/Resolute' | 'America/Rio_Branco' | 'America/Rosario' | 'America/Santa_Isabel' | 'America/Santarem' | 'America/Santiago' | 'America/Santo_Domingo' | 'America/Sao_Paulo' | 'America/Scoresbysund' | 'America/Shiprock' | 'America/Sitka' | 'America/St_Barthelemy' | 'America/St_Johns' | 'America/St_Kitts' | 'America/St_Lucia' | 'America/St_Thomas' | 'America/St_Vincent' | 'America/Swift_Current' | 'America/Tegucigalpa' | 'America/Thule' | 'America/Thunder_Bay' | 'America/Tijuana' | 'America/Toronto' | 'America/Tortola' | 'America/Vancouver' | 'America/Virgin' | 'America/Whitehorse' | 'America/Winnipeg' | 'America/Yakutat' | 'America/Yellowknife' | 'Antarctica/Casey' | 'Antarctica/Davis' | 'Antarctica/DumontDUrville' | 'Antarctica/Macquarie' | 'Antarctica/Mawson' | 'Antarctica/McMurdo' | 'Antarctica/Palmer' | 'Antarctica/Rothera' | 'Antarctica/South_Pole' | 'Antarctica/Syowa' | 'Antarctica/Troll' | 'Antarctica/Vostok' | 'Arctic/Longyearbyen' | 'Asia/Aden' | 'Asia/Almaty' | 'Asia/Amman' | 'Asia/Anadyr' | 'Asia/Aqtau' | 'Asia/Aqtobe' | 'Asia/Ashgabat' | 'Asia/Ashkhabad' | 'Asia/Baghdad' | 'Asia/Bahrain' | 'Asia/Baku' | 'Asia/Bangkok' | 'Asia/Beirut' | 'Asia/Bishkek' | 'Asia/Brunei' | 'Asia/Calcutta' | 'Asia/Chita' | 'Asia/Choibalsan' | 'Asia/Chongqing' | 'Asia/Chungking' | 'Asia/Colombo' | 'Asia/Dacca' | 'Asia/Damascus' | 'Asia/Dhaka' | 'Asia/Dili' | 'Asia/Dubai' | 'Asia/Dushanbe' | 'Asia/Gaza' | 'Asia/Harbin' | 'Asia/Hebron' | 'Asia/Ho_Chi_Minh' | 'Asia/Hong_Kong' | 'Asia/Hovd' | 'Asia/Irkutsk' | 'Asia/Istanbul' | 'Asia/Jakarta' | 'Asia/Jayapura' | 'Asia/Jerusalem' | 'Asia/Kabul' | 'Asia/Kamchatka' | 'Asia/Karachi' | 'Asia/Kashgar' | 'Asia/Kathmandu' | 'Asia/Katmandu' | 'Asia/Khandyga' | 'Asia/Kolkata' | 'Asia/Krasnoyarsk' | 'Asia/Kuala_Lumpur' | 'Asia/Kuching' | 'Asia/Kuwait' | 'Asia/Macao' | 'Asia/Macau' | 'Asia/Magadan' | 'Asia/Makassar' | 'Asia/Manila' | 'Asia/Muscat' | 'Asia/Nicosia' | 'Asia/Novokuznetsk' | 'Asia/Novosibirsk' | 'Asia/Omsk' | 'Asia/Oral' | 'Asia/Phnom_Penh' | 'Asia/Pontianak' | 'Asia/Pyongyang' | 'Asia/Qatar' | 'Asia/Qyzylorda' | 'Asia/Rangoon' | 'Asia/Riyadh' | 'Asia/Saigon' | 'Asia/Sakhalin' | 'Asia/Samarkand' | 'Asia/Seoul' | 'Asia/Shanghai' | 'Asia/Singapore' | 'Asia/Srednekolymsk' | 'Asia/Taipei' | 'Asia/Tashkent' | 'Asia/Tbilisi' | 'Asia/Tehran' | 'Asia/Tel_Aviv' | 'Asia/Thimbu' | 'Asia/Thimphu' | 'Asia/Tokyo' | 'Asia/Ujung_Pandang' | 'Asia/Ulaanbaatar' | 'Asia/Ulan_Bator' | 'Asia/Urumqi' | 'Asia/Ust-Nera' | 'Asia/Vientiane' | 'Asia/Vladivostok' | 'Asia/Yakutsk' | 'Asia/Yekaterinburg' | 'Asia/Yerevan' | 'Atlantic/Azores' | 'Atlantic/Bermuda' | 'Atlantic/Canary' | 'Atlantic/Cape_Verde' | 'Atlantic/Faeroe' | 'Atlantic/Faroe' | 'Atlantic/Jan_Mayen' | 'Atlantic/Madeira' | 'Atlantic/Reykjavik' | 'Atlantic/South_Georgia' | 'Atlantic/St_Helena' | 'Atlantic/Stanley' | 'Australia/ACT' | 'Australia/Adelaide' | 'Australia/Brisbane' | 'Australia/Broken_Hill' | 'Australia/Canberra' | 'Australia/Currie' | 'Australia/Darwin' | 'Australia/Eucla' | 'Australia/Hobart' | 'Australia/LHI' | 'Australia/Lindeman' | 'Australia/Lord_Howe' | 'Australia/Melbourne' | 'Australia/NSW' | 'Australia/North' | 'Australia/Perth' | 'Australia/Queensland' | 'Australia/South' | 'Australia/Sydney' | 'Australia/Tasmania' | 'Australia/Victoria' | 'Australia/West' | 'Australia/Yancowinna' | 'Brazil/Acre' | 'Brazil/DeNoronha' | 'Brazil/East' | 'Brazil/West' | 'Canada/Atlantic' | 'Canada/Central' | 'Canada/East-Saskatchewan' | 'Canada/Eastern' | 'Canada/Mountain' | 'Canada/Newfoundland' | 'Canada/Pacific' | 'Canada/Saskatchewan' | 'Canada/Yukon' | 'Chile/Continental' | 'Chile/EasterIsland' | 'Etc/GMT' | 'Etc/GMT+0' | 'Etc/GMT+1' | 'Etc/GMT+10' | 'Etc/GMT+11' | 'Etc/GMT+12' | 'Etc/GMT+2' | 'Etc/GMT+3' | 'Etc/GMT+4' | 'Etc/GMT+5' | 'Etc/GMT+6' | 'Etc/GMT+7' | 'Etc/GMT+8' | 'Etc/GMT+9' | 'Etc/GMT-0' | 'Etc/GMT-1' | 'Etc/GMT-10' | 'Etc/GMT-11' | 'Etc/GMT-12' | 'Etc/GMT-13' | 'Etc/GMT-14' | 'Etc/GMT-2' | 'Etc/GMT-3' | 'Etc/GMT-4' | 'Etc/GMT-5' | 'Etc/GMT-6' | 'Etc/GMT-7' | 'Etc/GMT-8' | 'Etc/GMT-9' | 'Etc/GMT0' | 'Etc/Greenwich' | 'Etc/UCT' | 'Etc/UTC' | 'Etc/Universal' | 'Etc/Zulu' | 'Europe/Amsterdam' | 'Europe/Andorra' | 'Europe/Athens' | 'Europe/Belfast' | 'Europe/Belgrade' | 'Europe/Berlin' | 'Europe/Bratislava' | 'Europe/Brussels' | 'Europe/Bucharest' | 'Europe/Budapest' | 'Europe/Busingen' | 'Europe/Chisinau' | 'Europe/Copenhagen' | 'Europe/Dublin' | 'Europe/Gibraltar' | 'Europe/Guernsey' | 'Europe/Helsinki' | 'Europe/Isle_of_Man' | 'Europe/Istanbul' | 'Europe/Jersey' | 'Europe/Kaliningrad' | 'Europe/Kiev' | 'Europe/Lisbon' | 'Europe/Ljubljana' | 'Europe/London' | 'Europe/Luxembourg' | 'Europe/Madrid' | 'Europe/Malta' | 'Europe/Mariehamn' | 'Europe/Minsk' | 'Europe/Monaco' | 'Europe/Moscow' | 'Europe/Nicosia' | 'Europe/Oslo' | 'Europe/Paris' | 'Europe/Podgorica' | 'Europe/Prague' | 'Europe/Riga' | 'Europe/Rome' | 'Europe/Samara' | 'Europe/San_Marino' | 'Europe/Sarajevo' | 'Europe/Simferopol' | 'Europe/Skopje' | 'Europe/Sofia' | 'Europe/Stockholm' | 'Europe/Tallinn' | 'Europe/Tirane' | 'Europe/Tiraspol' | 'Europe/Uzhgorod' | 'Europe/Vaduz' | 'Europe/Vatican' | 'Europe/Vienna' | 'Europe/Vilnius' | 'Europe/Volgograd' | 'Europe/Warsaw' | 'Europe/Zagreb' | 'Europe/Zaporozhye' | 'Europe/Zurich' | 'Indian/Antananarivo' | 'Indian/Chagos' | 'Indian/Christmas' | 'Indian/Cocos' | 'Indian/Comoro' | 'Indian/Kerguelen' | 'Indian/Mahe' | 'Indian/Maldives' | 'Indian/Mauritius' | 'Indian/Mayotte' | 'Indian/Reunion' | 'Mexico/BajaNorte' | 'Mexico/BajaSur' | 'Mexico/General' | 'Pacific/Apia' | 'Pacific/Auckland' | 'Pacific/Chatham' | 'Pacific/Chuuk' | 'Pacific/Easter' | 'Pacific/Efate' | 'Pacific/Enderbury' | 'Pacific/Fakaofo' | 'Pacific/Fiji' | 'Pacific/Funafuti' | 'Pacific/Galapagos' | 'Pacific/Gambier' | 'Pacific/Guadalcanal' | 'Pacific/Guam' | 'Pacific/Honolulu' | 'Pacific/Johnston' | 'Pacific/Kiritimati' | 'Pacific/Kosrae' | 'Pacific/Kwajalein' | 'Pacific/Majuro' | 'Pacific/Marquesas' | 'Pacific/Midway' | 'Pacific/Nauru' | 'Pacific/Niue' | 'Pacific/Norfolk' | 'Pacific/Noumea' | 'Pacific/Pago_Pago' | 'Pacific/Palau' | 'Pacific/Pitcairn' | 'Pacific/Pohnpei' | 'Pacific/Ponape' | 'Pacific/Port_Moresby' | 'Pacific/Rarotonga' | 'Pacific/Saipan' | 'Pacific/Samoa' | 'Pacific/Tahiti' | 'Pacific/Tarawa' | 'Pacific/Tongatapu' | 'Pacific/Truk' | 'Pacific/Wake' | 'Pacific/Wallis' | 'Pacific/Yap'} [timeZone] Time Zone by which to aggregate the results.
     * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to the beginning of the current month.
     * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to midnight tonight.
     * @param {Array<'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure'>} [types] An array containing specific balance transaction types. The data will be filtered to include only transactions with a matching type property.
     * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceTransactionsApi
     */
    public getBalanceTransactionsSummary(tilledAccount: string, timeUnit?: 'day' | 'month', timeZone?: 'Africa/Abidjan' | 'Africa/Accra' | 'Africa/Addis_Ababa' | 'Africa/Algiers' | 'Africa/Asmara' | 'Africa/Asmera' | 'Africa/Bamako' | 'Africa/Bangui' | 'Africa/Banjul' | 'Africa/Bissau' | 'Africa/Blantyre' | 'Africa/Brazzaville' | 'Africa/Bujumbura' | 'Africa/Cairo' | 'Africa/Casablanca' | 'Africa/Ceuta' | 'Africa/Conakry' | 'Africa/Dakar' | 'Africa/Dar_es_Salaam' | 'Africa/Djibouti' | 'Africa/Douala' | 'Africa/El_Aaiun' | 'Africa/Freetown' | 'Africa/Gaborone' | 'Africa/Harare' | 'Africa/Johannesburg' | 'Africa/Juba' | 'Africa/Kampala' | 'Africa/Khartoum' | 'Africa/Kigali' | 'Africa/Kinshasa' | 'Africa/Lagos' | 'Africa/Libreville' | 'Africa/Lome' | 'Africa/Luanda' | 'Africa/Lubumbashi' | 'Africa/Lusaka' | 'Africa/Malabo' | 'Africa/Maputo' | 'Africa/Maseru' | 'Africa/Mbabane' | 'Africa/Mogadishu' | 'Africa/Monrovia' | 'Africa/Nairobi' | 'Africa/Ndjamena' | 'Africa/Niamey' | 'Africa/Nouakchott' | 'Africa/Ouagadougou' | 'Africa/Porto-Novo' | 'Africa/Sao_Tome' | 'Africa/Timbuktu' | 'Africa/Tripoli' | 'Africa/Tunis' | 'Africa/Windhoek' | 'America/Adak' | 'America/Anchorage' | 'America/Anguilla' | 'America/Antigua' | 'America/Araguaina' | 'America/Argentina/Buenos_Aires' | 'America/Argentina/Catamarca' | 'America/Argentina/ComodRivadavia' | 'America/Argentina/Cordoba' | 'America/Argentina/Jujuy' | 'America/Argentina/La_Rioja' | 'America/Argentina/Mendoza' | 'America/Argentina/Rio_Gallegos' | 'America/Argentina/Salta' | 'America/Argentina/San_Juan' | 'America/Argentina/San_Luis' | 'America/Argentina/Tucuman' | 'America/Argentina/Ushuaia' | 'America/Aruba' | 'America/Asuncion' | 'America/Atikokan' | 'America/Atka' | 'America/Bahia' | 'America/Bahia_Banderas' | 'America/Barbados' | 'America/Belem' | 'America/Belize' | 'America/Blanc-Sablon' | 'America/Boa_Vista' | 'America/Bogota' | 'America/Boise' | 'America/Buenos_Aires' | 'America/Cambridge_Bay' | 'America/Campo_Grande' | 'America/Cancun' | 'America/Caracas' | 'America/Catamarca' | 'America/Cayenne' | 'America/Cayman' | 'America/Chicago' | 'America/Chihuahua' | 'America/Coral_Harbour' | 'America/Cordoba' | 'America/Costa_Rica' | 'America/Creston' | 'America/Cuiaba' | 'America/Curacao' | 'America/Danmarkshavn' | 'America/Dawson' | 'America/Dawson_Creek' | 'America/Denver' | 'America/Detroit' | 'America/Dominica' | 'America/Edmonton' | 'America/Eirunepe' | 'America/El_Salvador' | 'America/Ensenada' | 'America/Fort_Wayne' | 'America/Fortaleza' | 'America/Glace_Bay' | 'America/Godthab' | 'America/Goose_Bay' | 'America/Grand_Turk' | 'America/Grenada' | 'America/Guadeloupe' | 'America/Guatemala' | 'America/Guayaquil' | 'America/Guyana' | 'America/Halifax' | 'America/Havana' | 'America/Hermosillo' | 'America/Indiana/Indianapolis' | 'America/Indiana/Knox' | 'America/Indiana/Marengo' | 'America/Indiana/Petersburg' | 'America/Indiana/Tell_City' | 'America/Indiana/Vevay' | 'America/Indiana/Vincennes' | 'America/Indiana/Winamac' | 'America/Indianapolis' | 'America/Inuvik' | 'America/Iqaluit' | 'America/Jamaica' | 'America/Jujuy' | 'America/Juneau' | 'America/Kentucky/Louisville' | 'America/Kentucky/Monticello' | 'America/Knox_IN' | 'America/Kralendijk' | 'America/La_Paz' | 'America/Lima' | 'America/Los_Angeles' | 'America/Louisville' | 'America/Lower_Princes' | 'America/Maceio' | 'America/Managua' | 'America/Manaus' | 'America/Marigot' | 'America/Martinique' | 'America/Matamoros' | 'America/Mazatlan' | 'America/Mendoza' | 'America/Menominee' | 'America/Merida' | 'America/Metlakatla' | 'America/Mexico_City' | 'America/Miquelon' | 'America/Moncton' | 'America/Monterrey' | 'America/Montevideo' | 'America/Montreal' | 'America/Montserrat' | 'America/Nassau' | 'America/New_York' | 'America/Nipigon' | 'America/Nome' | 'America/Noronha' | 'America/North_Dakota/Beulah' | 'America/North_Dakota/Center' | 'America/North_Dakota/New_Salem' | 'America/Ojinaga' | 'America/Panama' | 'America/Pangnirtung' | 'America/Paramaribo' | 'America/Phoenix' | 'America/Port-au-Prince' | 'America/Port_of_Spain' | 'America/Porto_Acre' | 'America/Porto_Velho' | 'America/Puerto_Rico' | 'America/Rainy_River' | 'America/Rankin_Inlet' | 'America/Recife' | 'America/Regina' | 'America/Resolute' | 'America/Rio_Branco' | 'America/Rosario' | 'America/Santa_Isabel' | 'America/Santarem' | 'America/Santiago' | 'America/Santo_Domingo' | 'America/Sao_Paulo' | 'America/Scoresbysund' | 'America/Shiprock' | 'America/Sitka' | 'America/St_Barthelemy' | 'America/St_Johns' | 'America/St_Kitts' | 'America/St_Lucia' | 'America/St_Thomas' | 'America/St_Vincent' | 'America/Swift_Current' | 'America/Tegucigalpa' | 'America/Thule' | 'America/Thunder_Bay' | 'America/Tijuana' | 'America/Toronto' | 'America/Tortola' | 'America/Vancouver' | 'America/Virgin' | 'America/Whitehorse' | 'America/Winnipeg' | 'America/Yakutat' | 'America/Yellowknife' | 'Antarctica/Casey' | 'Antarctica/Davis' | 'Antarctica/DumontDUrville' | 'Antarctica/Macquarie' | 'Antarctica/Mawson' | 'Antarctica/McMurdo' | 'Antarctica/Palmer' | 'Antarctica/Rothera' | 'Antarctica/South_Pole' | 'Antarctica/Syowa' | 'Antarctica/Troll' | 'Antarctica/Vostok' | 'Arctic/Longyearbyen' | 'Asia/Aden' | 'Asia/Almaty' | 'Asia/Amman' | 'Asia/Anadyr' | 'Asia/Aqtau' | 'Asia/Aqtobe' | 'Asia/Ashgabat' | 'Asia/Ashkhabad' | 'Asia/Baghdad' | 'Asia/Bahrain' | 'Asia/Baku' | 'Asia/Bangkok' | 'Asia/Beirut' | 'Asia/Bishkek' | 'Asia/Brunei' | 'Asia/Calcutta' | 'Asia/Chita' | 'Asia/Choibalsan' | 'Asia/Chongqing' | 'Asia/Chungking' | 'Asia/Colombo' | 'Asia/Dacca' | 'Asia/Damascus' | 'Asia/Dhaka' | 'Asia/Dili' | 'Asia/Dubai' | 'Asia/Dushanbe' | 'Asia/Gaza' | 'Asia/Harbin' | 'Asia/Hebron' | 'Asia/Ho_Chi_Minh' | 'Asia/Hong_Kong' | 'Asia/Hovd' | 'Asia/Irkutsk' | 'Asia/Istanbul' | 'Asia/Jakarta' | 'Asia/Jayapura' | 'Asia/Jerusalem' | 'Asia/Kabul' | 'Asia/Kamchatka' | 'Asia/Karachi' | 'Asia/Kashgar' | 'Asia/Kathmandu' | 'Asia/Katmandu' | 'Asia/Khandyga' | 'Asia/Kolkata' | 'Asia/Krasnoyarsk' | 'Asia/Kuala_Lumpur' | 'Asia/Kuching' | 'Asia/Kuwait' | 'Asia/Macao' | 'Asia/Macau' | 'Asia/Magadan' | 'Asia/Makassar' | 'Asia/Manila' | 'Asia/Muscat' | 'Asia/Nicosia' | 'Asia/Novokuznetsk' | 'Asia/Novosibirsk' | 'Asia/Omsk' | 'Asia/Oral' | 'Asia/Phnom_Penh' | 'Asia/Pontianak' | 'Asia/Pyongyang' | 'Asia/Qatar' | 'Asia/Qyzylorda' | 'Asia/Rangoon' | 'Asia/Riyadh' | 'Asia/Saigon' | 'Asia/Sakhalin' | 'Asia/Samarkand' | 'Asia/Seoul' | 'Asia/Shanghai' | 'Asia/Singapore' | 'Asia/Srednekolymsk' | 'Asia/Taipei' | 'Asia/Tashkent' | 'Asia/Tbilisi' | 'Asia/Tehran' | 'Asia/Tel_Aviv' | 'Asia/Thimbu' | 'Asia/Thimphu' | 'Asia/Tokyo' | 'Asia/Ujung_Pandang' | 'Asia/Ulaanbaatar' | 'Asia/Ulan_Bator' | 'Asia/Urumqi' | 'Asia/Ust-Nera' | 'Asia/Vientiane' | 'Asia/Vladivostok' | 'Asia/Yakutsk' | 'Asia/Yekaterinburg' | 'Asia/Yerevan' | 'Atlantic/Azores' | 'Atlantic/Bermuda' | 'Atlantic/Canary' | 'Atlantic/Cape_Verde' | 'Atlantic/Faeroe' | 'Atlantic/Faroe' | 'Atlantic/Jan_Mayen' | 'Atlantic/Madeira' | 'Atlantic/Reykjavik' | 'Atlantic/South_Georgia' | 'Atlantic/St_Helena' | 'Atlantic/Stanley' | 'Australia/ACT' | 'Australia/Adelaide' | 'Australia/Brisbane' | 'Australia/Broken_Hill' | 'Australia/Canberra' | 'Australia/Currie' | 'Australia/Darwin' | 'Australia/Eucla' | 'Australia/Hobart' | 'Australia/LHI' | 'Australia/Lindeman' | 'Australia/Lord_Howe' | 'Australia/Melbourne' | 'Australia/NSW' | 'Australia/North' | 'Australia/Perth' | 'Australia/Queensland' | 'Australia/South' | 'Australia/Sydney' | 'Australia/Tasmania' | 'Australia/Victoria' | 'Australia/West' | 'Australia/Yancowinna' | 'Brazil/Acre' | 'Brazil/DeNoronha' | 'Brazil/East' | 'Brazil/West' | 'Canada/Atlantic' | 'Canada/Central' | 'Canada/East-Saskatchewan' | 'Canada/Eastern' | 'Canada/Mountain' | 'Canada/Newfoundland' | 'Canada/Pacific' | 'Canada/Saskatchewan' | 'Canada/Yukon' | 'Chile/Continental' | 'Chile/EasterIsland' | 'Etc/GMT' | 'Etc/GMT+0' | 'Etc/GMT+1' | 'Etc/GMT+10' | 'Etc/GMT+11' | 'Etc/GMT+12' | 'Etc/GMT+2' | 'Etc/GMT+3' | 'Etc/GMT+4' | 'Etc/GMT+5' | 'Etc/GMT+6' | 'Etc/GMT+7' | 'Etc/GMT+8' | 'Etc/GMT+9' | 'Etc/GMT-0' | 'Etc/GMT-1' | 'Etc/GMT-10' | 'Etc/GMT-11' | 'Etc/GMT-12' | 'Etc/GMT-13' | 'Etc/GMT-14' | 'Etc/GMT-2' | 'Etc/GMT-3' | 'Etc/GMT-4' | 'Etc/GMT-5' | 'Etc/GMT-6' | 'Etc/GMT-7' | 'Etc/GMT-8' | 'Etc/GMT-9' | 'Etc/GMT0' | 'Etc/Greenwich' | 'Etc/UCT' | 'Etc/UTC' | 'Etc/Universal' | 'Etc/Zulu' | 'Europe/Amsterdam' | 'Europe/Andorra' | 'Europe/Athens' | 'Europe/Belfast' | 'Europe/Belgrade' | 'Europe/Berlin' | 'Europe/Bratislava' | 'Europe/Brussels' | 'Europe/Bucharest' | 'Europe/Budapest' | 'Europe/Busingen' | 'Europe/Chisinau' | 'Europe/Copenhagen' | 'Europe/Dublin' | 'Europe/Gibraltar' | 'Europe/Guernsey' | 'Europe/Helsinki' | 'Europe/Isle_of_Man' | 'Europe/Istanbul' | 'Europe/Jersey' | 'Europe/Kaliningrad' | 'Europe/Kiev' | 'Europe/Lisbon' | 'Europe/Ljubljana' | 'Europe/London' | 'Europe/Luxembourg' | 'Europe/Madrid' | 'Europe/Malta' | 'Europe/Mariehamn' | 'Europe/Minsk' | 'Europe/Monaco' | 'Europe/Moscow' | 'Europe/Nicosia' | 'Europe/Oslo' | 'Europe/Paris' | 'Europe/Podgorica' | 'Europe/Prague' | 'Europe/Riga' | 'Europe/Rome' | 'Europe/Samara' | 'Europe/San_Marino' | 'Europe/Sarajevo' | 'Europe/Simferopol' | 'Europe/Skopje' | 'Europe/Sofia' | 'Europe/Stockholm' | 'Europe/Tallinn' | 'Europe/Tirane' | 'Europe/Tiraspol' | 'Europe/Uzhgorod' | 'Europe/Vaduz' | 'Europe/Vatican' | 'Europe/Vienna' | 'Europe/Vilnius' | 'Europe/Volgograd' | 'Europe/Warsaw' | 'Europe/Zagreb' | 'Europe/Zaporozhye' | 'Europe/Zurich' | 'Indian/Antananarivo' | 'Indian/Chagos' | 'Indian/Christmas' | 'Indian/Cocos' | 'Indian/Comoro' | 'Indian/Kerguelen' | 'Indian/Mahe' | 'Indian/Maldives' | 'Indian/Mauritius' | 'Indian/Mayotte' | 'Indian/Reunion' | 'Mexico/BajaNorte' | 'Mexico/BajaSur' | 'Mexico/General' | 'Pacific/Apia' | 'Pacific/Auckland' | 'Pacific/Chatham' | 'Pacific/Chuuk' | 'Pacific/Easter' | 'Pacific/Efate' | 'Pacific/Enderbury' | 'Pacific/Fakaofo' | 'Pacific/Fiji' | 'Pacific/Funafuti' | 'Pacific/Galapagos' | 'Pacific/Gambier' | 'Pacific/Guadalcanal' | 'Pacific/Guam' | 'Pacific/Honolulu' | 'Pacific/Johnston' | 'Pacific/Kiritimati' | 'Pacific/Kosrae' | 'Pacific/Kwajalein' | 'Pacific/Majuro' | 'Pacific/Marquesas' | 'Pacific/Midway' | 'Pacific/Nauru' | 'Pacific/Niue' | 'Pacific/Norfolk' | 'Pacific/Noumea' | 'Pacific/Pago_Pago' | 'Pacific/Palau' | 'Pacific/Pitcairn' | 'Pacific/Pohnpei' | 'Pacific/Ponape' | 'Pacific/Port_Moresby' | 'Pacific/Rarotonga' | 'Pacific/Saipan' | 'Pacific/Samoa' | 'Pacific/Tahiti' | 'Pacific/Tarawa' | 'Pacific/Tongatapu' | 'Pacific/Truk' | 'Pacific/Wake' | 'Pacific/Wallis' | 'Pacific/Yap', createdAtGte?: string, createdAtLte?: string, types?: Array<'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure'>, includeConnectedAccounts?: boolean, options?: AxiosRequestConfig) {
        return BalanceTransactionsApiFp(this.configuration).getBalanceTransactionsSummary(tilledAccount, timeUnit, timeZone, createdAtGte, createdAtLte, types, includeConnectedAccounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of transactions that have contributed to the Tilled account balance (e.g. charges, refunds, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.
     * @summary List all balance transactions
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
     * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
     * @param {'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure'} [type] Only return transaction of the given type.
     * @param {string} [sourceId] Only returns the original transaction.
     * @param {string} [payoutId] Only returns transactions that were paid out on the specified payout ID.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceTransactionsApi
     */
    public listBalanceTransactions(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, type?: 'charge' | 'charge_fee' | 'charge_failure_refund' | 'dispute' | 'dispute_won' | 'refund' | 'refund_fee' | 'refund_failure' | 'platform_fee' | 'platform_fee_refund' | 'tilled_fee' | 'account_fee' | 'payment_method_fee' | 'adjustment' | 'commission' | 'payout' | 'payout_cancel' | 'payout_failure', sourceId?: string, payoutId?: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return BalanceTransactionsApiFp(this.configuration).listBalanceTransactions(tilledAccount, createdAtGte, createdAtLte, type, sourceId, payoutId, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChargesApi - axios parameter creator
 * @export
 */
export const ChargesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a Charge object.
         * @summary Retrieve a charge
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharge: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getCharge', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCharge', 'id', id)
            const localVarPath = `/v1/charges/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChargesApi - functional programming interface
 * @export
 */
export const ChargesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChargesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a Charge object.
         * @summary Retrieve a charge
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharge(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Charge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharge(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChargesApi - factory interface
 * @export
 */
export const ChargesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChargesApiFp(configuration)
    return {
        /**
         * Retrieves a Charge object.
         * @summary Retrieve a charge
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharge(tilledAccount: string, id: string, options?: any): AxiosPromise<Charge> {
            return localVarFp.getCharge(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChargesApi - object-oriented interface
 * @export
 * @class ChargesApi
 * @extends {BaseAPI}
 */
export class ChargesApi extends BaseAPI {
    /**
     * Retrieves a Charge object.
     * @summary Retrieve a charge
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargesApi
     */
    public getCharge(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return ChargesApiFp(this.configuration).getCharge(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Customer objects allow you to track multiple charges that are associated with the same customer.
         * @summary Create a customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {CustomerCreateParams} customerCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (tilledAccount: string, customerCreateParams: CustomerCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createCustomer', 'tilledAccount', tilledAccount)
            // verify required parameter 'customerCreateParams' is not null or undefined
            assertParamExists('createCustomer', 'customerCreateParams', customerCreateParams)
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a customer. It cannot be undone.
         * @summary Delete a customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('deleteCustomer', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomer', 'id', id)
            const localVarPath = `/v1/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing customer.
         * @summary Retrieve a customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getCustomer', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCustomer', 'id', id)
            const localVarPath = `/v1/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your customers. The customers are returned sorted by creation date, with the most recent customers appearing first.
         * @summary List all customers
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomers: async (tilledAccount: string, metadata?: { [key: string]: string; }, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listCustomers', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified customer by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
         * @summary Update a customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {CustomerUpdateParams} customerUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer: async (tilledAccount: string, id: string, customerUpdateParams: CustomerUpdateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('updateCustomer', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCustomer', 'id', id)
            // verify required parameter 'customerUpdateParams' is not null or undefined
            assertParamExists('updateCustomer', 'customerUpdateParams', customerUpdateParams)
            const localVarPath = `/v1/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * Customer objects allow you to track multiple charges that are associated with the same customer.
         * @summary Create a customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {CustomerCreateParams} customerCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(tilledAccount: string, customerCreateParams: CustomerCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(tilledAccount, customerCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes a customer. It cannot be undone.
         * @summary Delete a customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing customer.
         * @summary Retrieve a customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your customers. The customers are returned sorted by creation date, with the most recent customers appearing first.
         * @summary List all customers
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomers(tilledAccount: string, metadata?: { [key: string]: string; }, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCustomers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomers(tilledAccount, metadata, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the specified customer by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
         * @summary Update a customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {CustomerUpdateParams} customerUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomer(tilledAccount: string, id: string, customerUpdateParams: CustomerUpdateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomer(tilledAccount, id, customerUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * Customer objects allow you to track multiple charges that are associated with the same customer.
         * @summary Create a customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {CustomerCreateParams} customerCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(tilledAccount: string, customerCreateParams: CustomerCreateParams, options?: any): AxiosPromise<Customer> {
            return localVarFp.createCustomer(tilledAccount, customerCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a customer. It cannot be undone.
         * @summary Delete a customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(tilledAccount: string, id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteCustomer(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing customer.
         * @summary Retrieve a customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(tilledAccount: string, id: string, options?: any): AxiosPromise<Customer> {
            return localVarFp.getCustomer(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your customers. The customers are returned sorted by creation date, with the most recent customers appearing first.
         * @summary List all customers
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomers(tilledAccount: string, metadata?: { [key: string]: string; }, offset?: number, limit?: number, options?: any): AxiosPromise<ListCustomers200Response> {
            return localVarFp.listCustomers(tilledAccount, metadata, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the specified customer by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
         * @summary Update a customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {CustomerUpdateParams} customerUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(tilledAccount: string, id: string, customerUpdateParams: CustomerUpdateParams, options?: any): AxiosPromise<Customer> {
            return localVarFp.updateCustomer(tilledAccount, id, customerUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * Customer objects allow you to track multiple charges that are associated with the same customer.
     * @summary Create a customer
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {CustomerCreateParams} customerCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public createCustomer(tilledAccount: string, customerCreateParams: CustomerCreateParams, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).createCustomer(tilledAccount, customerCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a customer. It cannot be undone.
     * @summary Delete a customer
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public deleteCustomer(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).deleteCustomer(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing customer.
     * @summary Retrieve a customer
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomer(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomer(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your customers. The customers are returned sorted by creation date, with the most recent customers appearing first.
     * @summary List all customers
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public listCustomers(tilledAccount: string, metadata?: { [key: string]: string; }, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).listCustomers(tilledAccount, metadata, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the specified customer by setting the values of the parameters passed. Any parameters not provided will be left unchanged.
     * @summary Update a customer
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {CustomerUpdateParams} customerUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public updateCustomer(tilledAccount: string, id: string, customerUpdateParams: CustomerUpdateParams, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).updateCustomer(tilledAccount, id, customerUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DisputesApi - axios parameter creator
 * @export
 */
export const DisputesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the details of an existing dispute with the given ID.
         * @summary Retrieve a dispute
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispute: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getDispute', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDispute', 'id', id)
            const localVarPath = `/v1/disputes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of existing disputes. The disputes are returned in sorted order, with the most recent disputes appearing first.
         * @summary List all disputes
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {'needs_response' | 'under_review' | 'closed' | 'won' | 'lost'} [status] Only return disputes that have the given status.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputes: async (tilledAccount: string, createdAtGte?: string, createdAtLte?: string, status?: 'needs_response' | 'under_review' | 'closed' | 'won' | 'lost', offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listDisputes', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisputesApi - functional programming interface
 * @export
 */
export const DisputesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisputesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the details of an existing dispute with the given ID.
         * @summary Retrieve a dispute
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDispute(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dispute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDispute(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of existing disputes. The disputes are returned in sorted order, with the most recent disputes appearing first.
         * @summary List all disputes
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {'needs_response' | 'under_review' | 'closed' | 'won' | 'lost'} [status] Only return disputes that have the given status.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDisputes(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, status?: 'needs_response' | 'under_review' | 'closed' | 'won' | 'lost', offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDisputes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDisputes(tilledAccount, createdAtGte, createdAtLte, status, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DisputesApi - factory interface
 * @export
 */
export const DisputesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisputesApiFp(configuration)
    return {
        /**
         * Retrieves the details of an existing dispute with the given ID.
         * @summary Retrieve a dispute
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispute(tilledAccount: string, id: string, options?: any): AxiosPromise<Dispute> {
            return localVarFp.getDispute(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of existing disputes. The disputes are returned in sorted order, with the most recent disputes appearing first.
         * @summary List all disputes
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {'needs_response' | 'under_review' | 'closed' | 'won' | 'lost'} [status] Only return disputes that have the given status.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDisputes(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, status?: 'needs_response' | 'under_review' | 'closed' | 'won' | 'lost', offset?: number, limit?: number, options?: any): AxiosPromise<ListDisputes200Response> {
            return localVarFp.listDisputes(tilledAccount, createdAtGte, createdAtLte, status, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisputesApi - object-oriented interface
 * @export
 * @class DisputesApi
 * @extends {BaseAPI}
 */
export class DisputesApi extends BaseAPI {
    /**
     * Retrieves the details of an existing dispute with the given ID.
     * @summary Retrieve a dispute
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public getDispute(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return DisputesApiFp(this.configuration).getDispute(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of existing disputes. The disputes are returned in sorted order, with the most recent disputes appearing first.
     * @summary List all disputes
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
     * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
     * @param {'needs_response' | 'under_review' | 'closed' | 'won' | 'lost'} [status] Only return disputes that have the given status.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputesApi
     */
    public listDisputes(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, status?: 'needs_response' | 'under_review' | 'closed' | 'won' | 'lost', offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DisputesApiFp(this.configuration).listDisputes(tilledAccount, createdAtGte, createdAtLte, status, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the details of an event. Supply the unique identifier of the event, which you might have received in a webhook.
         * @summary Retrieve an event
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getEvent', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEvent', 'id', id)
            const localVarPath = `/v1/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List events, going back up to at least 30 days.
         * @summary List all events
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {Array<'account.updated' | 'charge.captured' | 'charge.expired' | 'charge.failed' | 'charge.succeeded' | 'charge.pending' | 'charge.refunded' | 'charge.refund.updated' | 'charge.updated' | 'customer.created' | 'customer.deleted' | 'customer.updated' | 'dispute.created' | 'dispute.updated' | 'payment_intent.canceled' | 'payment_intent.created' | 'payment_intent.payment_failed' | 'payment_intent.processing' | 'payment_intent.requires_action' | 'payment_intent.succeeded' | 'payment_intent.amount_capturable_updated' | 'payment_method.attached' | 'payment_method.detached' | 'payout.created' | 'payout.failed' | 'payout.paid' | 'payout.updated' | 'platform_fee.created' | 'platform_fee.refunded' | 'subscription.created' | 'subscription.canceled' | 'subscription.updated' | 'report_run.succeeded' | 'report_run.failed'>} [types] An array of up to 20 strings containing specific event names. The list will be filtered to include only events with a matching event property.
         * @param {string} [objectId] Id of related resource. The list will be filtered to include events that are related to the resource with this id.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents: async (tilledAccount: string, createdAtGte?: string, createdAtLte?: string, types?: Array<'account.updated' | 'charge.captured' | 'charge.expired' | 'charge.failed' | 'charge.succeeded' | 'charge.pending' | 'charge.refunded' | 'charge.refund.updated' | 'charge.updated' | 'customer.created' | 'customer.deleted' | 'customer.updated' | 'dispute.created' | 'dispute.updated' | 'payment_intent.canceled' | 'payment_intent.created' | 'payment_intent.payment_failed' | 'payment_intent.processing' | 'payment_intent.requires_action' | 'payment_intent.succeeded' | 'payment_intent.amount_capturable_updated' | 'payment_method.attached' | 'payment_method.detached' | 'payout.created' | 'payout.failed' | 'payout.paid' | 'payout.updated' | 'platform_fee.created' | 'platform_fee.refunded' | 'subscription.created' | 'subscription.canceled' | 'subscription.updated' | 'report_run.succeeded' | 'report_run.failed'>, objectId?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listEvents', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['object_id'] = objectId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the details of an event. Supply the unique identifier of the event, which you might have received in a webhook.
         * @summary Retrieve an event
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvent(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List events, going back up to at least 30 days.
         * @summary List all events
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {Array<'account.updated' | 'charge.captured' | 'charge.expired' | 'charge.failed' | 'charge.succeeded' | 'charge.pending' | 'charge.refunded' | 'charge.refund.updated' | 'charge.updated' | 'customer.created' | 'customer.deleted' | 'customer.updated' | 'dispute.created' | 'dispute.updated' | 'payment_intent.canceled' | 'payment_intent.created' | 'payment_intent.payment_failed' | 'payment_intent.processing' | 'payment_intent.requires_action' | 'payment_intent.succeeded' | 'payment_intent.amount_capturable_updated' | 'payment_method.attached' | 'payment_method.detached' | 'payout.created' | 'payout.failed' | 'payout.paid' | 'payout.updated' | 'platform_fee.created' | 'platform_fee.refunded' | 'subscription.created' | 'subscription.canceled' | 'subscription.updated' | 'report_run.succeeded' | 'report_run.failed'>} [types] An array of up to 20 strings containing specific event names. The list will be filtered to include only events with a matching event property.
         * @param {string} [objectId] Id of related resource. The list will be filtered to include events that are related to the resource with this id.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEvents(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, types?: Array<'account.updated' | 'charge.captured' | 'charge.expired' | 'charge.failed' | 'charge.succeeded' | 'charge.pending' | 'charge.refunded' | 'charge.refund.updated' | 'charge.updated' | 'customer.created' | 'customer.deleted' | 'customer.updated' | 'dispute.created' | 'dispute.updated' | 'payment_intent.canceled' | 'payment_intent.created' | 'payment_intent.payment_failed' | 'payment_intent.processing' | 'payment_intent.requires_action' | 'payment_intent.succeeded' | 'payment_intent.amount_capturable_updated' | 'payment_method.attached' | 'payment_method.detached' | 'payout.created' | 'payout.failed' | 'payout.paid' | 'payout.updated' | 'platform_fee.created' | 'platform_fee.refunded' | 'subscription.created' | 'subscription.canceled' | 'subscription.updated' | 'report_run.succeeded' | 'report_run.failed'>, objectId?: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEvents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEvents(tilledAccount, createdAtGte, createdAtLte, types, objectId, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Retrieves the details of an event. Supply the unique identifier of the event, which you might have received in a webhook.
         * @summary Retrieve an event
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(tilledAccount: string, id: string, options?: any): AxiosPromise<Event> {
            return localVarFp.getEvent(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * List events, going back up to at least 30 days.
         * @summary List all events
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {Array<'account.updated' | 'charge.captured' | 'charge.expired' | 'charge.failed' | 'charge.succeeded' | 'charge.pending' | 'charge.refunded' | 'charge.refund.updated' | 'charge.updated' | 'customer.created' | 'customer.deleted' | 'customer.updated' | 'dispute.created' | 'dispute.updated' | 'payment_intent.canceled' | 'payment_intent.created' | 'payment_intent.payment_failed' | 'payment_intent.processing' | 'payment_intent.requires_action' | 'payment_intent.succeeded' | 'payment_intent.amount_capturable_updated' | 'payment_method.attached' | 'payment_method.detached' | 'payout.created' | 'payout.failed' | 'payout.paid' | 'payout.updated' | 'platform_fee.created' | 'platform_fee.refunded' | 'subscription.created' | 'subscription.canceled' | 'subscription.updated' | 'report_run.succeeded' | 'report_run.failed'>} [types] An array of up to 20 strings containing specific event names. The list will be filtered to include only events with a matching event property.
         * @param {string} [objectId] Id of related resource. The list will be filtered to include events that are related to the resource with this id.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, types?: Array<'account.updated' | 'charge.captured' | 'charge.expired' | 'charge.failed' | 'charge.succeeded' | 'charge.pending' | 'charge.refunded' | 'charge.refund.updated' | 'charge.updated' | 'customer.created' | 'customer.deleted' | 'customer.updated' | 'dispute.created' | 'dispute.updated' | 'payment_intent.canceled' | 'payment_intent.created' | 'payment_intent.payment_failed' | 'payment_intent.processing' | 'payment_intent.requires_action' | 'payment_intent.succeeded' | 'payment_intent.amount_capturable_updated' | 'payment_method.attached' | 'payment_method.detached' | 'payout.created' | 'payout.failed' | 'payout.paid' | 'payout.updated' | 'platform_fee.created' | 'platform_fee.refunded' | 'subscription.created' | 'subscription.canceled' | 'subscription.updated' | 'report_run.succeeded' | 'report_run.failed'>, objectId?: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListEvents200Response> {
            return localVarFp.listEvents(tilledAccount, createdAtGte, createdAtLte, types, objectId, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Retrieves the details of an event. Supply the unique identifier of the event, which you might have received in a webhook.
     * @summary Retrieve an event
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvent(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).getEvent(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List events, going back up to at least 30 days.
     * @summary List all events
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
     * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
     * @param {Array<'account.updated' | 'charge.captured' | 'charge.expired' | 'charge.failed' | 'charge.succeeded' | 'charge.pending' | 'charge.refunded' | 'charge.refund.updated' | 'charge.updated' | 'customer.created' | 'customer.deleted' | 'customer.updated' | 'dispute.created' | 'dispute.updated' | 'payment_intent.canceled' | 'payment_intent.created' | 'payment_intent.payment_failed' | 'payment_intent.processing' | 'payment_intent.requires_action' | 'payment_intent.succeeded' | 'payment_intent.amount_capturable_updated' | 'payment_method.attached' | 'payment_method.detached' | 'payout.created' | 'payout.failed' | 'payout.paid' | 'payout.updated' | 'platform_fee.created' | 'platform_fee.refunded' | 'subscription.created' | 'subscription.canceled' | 'subscription.updated' | 'report_run.succeeded' | 'report_run.failed'>} [types] An array of up to 20 strings containing specific event names. The list will be filtered to include only events with a matching event property.
     * @param {string} [objectId] Id of related resource. The list will be filtered to include events that are related to the resource with this id.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listEvents(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, types?: Array<'account.updated' | 'charge.captured' | 'charge.expired' | 'charge.failed' | 'charge.succeeded' | 'charge.pending' | 'charge.refunded' | 'charge.refund.updated' | 'charge.updated' | 'customer.created' | 'customer.deleted' | 'customer.updated' | 'dispute.created' | 'dispute.updated' | 'payment_intent.canceled' | 'payment_intent.created' | 'payment_intent.payment_failed' | 'payment_intent.processing' | 'payment_intent.requires_action' | 'payment_intent.succeeded' | 'payment_intent.amount_capturable_updated' | 'payment_method.attached' | 'payment_method.detached' | 'payout.created' | 'payout.failed' | 'payout.paid' | 'payout.updated' | 'platform_fee.created' | 'platform_fee.refunded' | 'subscription.created' | 'subscription.canceled' | 'subscription.updated' | 'report_run.succeeded' | 'report_run.failed'>, objectId?: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).listEvents(tilledAccount, createdAtGte, createdAtLte, types, objectId, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a File
         * @summary Create a File
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {any} file A file to upload. The file should follow the specifications of RFC 2388 (which defines file transfers for the multipart/form-data protocol).
         * @param {string} purpose The file purpose (e.g. &#x60;logo&#x60;, or &#x60;icon&#x60;)
         * @param {string} [title] The user friendly file title.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: async (tilledAccount: string, file: any, purpose: string, title?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createFile', 'tilledAccount', tilledAccount)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createFile', 'file', file)
            // verify required parameter 'purpose' is not null or undefined
            assertParamExists('createFile', 'purpose', purpose)
            const localVarPath = `/v1/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (purpose !== undefined) { 
                localVarFormParams.append('purpose', purpose as any);
            }
    
            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a file
         * @summary Delete a File
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('deleteFile', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFile', 'id', id)
            const localVarPath = `/v1/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the contents of a file with the given ID.
         * @summary Gets the contents of a File
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentsOfFile: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getContentsOfFile', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContentsOfFile', 'id', id)
            const localVarPath = `/v1/files/{id}/contents`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of uploaded files
         * @summary List all Files
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFiles: async (tilledAccount: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listAllFiles', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the file with the given ID.
         * @summary Retrieve a File
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('retrieveFile', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveFile', 'id', id)
            const localVarPath = `/v1/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a File
         * @summary Create a File
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {any} file A file to upload. The file should follow the specifications of RFC 2388 (which defines file transfers for the multipart/form-data protocol).
         * @param {string} purpose The file purpose (e.g. &#x60;logo&#x60;, or &#x60;icon&#x60;)
         * @param {string} [title] The user friendly file title.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFile(tilledAccount: string, file: any, purpose: string, title?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(tilledAccount, file, purpose, title, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently delete a file
         * @summary Delete a File
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the contents of a file with the given ID.
         * @summary Gets the contents of a File
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentsOfFile(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentsOfFile(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of uploaded files
         * @summary List all Files
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllFiles(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllFiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllFiles(tilledAccount, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the file with the given ID.
         * @summary Retrieve a File
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFile(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveFile(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Creates a File
         * @summary Create a File
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {any} file A file to upload. The file should follow the specifications of RFC 2388 (which defines file transfers for the multipart/form-data protocol).
         * @param {string} purpose The file purpose (e.g. &#x60;logo&#x60;, or &#x60;icon&#x60;)
         * @param {string} [title] The user friendly file title.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(tilledAccount: string, file: any, purpose: string, title?: string, options?: any): AxiosPromise<any> {
            return localVarFp.createFile(tilledAccount, file, purpose, title, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently delete a file
         * @summary Delete a File
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(tilledAccount: string, id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteFile(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the contents of a file with the given ID.
         * @summary Gets the contents of a File
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentsOfFile(tilledAccount: string, id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getContentsOfFile(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of uploaded files
         * @summary List all Files
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllFiles(tilledAccount: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListAllFiles200Response> {
            return localVarFp.listAllFiles(tilledAccount, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the file with the given ID.
         * @summary Retrieve a File
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile(tilledAccount: string, id: string, options?: any): AxiosPromise<any> {
            return localVarFp.retrieveFile(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Creates a File
     * @summary Create a File
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {any} file A file to upload. The file should follow the specifications of RFC 2388 (which defines file transfers for the multipart/form-data protocol).
     * @param {string} purpose The file purpose (e.g. &#x60;logo&#x60;, or &#x60;icon&#x60;)
     * @param {string} [title] The user friendly file title.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public createFile(tilledAccount: string, file: any, purpose: string, title?: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).createFile(tilledAccount, file, purpose, title, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently delete a file
     * @summary Delete a File
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public deleteFile(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFile(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the contents of a file with the given ID.
     * @summary Gets the contents of a File
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getContentsOfFile(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getContentsOfFile(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of uploaded files
     * @summary List all Files
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public listAllFiles(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).listAllFiles(tilledAccount, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the file with the given ID.
     * @summary Retrieve a File
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public retrieveFile(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).retrieveFile(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A status of `pass` is healthy, `warn` is healthy with concerns, and `fail` is unhealthy.  *Note: a `503` HTTP response code will be returned for the `fail` status.*
         * @summary Returns the Overall Health of the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * A status of `pass` is healthy, `warn` is healthy with concerns, and `fail` is unhealthy.  *Note: a `503` HTTP response code will be returned for the `fail` status.*
         * @summary Returns the Overall Health of the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealth(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * A status of `pass` is healthy, `warn` is healthy with concerns, and `fail` is unhealthy.  *Note: a `503` HTTP response code will be returned for the `fail` status.*
         * @summary Returns the Overall Health of the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: any): AxiosPromise<HealthOutput> {
            return localVarFp.getHealth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * A status of `pass` is healthy, `warn` is healthy with concerns, and `fail` is unhealthy.  *Note: a `503` HTTP response code will be returned for the `fail` status.*
     * @summary Returns the Overall Health of the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getHealth(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getHealth(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OnboardingApi - axios parameter creator
 * @export
 */
export const OnboardingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a merchant application as long as its `status` is `created` or `started`. Once the application is `submitted` or `active` it is not accessible.
         * @summary Retrieve a merchant application
         * @param {string} accountId The id of the associated connected (i.e. merchant) account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnboardingApplication: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getOnboardingApplication', 'accountId', accountId)
            const localVarPath = `/v1/applications/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a merchant application to be processed. If any validation errors exist, you must correct them before re-submitting. Once successful submission, you cannot access the application again.
         * @summary Submit a merchant application
         * @param {string} accountId The id of the associated connected (i.e. merchant) account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitOnboardingApplication: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('submitOnboardingApplication', 'accountId', accountId)
            const localVarPath = `/v1/applications/{account_id}/submit`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a merchant application by overwriting all properties.
         * @summary Update a merchant application
         * @param {string} accountId The id of the associated connected (i.e. merchant) account.
         * @param {MerchantApplicationCreateParams} merchantApplicationCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOnboardingApplication: async (accountId: string, merchantApplicationCreateParams: MerchantApplicationCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateOnboardingApplication', 'accountId', accountId)
            // verify required parameter 'merchantApplicationCreateParams' is not null or undefined
            assertParamExists('updateOnboardingApplication', 'merchantApplicationCreateParams', merchantApplicationCreateParams)
            const localVarPath = `/v1/applications/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(merchantApplicationCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OnboardingApi - functional programming interface
 * @export
 */
export const OnboardingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OnboardingApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a merchant application as long as its `status` is `created` or `started`. Once the application is `submitted` or `active` it is not accessible.
         * @summary Retrieve a merchant application
         * @param {string} accountId The id of the associated connected (i.e. merchant) account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOnboardingApplication(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOnboardingApplication(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Submits a merchant application to be processed. If any validation errors exist, you must correct them before re-submitting. Once successful submission, you cannot access the application again.
         * @summary Submit a merchant application
         * @param {string} accountId The id of the associated connected (i.e. merchant) account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitOnboardingApplication(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitOnboardingApplication(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a merchant application by overwriting all properties.
         * @summary Update a merchant application
         * @param {string} accountId The id of the associated connected (i.e. merchant) account.
         * @param {MerchantApplicationCreateParams} merchantApplicationCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOnboardingApplication(accountId: string, merchantApplicationCreateParams: MerchantApplicationCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantApplication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOnboardingApplication(accountId, merchantApplicationCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OnboardingApi - factory interface
 * @export
 */
export const OnboardingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OnboardingApiFp(configuration)
    return {
        /**
         * Retrieves a merchant application as long as its `status` is `created` or `started`. Once the application is `submitted` or `active` it is not accessible.
         * @summary Retrieve a merchant application
         * @param {string} accountId The id of the associated connected (i.e. merchant) account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnboardingApplication(accountId: string, options?: any): AxiosPromise<MerchantApplication> {
            return localVarFp.getOnboardingApplication(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a merchant application to be processed. If any validation errors exist, you must correct them before re-submitting. Once successful submission, you cannot access the application again.
         * @summary Submit a merchant application
         * @param {string} accountId The id of the associated connected (i.e. merchant) account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitOnboardingApplication(accountId: string, options?: any): AxiosPromise<object> {
            return localVarFp.submitOnboardingApplication(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a merchant application by overwriting all properties.
         * @summary Update a merchant application
         * @param {string} accountId The id of the associated connected (i.e. merchant) account.
         * @param {MerchantApplicationCreateParams} merchantApplicationCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOnboardingApplication(accountId: string, merchantApplicationCreateParams: MerchantApplicationCreateParams, options?: any): AxiosPromise<MerchantApplication> {
            return localVarFp.updateOnboardingApplication(accountId, merchantApplicationCreateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OnboardingApi - object-oriented interface
 * @export
 * @class OnboardingApi
 * @extends {BaseAPI}
 */
export class OnboardingApi extends BaseAPI {
    /**
     * Retrieves a merchant application as long as its `status` is `created` or `started`. Once the application is `submitted` or `active` it is not accessible.
     * @summary Retrieve a merchant application
     * @param {string} accountId The id of the associated connected (i.e. merchant) account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public getOnboardingApplication(accountId: string, options?: AxiosRequestConfig) {
        return OnboardingApiFp(this.configuration).getOnboardingApplication(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a merchant application to be processed. If any validation errors exist, you must correct them before re-submitting. Once successful submission, you cannot access the application again.
     * @summary Submit a merchant application
     * @param {string} accountId The id of the associated connected (i.e. merchant) account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public submitOnboardingApplication(accountId: string, options?: AxiosRequestConfig) {
        return OnboardingApiFp(this.configuration).submitOnboardingApplication(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a merchant application by overwriting all properties.
     * @summary Update a merchant application
     * @param {string} accountId The id of the associated connected (i.e. merchant) account.
     * @param {MerchantApplicationCreateParams} merchantApplicationCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingApi
     */
    public updateOnboardingApplication(accountId: string, merchantApplicationCreateParams: MerchantApplicationCreateParams, options?: AxiosRequestConfig) {
        return OnboardingApiFp(this.configuration).updateOnboardingApplication(accountId, merchantApplicationCreateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentIntentsApi - axios parameter creator
 * @export
 */
export const PaymentIntentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A PaymentIntent object can be canceled when it is in one of these statuses: `requires_payment_method`, `requires_capture`, `requires_confirmation`, or `requires_action`.  Once canceled, no additional charges will be made by the PaymentIntent and any operations on the PaymentIntent will fail with an error.
         * @summary Cancel a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentIntentCancelParams} paymentIntentCancelParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentIntent: async (tilledAccount: string, id: string, paymentIntentCancelParams: PaymentIntentCancelParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('cancelPaymentIntent', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelPaymentIntent', 'id', id)
            // verify required parameter 'paymentIntentCancelParams' is not null or undefined
            assertParamExists('cancelPaymentIntent', 'paymentIntentCancelParams', paymentIntentCancelParams)
            const localVarPath = `/v1/payment-intents/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentIntentCancelParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Capture the funds of an existing uncaptured PaymentIntent when its status is `requires_capture`. Uncaptured PaymentIntents will be canceled exactly 7 days after they are created.
         * @summary Capture a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentIntentCaptureParams} paymentIntentCaptureParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePaymentIntent: async (tilledAccount: string, id: string, paymentIntentCaptureParams: PaymentIntentCaptureParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('capturePaymentIntent', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('capturePaymentIntent', 'id', id)
            // verify required parameter 'paymentIntentCaptureParams' is not null or undefined
            assertParamExists('capturePaymentIntent', 'paymentIntentCaptureParams', paymentIntentCaptureParams)
            const localVarPath = `/v1/payment-intents/{id}/capture`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentIntentCaptureParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm that your customer intends to pay with current or provided payment method. Upon confirmation, the PaymentIntent will attempt to initiate a payment.  If the selected payment method requires additional steps, the PaymentIntent will transition to the `requires_action` status. If payment fails, the PaymentIntent will transition to the `requires_payment_method` status. If payment succeeds, the PaymentIntent will transition to the `succeeded` status (or `requires_capture`, if `capture_method` is set to `manual`).  Payment may be attempted using our `tilled.js` and the PaymentIntent’s `client_secret`.
         * @summary Confirm a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentIntentConfirmParams} paymentIntentConfirmParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPaymentIntent: async (tilledAccount: string, id: string, paymentIntentConfirmParams: PaymentIntentConfirmParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('confirmPaymentIntent', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('confirmPaymentIntent', 'id', id)
            // verify required parameter 'paymentIntentConfirmParams' is not null or undefined
            assertParamExists('confirmPaymentIntent', 'paymentIntentConfirmParams', paymentIntentConfirmParams)
            const localVarPath = `/v1/payment-intents/{id}/confirm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentIntentConfirmParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After the PaymentIntent is created, attach a payment method and confirm to continue the payment. You can read more about the different payment flows available via the Payment Intents API here<TBD>.  When `confirm=true` is used during creation, it is equivalent to creating and confirming the PaymentIntent in the same call. You may use any parameters available in the confirm API when `confirm=true` is supplied.
         * @summary Create a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {PaymentIntentCreateParams} paymentIntentCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentIntent: async (tilledAccount: string, paymentIntentCreateParams: PaymentIntentCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createPaymentIntent', 'tilledAccount', tilledAccount)
            // verify required parameter 'paymentIntentCreateParams' is not null or undefined
            assertParamExists('createPaymentIntent', 'paymentIntentCreateParams', paymentIntentCreateParams)
            const localVarPath = `/v1/payment-intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentIntentCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a PaymentIntent that has previously been created.
         * @summary Retrieve a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentIntent: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getPaymentIntent', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPaymentIntent', 'id', id)
            const localVarPath = `/v1/payment-intents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of PaymentIntents.
         * @summary List all PaymentIntents
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {Array<'canceled' | 'processing' | 'requires_action' | 'requires_capture' | 'requires_confirmation' | 'requires_payment_method' | 'succeeded'>} [status] Only return PaymentIntents whose status is included by this array. Examples: &#x60;/v1/payment-intents?status&#x3D;succeeded,requires_payment_method&#x60; and &#x60;/v1/payment-intents?status&#x3D;succeeded&amp;status&#x3D;requires_payment_method&#x60;.
         * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
         * @param {string} [subscriptionId] The ID of the subscription whose payment intents will be retrieved.
         * @param {string} [q] The partial search of text fields. Supports searching by &#x60;payment_intent.id&#x60;, &#x60;payment_method.billing_details.name&#x60;, &#x60;payment_method.details.last4&#x60;, &#x60;payment_method.details.last2\&#39;, &#x60;customer.first_name&#x60;, &#x60;customer.last_name&#x60;
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentIntents: async (tilledAccount: string, metadata?: { [key: string]: string; }, createdAtGte?: string, createdAtLte?: string, status?: Array<'canceled' | 'processing' | 'requires_action' | 'requires_capture' | 'requires_confirmation' | 'requires_payment_method' | 'succeeded'>, includeConnectedAccounts?: boolean, subscriptionId?: string, q?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listPaymentIntents', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/payment-intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (includeConnectedAccounts !== undefined) {
                localVarQueryParameter['include_connected_accounts'] = includeConnectedAccounts;
            }

            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscription_id'] = subscriptionId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates properties on a PaymentIntent object without confirming.  Depending on which properties you update, you may need to confirm the PaymentIntent again.
         * @summary Update a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentIntentUpdateParams} paymentIntentUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentIntent: async (tilledAccount: string, id: string, paymentIntentUpdateParams: PaymentIntentUpdateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('updatePaymentIntent', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePaymentIntent', 'id', id)
            // verify required parameter 'paymentIntentUpdateParams' is not null or undefined
            assertParamExists('updatePaymentIntent', 'paymentIntentUpdateParams', paymentIntentUpdateParams)
            const localVarPath = `/v1/payment-intents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentIntentUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentIntentsApi - functional programming interface
 * @export
 */
export const PaymentIntentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentIntentsApiAxiosParamCreator(configuration)
    return {
        /**
         * A PaymentIntent object can be canceled when it is in one of these statuses: `requires_payment_method`, `requires_capture`, `requires_confirmation`, or `requires_action`.  Once canceled, no additional charges will be made by the PaymentIntent and any operations on the PaymentIntent will fail with an error.
         * @summary Cancel a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentIntentCancelParams} paymentIntentCancelParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPaymentIntent(tilledAccount: string, id: string, paymentIntentCancelParams: PaymentIntentCancelParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPaymentIntent(tilledAccount, id, paymentIntentCancelParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Capture the funds of an existing uncaptured PaymentIntent when its status is `requires_capture`. Uncaptured PaymentIntents will be canceled exactly 7 days after they are created.
         * @summary Capture a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentIntentCaptureParams} paymentIntentCaptureParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturePaymentIntent(tilledAccount: string, id: string, paymentIntentCaptureParams: PaymentIntentCaptureParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturePaymentIntent(tilledAccount, id, paymentIntentCaptureParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Confirm that your customer intends to pay with current or provided payment method. Upon confirmation, the PaymentIntent will attempt to initiate a payment.  If the selected payment method requires additional steps, the PaymentIntent will transition to the `requires_action` status. If payment fails, the PaymentIntent will transition to the `requires_payment_method` status. If payment succeeds, the PaymentIntent will transition to the `succeeded` status (or `requires_capture`, if `capture_method` is set to `manual`).  Payment may be attempted using our `tilled.js` and the PaymentIntent’s `client_secret`.
         * @summary Confirm a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentIntentConfirmParams} paymentIntentConfirmParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmPaymentIntent(tilledAccount: string, id: string, paymentIntentConfirmParams: PaymentIntentConfirmParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmPaymentIntent(tilledAccount, id, paymentIntentConfirmParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After the PaymentIntent is created, attach a payment method and confirm to continue the payment. You can read more about the different payment flows available via the Payment Intents API here<TBD>.  When `confirm=true` is used during creation, it is equivalent to creating and confirming the PaymentIntent in the same call. You may use any parameters available in the confirm API when `confirm=true` is supplied.
         * @summary Create a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {PaymentIntentCreateParams} paymentIntentCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentIntent(tilledAccount: string, paymentIntentCreateParams: PaymentIntentCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentIntent(tilledAccount, paymentIntentCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of a PaymentIntent that has previously been created.
         * @summary Retrieve a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentIntent(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentIntent(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of PaymentIntents.
         * @summary List all PaymentIntents
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {Array<'canceled' | 'processing' | 'requires_action' | 'requires_capture' | 'requires_confirmation' | 'requires_payment_method' | 'succeeded'>} [status] Only return PaymentIntents whose status is included by this array. Examples: &#x60;/v1/payment-intents?status&#x3D;succeeded,requires_payment_method&#x60; and &#x60;/v1/payment-intents?status&#x3D;succeeded&amp;status&#x3D;requires_payment_method&#x60;.
         * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
         * @param {string} [subscriptionId] The ID of the subscription whose payment intents will be retrieved.
         * @param {string} [q] The partial search of text fields. Supports searching by &#x60;payment_intent.id&#x60;, &#x60;payment_method.billing_details.name&#x60;, &#x60;payment_method.details.last4&#x60;, &#x60;payment_method.details.last2\&#39;, &#x60;customer.first_name&#x60;, &#x60;customer.last_name&#x60;
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPaymentIntents(tilledAccount: string, metadata?: { [key: string]: string; }, createdAtGte?: string, createdAtLte?: string, status?: Array<'canceled' | 'processing' | 'requires_action' | 'requires_capture' | 'requires_confirmation' | 'requires_payment_method' | 'succeeded'>, includeConnectedAccounts?: boolean, subscriptionId?: string, q?: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentIntents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentIntents(tilledAccount, metadata, createdAtGte, createdAtLte, status, includeConnectedAccounts, subscriptionId, q, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates properties on a PaymentIntent object without confirming.  Depending on which properties you update, you may need to confirm the PaymentIntent again.
         * @summary Update a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentIntentUpdateParams} paymentIntentUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentIntent(tilledAccount: string, id: string, paymentIntentUpdateParams: PaymentIntentUpdateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentIntent(tilledAccount, id, paymentIntentUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentIntentsApi - factory interface
 * @export
 */
export const PaymentIntentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentIntentsApiFp(configuration)
    return {
        /**
         * A PaymentIntent object can be canceled when it is in one of these statuses: `requires_payment_method`, `requires_capture`, `requires_confirmation`, or `requires_action`.  Once canceled, no additional charges will be made by the PaymentIntent and any operations on the PaymentIntent will fail with an error.
         * @summary Cancel a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentIntentCancelParams} paymentIntentCancelParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentIntent(tilledAccount: string, id: string, paymentIntentCancelParams: PaymentIntentCancelParams, options?: any): AxiosPromise<PaymentIntent> {
            return localVarFp.cancelPaymentIntent(tilledAccount, id, paymentIntentCancelParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Capture the funds of an existing uncaptured PaymentIntent when its status is `requires_capture`. Uncaptured PaymentIntents will be canceled exactly 7 days after they are created.
         * @summary Capture a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentIntentCaptureParams} paymentIntentCaptureParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePaymentIntent(tilledAccount: string, id: string, paymentIntentCaptureParams: PaymentIntentCaptureParams, options?: any): AxiosPromise<PaymentIntent> {
            return localVarFp.capturePaymentIntent(tilledAccount, id, paymentIntentCaptureParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirm that your customer intends to pay with current or provided payment method. Upon confirmation, the PaymentIntent will attempt to initiate a payment.  If the selected payment method requires additional steps, the PaymentIntent will transition to the `requires_action` status. If payment fails, the PaymentIntent will transition to the `requires_payment_method` status. If payment succeeds, the PaymentIntent will transition to the `succeeded` status (or `requires_capture`, if `capture_method` is set to `manual`).  Payment may be attempted using our `tilled.js` and the PaymentIntent’s `client_secret`.
         * @summary Confirm a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentIntentConfirmParams} paymentIntentConfirmParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPaymentIntent(tilledAccount: string, id: string, paymentIntentConfirmParams: PaymentIntentConfirmParams, options?: any): AxiosPromise<PaymentIntent> {
            return localVarFp.confirmPaymentIntent(tilledAccount, id, paymentIntentConfirmParams, options).then((request) => request(axios, basePath));
        },
        /**
         * After the PaymentIntent is created, attach a payment method and confirm to continue the payment. You can read more about the different payment flows available via the Payment Intents API here<TBD>.  When `confirm=true` is used during creation, it is equivalent to creating and confirming the PaymentIntent in the same call. You may use any parameters available in the confirm API when `confirm=true` is supplied.
         * @summary Create a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {PaymentIntentCreateParams} paymentIntentCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentIntent(tilledAccount: string, paymentIntentCreateParams: PaymentIntentCreateParams, options?: any): AxiosPromise<PaymentIntent> {
            return localVarFp.createPaymentIntent(tilledAccount, paymentIntentCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a PaymentIntent that has previously been created.
         * @summary Retrieve a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentIntent(tilledAccount: string, id: string, options?: any): AxiosPromise<PaymentIntent> {
            return localVarFp.getPaymentIntent(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of PaymentIntents.
         * @summary List all PaymentIntents
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {Array<'canceled' | 'processing' | 'requires_action' | 'requires_capture' | 'requires_confirmation' | 'requires_payment_method' | 'succeeded'>} [status] Only return PaymentIntents whose status is included by this array. Examples: &#x60;/v1/payment-intents?status&#x3D;succeeded,requires_payment_method&#x60; and &#x60;/v1/payment-intents?status&#x3D;succeeded&amp;status&#x3D;requires_payment_method&#x60;.
         * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
         * @param {string} [subscriptionId] The ID of the subscription whose payment intents will be retrieved.
         * @param {string} [q] The partial search of text fields. Supports searching by &#x60;payment_intent.id&#x60;, &#x60;payment_method.billing_details.name&#x60;, &#x60;payment_method.details.last4&#x60;, &#x60;payment_method.details.last2\&#39;, &#x60;customer.first_name&#x60;, &#x60;customer.last_name&#x60;
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentIntents(tilledAccount: string, metadata?: { [key: string]: string; }, createdAtGte?: string, createdAtLte?: string, status?: Array<'canceled' | 'processing' | 'requires_action' | 'requires_capture' | 'requires_confirmation' | 'requires_payment_method' | 'succeeded'>, includeConnectedAccounts?: boolean, subscriptionId?: string, q?: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListPaymentIntents200Response> {
            return localVarFp.listPaymentIntents(tilledAccount, metadata, createdAtGte, createdAtLte, status, includeConnectedAccounts, subscriptionId, q, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates properties on a PaymentIntent object without confirming.  Depending on which properties you update, you may need to confirm the PaymentIntent again.
         * @summary Update a PaymentIntent
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentIntentUpdateParams} paymentIntentUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentIntent(tilledAccount: string, id: string, paymentIntentUpdateParams: PaymentIntentUpdateParams, options?: any): AxiosPromise<PaymentIntent> {
            return localVarFp.updatePaymentIntent(tilledAccount, id, paymentIntentUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentIntentsApi - object-oriented interface
 * @export
 * @class PaymentIntentsApi
 * @extends {BaseAPI}
 */
export class PaymentIntentsApi extends BaseAPI {
    /**
     * A PaymentIntent object can be canceled when it is in one of these statuses: `requires_payment_method`, `requires_capture`, `requires_confirmation`, or `requires_action`.  Once canceled, no additional charges will be made by the PaymentIntent and any operations on the PaymentIntent will fail with an error.
     * @summary Cancel a PaymentIntent
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {PaymentIntentCancelParams} paymentIntentCancelParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntentsApi
     */
    public cancelPaymentIntent(tilledAccount: string, id: string, paymentIntentCancelParams: PaymentIntentCancelParams, options?: AxiosRequestConfig) {
        return PaymentIntentsApiFp(this.configuration).cancelPaymentIntent(tilledAccount, id, paymentIntentCancelParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Capture the funds of an existing uncaptured PaymentIntent when its status is `requires_capture`. Uncaptured PaymentIntents will be canceled exactly 7 days after they are created.
     * @summary Capture a PaymentIntent
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {PaymentIntentCaptureParams} paymentIntentCaptureParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntentsApi
     */
    public capturePaymentIntent(tilledAccount: string, id: string, paymentIntentCaptureParams: PaymentIntentCaptureParams, options?: AxiosRequestConfig) {
        return PaymentIntentsApiFp(this.configuration).capturePaymentIntent(tilledAccount, id, paymentIntentCaptureParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirm that your customer intends to pay with current or provided payment method. Upon confirmation, the PaymentIntent will attempt to initiate a payment.  If the selected payment method requires additional steps, the PaymentIntent will transition to the `requires_action` status. If payment fails, the PaymentIntent will transition to the `requires_payment_method` status. If payment succeeds, the PaymentIntent will transition to the `succeeded` status (or `requires_capture`, if `capture_method` is set to `manual`).  Payment may be attempted using our `tilled.js` and the PaymentIntent’s `client_secret`.
     * @summary Confirm a PaymentIntent
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {PaymentIntentConfirmParams} paymentIntentConfirmParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntentsApi
     */
    public confirmPaymentIntent(tilledAccount: string, id: string, paymentIntentConfirmParams: PaymentIntentConfirmParams, options?: AxiosRequestConfig) {
        return PaymentIntentsApiFp(this.configuration).confirmPaymentIntent(tilledAccount, id, paymentIntentConfirmParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After the PaymentIntent is created, attach a payment method and confirm to continue the payment. You can read more about the different payment flows available via the Payment Intents API here<TBD>.  When `confirm=true` is used during creation, it is equivalent to creating and confirming the PaymentIntent in the same call. You may use any parameters available in the confirm API when `confirm=true` is supplied.
     * @summary Create a PaymentIntent
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {PaymentIntentCreateParams} paymentIntentCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntentsApi
     */
    public createPaymentIntent(tilledAccount: string, paymentIntentCreateParams: PaymentIntentCreateParams, options?: AxiosRequestConfig) {
        return PaymentIntentsApiFp(this.configuration).createPaymentIntent(tilledAccount, paymentIntentCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a PaymentIntent that has previously been created.
     * @summary Retrieve a PaymentIntent
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntentsApi
     */
    public getPaymentIntent(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return PaymentIntentsApiFp(this.configuration).getPaymentIntent(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of PaymentIntents.
     * @summary List all PaymentIntents
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
     * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
     * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
     * @param {Array<'canceled' | 'processing' | 'requires_action' | 'requires_capture' | 'requires_confirmation' | 'requires_payment_method' | 'succeeded'>} [status] Only return PaymentIntents whose status is included by this array. Examples: &#x60;/v1/payment-intents?status&#x3D;succeeded,requires_payment_method&#x60; and &#x60;/v1/payment-intents?status&#x3D;succeeded&amp;status&#x3D;requires_payment_method&#x60;.
     * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
     * @param {string} [subscriptionId] The ID of the subscription whose payment intents will be retrieved.
     * @param {string} [q] The partial search of text fields. Supports searching by &#x60;payment_intent.id&#x60;, &#x60;payment_method.billing_details.name&#x60;, &#x60;payment_method.details.last4&#x60;, &#x60;payment_method.details.last2\&#39;, &#x60;customer.first_name&#x60;, &#x60;customer.last_name&#x60;
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntentsApi
     */
    public listPaymentIntents(tilledAccount: string, metadata?: { [key: string]: string; }, createdAtGte?: string, createdAtLte?: string, status?: Array<'canceled' | 'processing' | 'requires_action' | 'requires_capture' | 'requires_confirmation' | 'requires_payment_method' | 'succeeded'>, includeConnectedAccounts?: boolean, subscriptionId?: string, q?: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return PaymentIntentsApiFp(this.configuration).listPaymentIntents(tilledAccount, metadata, createdAtGte, createdAtLte, status, includeConnectedAccounts, subscriptionId, q, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates properties on a PaymentIntent object without confirming.  Depending on which properties you update, you may need to confirm the PaymentIntent again.
     * @summary Update a PaymentIntent
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {PaymentIntentUpdateParams} paymentIntentUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntentsApi
     */
    public updatePaymentIntent(tilledAccount: string, id: string, paymentIntentUpdateParams: PaymentIntentUpdateParams, options?: AxiosRequestConfig) {
        return PaymentIntentsApiFp(this.configuration).updatePaymentIntent(tilledAccount, id, paymentIntentUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentMethodsApi - axios parameter creator
 * @export
 */
export const PaymentMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attaches a PaymentMethod to a Customer. This effectively changes the payment method from single-use to reusable.
         * @summary Attach a PaymentMethod to a Customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentMethodAttachParams} paymentMethodAttachParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethodToCustomer: async (tilledAccount: string, id: string, paymentMethodAttachParams: PaymentMethodAttachParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('attachPaymentMethodToCustomer', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attachPaymentMethodToCustomer', 'id', id)
            // verify required parameter 'paymentMethodAttachParams' is not null or undefined
            assertParamExists('attachPaymentMethodToCustomer', 'paymentMethodAttachParams', paymentMethodAttachParams)
            const localVarPath = `/v1/payment-methods/{id}/attach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentMethodAttachParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an ACH Debit Single-Use Token, for use in creating a PaymentMethod.
         * @summary Create ACH Debit Single-Use Token
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {PaymentMethodCreateAchDebitSingleUseTokenParams} paymentMethodCreateAchDebitSingleUseTokenParams 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createAchDebitSingleUseToken: async (tilledAccount: string, paymentMethodCreateAchDebitSingleUseTokenParams: PaymentMethodCreateAchDebitSingleUseTokenParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createAchDebitSingleUseToken', 'tilledAccount', tilledAccount)
            // verify required parameter 'paymentMethodCreateAchDebitSingleUseTokenParams' is not null or undefined
            assertParamExists('createAchDebitSingleUseToken', 'paymentMethodCreateAchDebitSingleUseTokenParams', paymentMethodCreateAchDebitSingleUseTokenParams)
            const localVarPath = `/v1/payment-methods/ach-debit-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentMethodCreateAchDebitSingleUseTokenParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a PaymentMethod object. Read the [Tilled.js reference](#section/Tilled.js) to learn how to create PaymentMethods via Tilled.js. One of the following is required to create a payment method: `card`, `payment_token`, `terminal_reader_id`, `ach_debit`, or `eft_debit`.
         * @summary Create a PaymentMethod
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {PaymentMethodCreateParams} paymentMethodCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod: async (tilledAccount: string, paymentMethodCreateParams: PaymentMethodCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createPaymentMethod', 'tilledAccount', tilledAccount)
            // verify required parameter 'paymentMethodCreateParams' is not null or undefined
            assertParamExists('createPaymentMethod', 'paymentMethodCreateParams', paymentMethodCreateParams)
            const localVarPath = `/v1/payment-methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentMethodCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detaches a PaymentMethod from a Customer. Once a payment method is detached it can no longer be used to make a charge.
         * @summary Detach a PaymentMethod from a Customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethodFromCustomer: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('detachPaymentMethodFromCustomer', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('detachPaymentMethodFromCustomer', 'id', id)
            const localVarPath = `/v1/payment-methods/{id}/detach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a PaymentMethod object.
         * @summary Retrieve a PaymentMethod
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getPaymentMethod', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPaymentMethod', 'id', id)
            const localVarPath = `/v1/payment-methods/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of PaymentMethods for a given Customer
         * @summary List a customer\'s PaymentMethods
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {'card' | 'ach_debit' | 'card_present' | 'eft_debit'} type Only return payment methods of the given type.
         * @param {string} customerId Customer identifier
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentMethods: async (tilledAccount: string, type: 'card' | 'ach_debit' | 'card_present' | 'eft_debit', customerId: string, metadata?: { [key: string]: string; }, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listPaymentMethods', 'tilledAccount', tilledAccount)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listPaymentMethods', 'type', type)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('listPaymentMethods', 'customerId', customerId)
            const localVarPath = `/v1/payment-methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a PaymentMethod object. A PaymentMethod must be attached to a customer to be updated.
         * @summary Update a PaymentMethod
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentMethodUpdateParams} paymentMethodUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethod: async (tilledAccount: string, id: string, paymentMethodUpdateParams: PaymentMethodUpdateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('updatePaymentMethod', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePaymentMethod', 'id', id)
            // verify required parameter 'paymentMethodUpdateParams' is not null or undefined
            assertParamExists('updatePaymentMethod', 'paymentMethodUpdateParams', paymentMethodUpdateParams)
            const localVarPath = `/v1/payment-methods/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentMethodUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentMethodsApi - functional programming interface
 * @export
 */
export const PaymentMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Attaches a PaymentMethod to a Customer. This effectively changes the payment method from single-use to reusable.
         * @summary Attach a PaymentMethod to a Customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentMethodAttachParams} paymentMethodAttachParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachPaymentMethodToCustomer(tilledAccount: string, id: string, paymentMethodAttachParams: PaymentMethodAttachParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachPaymentMethodToCustomer(tilledAccount, id, paymentMethodAttachParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates an ACH Debit Single-Use Token, for use in creating a PaymentMethod.
         * @summary Create ACH Debit Single-Use Token
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {PaymentMethodCreateAchDebitSingleUseTokenParams} paymentMethodCreateAchDebitSingleUseTokenParams 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createAchDebitSingleUseToken(tilledAccount: string, paymentMethodCreateAchDebitSingleUseTokenParams: PaymentMethodCreateAchDebitSingleUseTokenParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AchDebitSingleUseToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAchDebitSingleUseToken(tilledAccount, paymentMethodCreateAchDebitSingleUseTokenParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a PaymentMethod object. Read the [Tilled.js reference](#section/Tilled.js) to learn how to create PaymentMethods via Tilled.js. One of the following is required to create a payment method: `card`, `payment_token`, `terminal_reader_id`, `ach_debit`, or `eft_debit`.
         * @summary Create a PaymentMethod
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {PaymentMethodCreateParams} paymentMethodCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentMethod(tilledAccount: string, paymentMethodCreateParams: PaymentMethodCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentMethod(tilledAccount, paymentMethodCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Detaches a PaymentMethod from a Customer. Once a payment method is detached it can no longer be used to make a charge.
         * @summary Detach a PaymentMethod from a Customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachPaymentMethodFromCustomer(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachPaymentMethodFromCustomer(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a PaymentMethod object.
         * @summary Retrieve a PaymentMethod
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethod(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentMethod(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of PaymentMethods for a given Customer
         * @summary List a customer\'s PaymentMethods
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {'card' | 'ach_debit' | 'card_present' | 'eft_debit'} type Only return payment methods of the given type.
         * @param {string} customerId Customer identifier
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPaymentMethods(tilledAccount: string, type: 'card' | 'ach_debit' | 'card_present' | 'eft_debit', customerId: string, metadata?: { [key: string]: string; }, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentMethods200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentMethods(tilledAccount, type, customerId, metadata, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a PaymentMethod object. A PaymentMethod must be attached to a customer to be updated.
         * @summary Update a PaymentMethod
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentMethodUpdateParams} paymentMethodUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentMethod(tilledAccount: string, id: string, paymentMethodUpdateParams: PaymentMethodUpdateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentMethod(tilledAccount, id, paymentMethodUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentMethodsApi - factory interface
 * @export
 */
export const PaymentMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentMethodsApiFp(configuration)
    return {
        /**
         * Attaches a PaymentMethod to a Customer. This effectively changes the payment method from single-use to reusable.
         * @summary Attach a PaymentMethod to a Customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentMethodAttachParams} paymentMethodAttachParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachPaymentMethodToCustomer(tilledAccount: string, id: string, paymentMethodAttachParams: PaymentMethodAttachParams, options?: any): AxiosPromise<PaymentMethod> {
            return localVarFp.attachPaymentMethodToCustomer(tilledAccount, id, paymentMethodAttachParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an ACH Debit Single-Use Token, for use in creating a PaymentMethod.
         * @summary Create ACH Debit Single-Use Token
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {PaymentMethodCreateAchDebitSingleUseTokenParams} paymentMethodCreateAchDebitSingleUseTokenParams 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createAchDebitSingleUseToken(tilledAccount: string, paymentMethodCreateAchDebitSingleUseTokenParams: PaymentMethodCreateAchDebitSingleUseTokenParams, options?: any): AxiosPromise<AchDebitSingleUseToken> {
            return localVarFp.createAchDebitSingleUseToken(tilledAccount, paymentMethodCreateAchDebitSingleUseTokenParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a PaymentMethod object. Read the [Tilled.js reference](#section/Tilled.js) to learn how to create PaymentMethods via Tilled.js. One of the following is required to create a payment method: `card`, `payment_token`, `terminal_reader_id`, `ach_debit`, or `eft_debit`.
         * @summary Create a PaymentMethod
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {PaymentMethodCreateParams} paymentMethodCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod(tilledAccount: string, paymentMethodCreateParams: PaymentMethodCreateParams, options?: any): AxiosPromise<PaymentMethod> {
            return localVarFp.createPaymentMethod(tilledAccount, paymentMethodCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches a PaymentMethod from a Customer. Once a payment method is detached it can no longer be used to make a charge.
         * @summary Detach a PaymentMethod from a Customer
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachPaymentMethodFromCustomer(tilledAccount: string, id: string, options?: any): AxiosPromise<PaymentMethod> {
            return localVarFp.detachPaymentMethodFromCustomer(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a PaymentMethod object.
         * @summary Retrieve a PaymentMethod
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(tilledAccount: string, id: string, options?: any): AxiosPromise<PaymentMethod> {
            return localVarFp.getPaymentMethod(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of PaymentMethods for a given Customer
         * @summary List a customer\'s PaymentMethods
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {'card' | 'ach_debit' | 'card_present' | 'eft_debit'} type Only return payment methods of the given type.
         * @param {string} customerId Customer identifier
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentMethods(tilledAccount: string, type: 'card' | 'ach_debit' | 'card_present' | 'eft_debit', customerId: string, metadata?: { [key: string]: string; }, offset?: number, limit?: number, options?: any): AxiosPromise<ListPaymentMethods200Response> {
            return localVarFp.listPaymentMethods(tilledAccount, type, customerId, metadata, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a PaymentMethod object. A PaymentMethod must be attached to a customer to be updated.
         * @summary Update a PaymentMethod
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {PaymentMethodUpdateParams} paymentMethodUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethod(tilledAccount: string, id: string, paymentMethodUpdateParams: PaymentMethodUpdateParams, options?: any): AxiosPromise<PaymentMethod> {
            return localVarFp.updatePaymentMethod(tilledAccount, id, paymentMethodUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentMethodsApi - object-oriented interface
 * @export
 * @class PaymentMethodsApi
 * @extends {BaseAPI}
 */
export class PaymentMethodsApi extends BaseAPI {
    /**
     * Attaches a PaymentMethod to a Customer. This effectively changes the payment method from single-use to reusable.
     * @summary Attach a PaymentMethod to a Customer
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {PaymentMethodAttachParams} paymentMethodAttachParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    public attachPaymentMethodToCustomer(tilledAccount: string, id: string, paymentMethodAttachParams: PaymentMethodAttachParams, options?: AxiosRequestConfig) {
        return PaymentMethodsApiFp(this.configuration).attachPaymentMethodToCustomer(tilledAccount, id, paymentMethodAttachParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an ACH Debit Single-Use Token, for use in creating a PaymentMethod.
     * @summary Create ACH Debit Single-Use Token
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {PaymentMethodCreateAchDebitSingleUseTokenParams} paymentMethodCreateAchDebitSingleUseTokenParams 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    public createAchDebitSingleUseToken(tilledAccount: string, paymentMethodCreateAchDebitSingleUseTokenParams: PaymentMethodCreateAchDebitSingleUseTokenParams, options?: AxiosRequestConfig) {
        return PaymentMethodsApiFp(this.configuration).createAchDebitSingleUseToken(tilledAccount, paymentMethodCreateAchDebitSingleUseTokenParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a PaymentMethod object. Read the [Tilled.js reference](#section/Tilled.js) to learn how to create PaymentMethods via Tilled.js. One of the following is required to create a payment method: `card`, `payment_token`, `terminal_reader_id`, `ach_debit`, or `eft_debit`.
     * @summary Create a PaymentMethod
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {PaymentMethodCreateParams} paymentMethodCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    public createPaymentMethod(tilledAccount: string, paymentMethodCreateParams: PaymentMethodCreateParams, options?: AxiosRequestConfig) {
        return PaymentMethodsApiFp(this.configuration).createPaymentMethod(tilledAccount, paymentMethodCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detaches a PaymentMethod from a Customer. Once a payment method is detached it can no longer be used to make a charge.
     * @summary Detach a PaymentMethod from a Customer
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    public detachPaymentMethodFromCustomer(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return PaymentMethodsApiFp(this.configuration).detachPaymentMethodFromCustomer(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a PaymentMethod object.
     * @summary Retrieve a PaymentMethod
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    public getPaymentMethod(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return PaymentMethodsApiFp(this.configuration).getPaymentMethod(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of PaymentMethods for a given Customer
     * @summary List a customer\'s PaymentMethods
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {'card' | 'ach_debit' | 'card_present' | 'eft_debit'} type Only return payment methods of the given type.
     * @param {string} customerId Customer identifier
     * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    public listPaymentMethods(tilledAccount: string, type: 'card' | 'ach_debit' | 'card_present' | 'eft_debit', customerId: string, metadata?: { [key: string]: string; }, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return PaymentMethodsApiFp(this.configuration).listPaymentMethods(tilledAccount, type, customerId, metadata, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a PaymentMethod object. A PaymentMethod must be attached to a customer to be updated.
     * @summary Update a PaymentMethod
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {PaymentMethodUpdateParams} paymentMethodUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodsApi
     */
    public updatePaymentMethod(tilledAccount: string, id: string, paymentMethodUpdateParams: PaymentMethodUpdateParams, options?: AxiosRequestConfig) {
        return PaymentMethodsApiFp(this.configuration).updatePaymentMethod(tilledAccount, id, paymentMethodUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PayoutsApi - axios parameter creator
 * @export
 */
export const PayoutsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the details of an existing payout with the given ID.
         * @summary Retrieve a payout
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {'transaction_count'} [include] An array of optional include parameters, specifying extra properties to return. Currently for this endpoint only accepts \&#39;transaction_count\&#39;. In the query parameters, this is specified as include&#x3D;value1,value2,value3,etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayout: async (tilledAccount: string, id: string, include?: 'transaction_count', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getPayout', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPayout', 'id', id)
            const localVarPath = `/v1/payouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of existing payouts. The payouts are returned in sorted order, with the most recent payouts appearing first.
         * @summary List all payouts
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive). Cannot be paired with paid_at_gte or paid_at_lte.
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive). Cannot be paired with paid_at_gte or paid_at_lte.
         * @param {string} [paidAtGte] Minimum &#x60;paid_at&#x60; value to filter by (inclusive). Cannot be paired with created_at_gte or created_at_lte.
         * @param {string} [paidAtLte] Maximum &#x60;paid_at&#x60; value to filter by (inclusive). Cannot be paired with created_at_gte or created_at_lte.
         * @param {'canceled' | 'failed' | 'in_transit' | 'paid' | 'pending'} [status] Only return payouts that have the given status.
         * @param {'transaction_count'} [include] An array of optional include parameters, specifying extra properties to return. Currently for this endpoint only accepts \&#39;transaction_count\&#39;. In the query parameters, this is specified as include&#x3D;value1,value2,value3,etc.
         * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayouts: async (tilledAccount: string, createdAtGte?: string, createdAtLte?: string, paidAtGte?: string, paidAtLte?: string, status?: 'canceled' | 'failed' | 'in_transit' | 'paid' | 'pending', include?: 'transaction_count', includeConnectedAccounts?: boolean, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listPayouts', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (paidAtGte !== undefined) {
                localVarQueryParameter['paid_at_gte'] = (paidAtGte as any instanceof Date) ?
                    (paidAtGte as any).toISOString() :
                    paidAtGte;
            }

            if (paidAtLte !== undefined) {
                localVarQueryParameter['paid_at_lte'] = (paidAtLte as any instanceof Date) ?
                    (paidAtLte as any).toISOString() :
                    paidAtLte;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (includeConnectedAccounts !== undefined) {
                localVarQueryParameter['include_connected_accounts'] = includeConnectedAccounts;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a payout summary object, which aggregates payout, charge, and refund balance transactions associated with a list of payout ID(s) and/or a date range. Must include either a date range or list of payout ID(s) in request query parameters.
         * @summary Provide payout summary
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [paidAtGte] Minimum &#x60;paid_at&#x60; value to filter by (inclusive).
         * @param {string} [paidAtLte] Maximum &#x60;paid_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to the beginning of the current month.
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to midnight tonight.
         * @param {Array<string>} [payoutIds] array of payout_id(s) that we want to return a payout summary of
         * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutSummary: async (tilledAccount: string, paidAtGte?: string, paidAtLte?: string, createdAtGte?: string, createdAtLte?: string, payoutIds?: Array<string>, includeConnectedAccounts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('payoutSummary', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/payouts/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (paidAtGte !== undefined) {
                localVarQueryParameter['paid_at_gte'] = (paidAtGte as any instanceof Date) ?
                    (paidAtGte as any).toISOString() :
                    paidAtGte;
            }

            if (paidAtLte !== undefined) {
                localVarQueryParameter['paid_at_lte'] = (paidAtLte as any instanceof Date) ?
                    (paidAtLte as any).toISOString() :
                    paidAtLte;
            }

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (payoutIds) {
                localVarQueryParameter['payout_ids'] = payoutIds;
            }

            if (includeConnectedAccounts !== undefined) {
                localVarQueryParameter['include_connected_accounts'] = includeConnectedAccounts;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayoutsApi - functional programming interface
 * @export
 */
export const PayoutsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayoutsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the details of an existing payout with the given ID.
         * @summary Retrieve a payout
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {'transaction_count'} [include] An array of optional include parameters, specifying extra properties to return. Currently for this endpoint only accepts \&#39;transaction_count\&#39;. In the query parameters, this is specified as include&#x3D;value1,value2,value3,etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayout(tilledAccount: string, id: string, include?: 'transaction_count', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayout(tilledAccount, id, include, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of existing payouts. The payouts are returned in sorted order, with the most recent payouts appearing first.
         * @summary List all payouts
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive). Cannot be paired with paid_at_gte or paid_at_lte.
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive). Cannot be paired with paid_at_gte or paid_at_lte.
         * @param {string} [paidAtGte] Minimum &#x60;paid_at&#x60; value to filter by (inclusive). Cannot be paired with created_at_gte or created_at_lte.
         * @param {string} [paidAtLte] Maximum &#x60;paid_at&#x60; value to filter by (inclusive). Cannot be paired with created_at_gte or created_at_lte.
         * @param {'canceled' | 'failed' | 'in_transit' | 'paid' | 'pending'} [status] Only return payouts that have the given status.
         * @param {'transaction_count'} [include] An array of optional include parameters, specifying extra properties to return. Currently for this endpoint only accepts \&#39;transaction_count\&#39;. In the query parameters, this is specified as include&#x3D;value1,value2,value3,etc.
         * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPayouts(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, paidAtGte?: string, paidAtLte?: string, status?: 'canceled' | 'failed' | 'in_transit' | 'paid' | 'pending', include?: 'transaction_count', includeConnectedAccounts?: boolean, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPayouts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayouts(tilledAccount, createdAtGte, createdAtLte, paidAtGte, paidAtLte, status, include, includeConnectedAccounts, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a payout summary object, which aggregates payout, charge, and refund balance transactions associated with a list of payout ID(s) and/or a date range. Must include either a date range or list of payout ID(s) in request query parameters.
         * @summary Provide payout summary
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [paidAtGte] Minimum &#x60;paid_at&#x60; value to filter by (inclusive).
         * @param {string} [paidAtLte] Maximum &#x60;paid_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to the beginning of the current month.
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to midnight tonight.
         * @param {Array<string>} [payoutIds] array of payout_id(s) that we want to return a payout summary of
         * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payoutSummary(tilledAccount: string, paidAtGte?: string, paidAtLte?: string, createdAtGte?: string, createdAtLte?: string, payoutIds?: Array<string>, includeConnectedAccounts?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PayoutSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payoutSummary(tilledAccount, paidAtGte, paidAtLte, createdAtGte, createdAtLte, payoutIds, includeConnectedAccounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PayoutsApi - factory interface
 * @export
 */
export const PayoutsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayoutsApiFp(configuration)
    return {
        /**
         * Retrieves the details of an existing payout with the given ID.
         * @summary Retrieve a payout
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {'transaction_count'} [include] An array of optional include parameters, specifying extra properties to return. Currently for this endpoint only accepts \&#39;transaction_count\&#39;. In the query parameters, this is specified as include&#x3D;value1,value2,value3,etc.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayout(tilledAccount: string, id: string, include?: 'transaction_count', options?: any): AxiosPromise<Payout> {
            return localVarFp.getPayout(tilledAccount, id, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of existing payouts. The payouts are returned in sorted order, with the most recent payouts appearing first.
         * @summary List all payouts
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive). Cannot be paired with paid_at_gte or paid_at_lte.
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive). Cannot be paired with paid_at_gte or paid_at_lte.
         * @param {string} [paidAtGte] Minimum &#x60;paid_at&#x60; value to filter by (inclusive). Cannot be paired with created_at_gte or created_at_lte.
         * @param {string} [paidAtLte] Maximum &#x60;paid_at&#x60; value to filter by (inclusive). Cannot be paired with created_at_gte or created_at_lte.
         * @param {'canceled' | 'failed' | 'in_transit' | 'paid' | 'pending'} [status] Only return payouts that have the given status.
         * @param {'transaction_count'} [include] An array of optional include parameters, specifying extra properties to return. Currently for this endpoint only accepts \&#39;transaction_count\&#39;. In the query parameters, this is specified as include&#x3D;value1,value2,value3,etc.
         * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayouts(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, paidAtGte?: string, paidAtLte?: string, status?: 'canceled' | 'failed' | 'in_transit' | 'paid' | 'pending', include?: 'transaction_count', includeConnectedAccounts?: boolean, offset?: number, limit?: number, options?: any): AxiosPromise<ListPayouts200Response> {
            return localVarFp.listPayouts(tilledAccount, createdAtGte, createdAtLte, paidAtGte, paidAtLte, status, include, includeConnectedAccounts, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a payout summary object, which aggregates payout, charge, and refund balance transactions associated with a list of payout ID(s) and/or a date range. Must include either a date range or list of payout ID(s) in request query parameters.
         * @summary Provide payout summary
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [paidAtGte] Minimum &#x60;paid_at&#x60; value to filter by (inclusive).
         * @param {string} [paidAtLte] Maximum &#x60;paid_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to the beginning of the current month.
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to midnight tonight.
         * @param {Array<string>} [payoutIds] array of payout_id(s) that we want to return a payout summary of
         * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutSummary(tilledAccount: string, paidAtGte?: string, paidAtLte?: string, createdAtGte?: string, createdAtLte?: string, payoutIds?: Array<string>, includeConnectedAccounts?: boolean, options?: any): AxiosPromise<Array<PayoutSummary>> {
            return localVarFp.payoutSummary(tilledAccount, paidAtGte, paidAtLte, createdAtGte, createdAtLte, payoutIds, includeConnectedAccounts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayoutsApi - object-oriented interface
 * @export
 * @class PayoutsApi
 * @extends {BaseAPI}
 */
export class PayoutsApi extends BaseAPI {
    /**
     * Retrieves the details of an existing payout with the given ID.
     * @summary Retrieve a payout
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {'transaction_count'} [include] An array of optional include parameters, specifying extra properties to return. Currently for this endpoint only accepts \&#39;transaction_count\&#39;. In the query parameters, this is specified as include&#x3D;value1,value2,value3,etc.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    public getPayout(tilledAccount: string, id: string, include?: 'transaction_count', options?: AxiosRequestConfig) {
        return PayoutsApiFp(this.configuration).getPayout(tilledAccount, id, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of existing payouts. The payouts are returned in sorted order, with the most recent payouts appearing first.
     * @summary List all payouts
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive). Cannot be paired with paid_at_gte or paid_at_lte.
     * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive). Cannot be paired with paid_at_gte or paid_at_lte.
     * @param {string} [paidAtGte] Minimum &#x60;paid_at&#x60; value to filter by (inclusive). Cannot be paired with created_at_gte or created_at_lte.
     * @param {string} [paidAtLte] Maximum &#x60;paid_at&#x60; value to filter by (inclusive). Cannot be paired with created_at_gte or created_at_lte.
     * @param {'canceled' | 'failed' | 'in_transit' | 'paid' | 'pending'} [status] Only return payouts that have the given status.
     * @param {'transaction_count'} [include] An array of optional include parameters, specifying extra properties to return. Currently for this endpoint only accepts \&#39;transaction_count\&#39;. In the query parameters, this is specified as include&#x3D;value1,value2,value3,etc.
     * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    public listPayouts(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, paidAtGte?: string, paidAtLte?: string, status?: 'canceled' | 'failed' | 'in_transit' | 'paid' | 'pending', include?: 'transaction_count', includeConnectedAccounts?: boolean, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return PayoutsApiFp(this.configuration).listPayouts(tilledAccount, createdAtGte, createdAtLte, paidAtGte, paidAtLte, status, include, includeConnectedAccounts, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a payout summary object, which aggregates payout, charge, and refund balance transactions associated with a list of payout ID(s) and/or a date range. Must include either a date range or list of payout ID(s) in request query parameters.
     * @summary Provide payout summary
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} [paidAtGte] Minimum &#x60;paid_at&#x60; value to filter by (inclusive).
     * @param {string} [paidAtLte] Maximum &#x60;paid_at&#x60; value to filter by (inclusive).
     * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to the beginning of the current month.
     * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive). Defaults to midnight tonight.
     * @param {Array<string>} [payoutIds] array of payout_id(s) that we want to return a payout summary of
     * @param {boolean} [includeConnectedAccounts] Whether or not to include the results from any connected accounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutsApi
     */
    public payoutSummary(tilledAccount: string, paidAtGte?: string, paidAtLte?: string, createdAtGte?: string, createdAtLte?: string, payoutIds?: Array<string>, includeConnectedAccounts?: boolean, options?: AxiosRequestConfig) {
        return PayoutsApiFp(this.configuration).payoutSummary(tilledAccount, paidAtGte, paidAtLte, createdAtGte, createdAtLte, payoutIds, includeConnectedAccounts, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlatformFeeRefundsApi - axios parameter creator
 * @export
 */
export const PlatformFeeRefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the details of a specific refund stored on the platform fee.
         * @summary Retrieve a platform fee refund
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformFeeRefund: async (tilledAccount: string, id: string, refundId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getPlatformFeeRefund', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlatformFeeRefund', 'id', id)
            // verify required parameter 'refundId' is not null or undefined
            assertParamExists('getPlatformFeeRefund', 'refundId', refundId)
            const localVarPath = `/v1/platform-fees/{id}/refunds/{refund_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"refund_id"}}`, encodeURIComponent(String(refundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlatformFeeRefundsApi - functional programming interface
 * @export
 */
export const PlatformFeeRefundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlatformFeeRefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the details of a specific refund stored on the platform fee.
         * @summary Retrieve a platform fee refund
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatformFeeRefund(tilledAccount: string, id: string, refundId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformFeeRefund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatformFeeRefund(tilledAccount, id, refundId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlatformFeeRefundsApi - factory interface
 * @export
 */
export const PlatformFeeRefundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlatformFeeRefundsApiFp(configuration)
    return {
        /**
         * Retrieves the details of a specific refund stored on the platform fee.
         * @summary Retrieve a platform fee refund
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformFeeRefund(tilledAccount: string, id: string, refundId: string, options?: any): AxiosPromise<PlatformFeeRefund> {
            return localVarFp.getPlatformFeeRefund(tilledAccount, id, refundId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlatformFeeRefundsApi - object-oriented interface
 * @export
 * @class PlatformFeeRefundsApi
 * @extends {BaseAPI}
 */
export class PlatformFeeRefundsApi extends BaseAPI {
    /**
     * Retrieves the details of a specific refund stored on the platform fee.
     * @summary Retrieve a platform fee refund
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {string} refundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformFeeRefundsApi
     */
    public getPlatformFeeRefund(tilledAccount: string, id: string, refundId: string, options?: AxiosRequestConfig) {
        return PlatformFeeRefundsApiFp(this.configuration).getPlatformFeeRefund(tilledAccount, id, refundId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlatformFeesApi - axios parameter creator
 * @export
 */
export const PlatformFeesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the details of a platform fee that your account has collected. The same information is returned when when refunding the application fee.
         * @summary Retrieve a platform fee
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformFee: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getPlatformFee', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlatformFee', 'id', id)
            const localVarPath = `/v1/platform-fees/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of platform fees you\'ve previously collected. The platform fees are returned in a sorted order, with the most recent fees appearing first.
         * @summary List all platform fees
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [chargeId] Only return application fees for the charge specified by this charge id.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlatformFees: async (tilledAccount: string, createdAtGte?: string, createdAtLte?: string, chargeId?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listPlatformFees', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/platform-fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (createdAtGte !== undefined) {
                localVarQueryParameter['created_at_gte'] = (createdAtGte as any instanceof Date) ?
                    (createdAtGte as any).toISOString() :
                    createdAtGte;
            }

            if (createdAtLte !== undefined) {
                localVarQueryParameter['created_at_lte'] = (createdAtLte as any instanceof Date) ?
                    (createdAtLte as any).toISOString() :
                    createdAtLte;
            }

            if (chargeId !== undefined) {
                localVarQueryParameter['charge_id'] = chargeId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlatformFeesApi - functional programming interface
 * @export
 */
export const PlatformFeesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlatformFeesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the details of a platform fee that your account has collected. The same information is returned when when refunding the application fee.
         * @summary Retrieve a platform fee
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatformFee(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformFee>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatformFee(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of platform fees you\'ve previously collected. The platform fees are returned in a sorted order, with the most recent fees appearing first.
         * @summary List all platform fees
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [chargeId] Only return application fees for the charge specified by this charge id.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlatformFees(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, chargeId?: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPlatformFees200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlatformFees(tilledAccount, createdAtGte, createdAtLte, chargeId, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlatformFeesApi - factory interface
 * @export
 */
export const PlatformFeesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlatformFeesApiFp(configuration)
    return {
        /**
         * Retrieves the details of a platform fee that your account has collected. The same information is returned when when refunding the application fee.
         * @summary Retrieve a platform fee
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformFee(tilledAccount: string, id: string, options?: any): AxiosPromise<PlatformFee> {
            return localVarFp.getPlatformFee(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of platform fees you\'ve previously collected. The platform fees are returned in a sorted order, with the most recent fees appearing first.
         * @summary List all platform fees
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
         * @param {string} [chargeId] Only return application fees for the charge specified by this charge id.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlatformFees(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, chargeId?: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListPlatformFees200Response> {
            return localVarFp.listPlatformFees(tilledAccount, createdAtGte, createdAtLte, chargeId, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlatformFeesApi - object-oriented interface
 * @export
 * @class PlatformFeesApi
 * @extends {BaseAPI}
 */
export class PlatformFeesApi extends BaseAPI {
    /**
     * Retrieves the details of a platform fee that your account has collected. The same information is returned when when refunding the application fee.
     * @summary Retrieve a platform fee
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformFeesApi
     */
    public getPlatformFee(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return PlatformFeesApiFp(this.configuration).getPlatformFee(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of platform fees you\'ve previously collected. The platform fees are returned in a sorted order, with the most recent fees appearing first.
     * @summary List all platform fees
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} [createdAtGte] Minimum &#x60;created_at&#x60; value to filter by (inclusive).
     * @param {string} [createdAtLte] Maximum &#x60;created_at&#x60; value to filter by (inclusive).
     * @param {string} [chargeId] Only return application fees for the charge specified by this charge id.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformFeesApi
     */
    public listPlatformFees(tilledAccount: string, createdAtGte?: string, createdAtLte?: string, chargeId?: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return PlatformFeesApiFp(this.configuration).listPlatformFees(tilledAccount, createdAtGte, createdAtLte, chargeId, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductCodesApi - axios parameter creator
 * @export
 */
export const ProductCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of ProductCodes available to a given `partner` account. These are the product codes that are available to be assigned to `merchant` accounts during merchant onboarding.
         * @summary List an account\'s ProductCodes
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductCodes: async (tilledAccount: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listProductCodes', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/product-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductCodesApi - functional programming interface
 * @export
 */
export const ProductCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of ProductCodes available to a given `partner` account. These are the product codes that are available to be assigned to `merchant` accounts during merchant onboarding.
         * @summary List an account\'s ProductCodes
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductCodes(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProductCodes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProductCodes(tilledAccount, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductCodesApi - factory interface
 * @export
 */
export const ProductCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductCodesApiFp(configuration)
    return {
        /**
         * Returns a list of ProductCodes available to a given `partner` account. These are the product codes that are available to be assigned to `merchant` accounts during merchant onboarding.
         * @summary List an account\'s ProductCodes
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductCodes(tilledAccount: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListProductCodes200Response> {
            return localVarFp.listProductCodes(tilledAccount, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductCodesApi - object-oriented interface
 * @export
 * @class ProductCodesApi
 * @extends {BaseAPI}
 */
export class ProductCodesApi extends BaseAPI {
    /**
     * Returns a list of ProductCodes available to a given `partner` account. These are the product codes that are available to be assigned to `merchant` accounts during merchant onboarding.
     * @summary List an account\'s ProductCodes
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCodesApi
     */
    public listProductCodes(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return ProductCodesApiFp(this.configuration).listProductCodes(tilledAccount, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RefundsApi - axios parameter creator
 * @export
 */
export const RefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * When you create a new refund, you must specify a PaymentIntent object on which to create it.  Creating a new refund will refund a charge that has previously been created but not yet refunded. Funds will be refunded to the original payment method.  You can optionally refund only part of a charge. You can do so multiple times, until the entire charge has been refunded.  Once entirely refunded, a charge can\'t be refunded again. This method will throw an error when called on an already-refunded charge, or when trying to refund more money than is left on a charge.
         * @summary Create a refund
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {RefundCreateParams} refundCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund: async (tilledAccount: string, refundCreateParams: RefundCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createRefund', 'tilledAccount', tilledAccount)
            // verify required parameter 'refundCreateParams' is not null or undefined
            assertParamExists('createRefund', 'refundCreateParams', refundCreateParams)
            const localVarPath = `/v1/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing refund.
         * @summary Retrieve a refund
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefund: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('getRefund', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRefund', 'id', id)
            const localVarPath = `/v1/refunds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Refunds. The refunds are returned in a sorted order, with the most recent refunds appearing first.
         * @summary List all refunds
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds: async (tilledAccount: string, metadata?: { [key: string]: string; }, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listRefunds', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefundsApi - functional programming interface
 * @export
 */
export const RefundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * When you create a new refund, you must specify a PaymentIntent object on which to create it.  Creating a new refund will refund a charge that has previously been created but not yet refunded. Funds will be refunded to the original payment method.  You can optionally refund only part of a charge. You can do so multiple times, until the entire charge has been refunded.  Once entirely refunded, a charge can\'t be refunded again. This method will throw an error when called on an already-refunded charge, or when trying to refund more money than is left on a charge.
         * @summary Create a refund
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {RefundCreateParams} refundCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRefund(tilledAccount: string, refundCreateParams: RefundCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRefund(tilledAccount, refundCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing refund.
         * @summary Retrieve a refund
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRefund(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRefund(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Refunds. The refunds are returned in a sorted order, with the most recent refunds appearing first.
         * @summary List all refunds
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRefunds(tilledAccount: string, metadata?: { [key: string]: string; }, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRefunds200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRefunds(tilledAccount, metadata, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RefundsApi - factory interface
 * @export
 */
export const RefundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefundsApiFp(configuration)
    return {
        /**
         * When you create a new refund, you must specify a PaymentIntent object on which to create it.  Creating a new refund will refund a charge that has previously been created but not yet refunded. Funds will be refunded to the original payment method.  You can optionally refund only part of a charge. You can do so multiple times, until the entire charge has been refunded.  Once entirely refunded, a charge can\'t be refunded again. This method will throw an error when called on an already-refunded charge, or when trying to refund more money than is left on a charge.
         * @summary Create a refund
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {RefundCreateParams} refundCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund(tilledAccount: string, refundCreateParams: RefundCreateParams, options?: any): AxiosPromise<Refund> {
            return localVarFp.createRefund(tilledAccount, refundCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing refund.
         * @summary Retrieve a refund
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefund(tilledAccount: string, id: string, options?: any): AxiosPromise<Refund> {
            return localVarFp.getRefund(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Refunds. The refunds are returned in a sorted order, with the most recent refunds appearing first.
         * @summary List all refunds
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds(tilledAccount: string, metadata?: { [key: string]: string; }, offset?: number, limit?: number, options?: any): AxiosPromise<ListRefunds200Response> {
            return localVarFp.listRefunds(tilledAccount, metadata, offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RefundsApi - object-oriented interface
 * @export
 * @class RefundsApi
 * @extends {BaseAPI}
 */
export class RefundsApi extends BaseAPI {
    /**
     * When you create a new refund, you must specify a PaymentIntent object on which to create it.  Creating a new refund will refund a charge that has previously been created but not yet refunded. Funds will be refunded to the original payment method.  You can optionally refund only part of a charge. You can do so multiple times, until the entire charge has been refunded.  Once entirely refunded, a charge can\'t be refunded again. This method will throw an error when called on an already-refunded charge, or when trying to refund more money than is left on a charge.
     * @summary Create a refund
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {RefundCreateParams} refundCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public createRefund(tilledAccount: string, refundCreateParams: RefundCreateParams, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).createRefund(tilledAccount, refundCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing refund.
     * @summary Retrieve a refund
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public getRefund(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).getRefund(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Refunds. The refunds are returned in a sorted order, with the most recent refunds appearing first.
     * @summary List all refunds
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public listRefunds(tilledAccount: string, metadata?: { [key: string]: string; }, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).listRefunds(tilledAccount, metadata, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportRunsApi - axios parameter creator
 * @export
 */
export const ReportRunsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a Report Run
         * @summary Create a Report Run
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {ReportRunCreateParams} reportRunCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReportRun: async (tilledAccount: string, reportRunCreateParams: ReportRunCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createReportRun', 'tilledAccount', tilledAccount)
            // verify required parameter 'reportRunCreateParams' is not null or undefined
            assertParamExists('createReportRun', 'reportRunCreateParams', reportRunCreateParams)
            const localVarPath = `/v1/report-runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportRunCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of report runs
         * @summary List all Report Runs
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {ReportRunRetrieveParams} reportRunRetrieveParams 
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllReportRuns: async (tilledAccount: string, reportRunRetrieveParams: ReportRunRetrieveParams, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listAllReportRuns', 'tilledAccount', tilledAccount)
            // verify required parameter 'reportRunRetrieveParams' is not null or undefined
            assertParamExists('listAllReportRuns', 'reportRunRetrieveParams', reportRunRetrieveParams)
            const localVarPath = `/v1/report-runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportRunRetrieveParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the report run with the given ID.
         * @summary Retrieve a Report Run
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveReportRun: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('retrieveReportRun', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveReportRun', 'id', id)
            const localVarPath = `/v1/report-runs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportRunsApi - functional programming interface
 * @export
 */
export const ReportRunsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportRunsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a Report Run
         * @summary Create a Report Run
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {ReportRunCreateParams} reportRunCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReportRun(tilledAccount: string, reportRunCreateParams: ReportRunCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReportRun(tilledAccount, reportRunCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of report runs
         * @summary List all Report Runs
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {ReportRunRetrieveParams} reportRunRetrieveParams 
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllReportRuns(tilledAccount: string, reportRunRetrieveParams: ReportRunRetrieveParams, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllReportRuns200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllReportRuns(tilledAccount, reportRunRetrieveParams, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the report run with the given ID.
         * @summary Retrieve a Report Run
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveReportRun(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveReportRun(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportRunsApi - factory interface
 * @export
 */
export const ReportRunsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportRunsApiFp(configuration)
    return {
        /**
         * Creates a Report Run
         * @summary Create a Report Run
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {ReportRunCreateParams} reportRunCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReportRun(tilledAccount: string, reportRunCreateParams: ReportRunCreateParams, options?: any): AxiosPromise<ReportRun> {
            return localVarFp.createReportRun(tilledAccount, reportRunCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of report runs
         * @summary List all Report Runs
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {ReportRunRetrieveParams} reportRunRetrieveParams 
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllReportRuns(tilledAccount: string, reportRunRetrieveParams: ReportRunRetrieveParams, offset?: number, limit?: number, options?: any): AxiosPromise<ListAllReportRuns200Response> {
            return localVarFp.listAllReportRuns(tilledAccount, reportRunRetrieveParams, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the report run with the given ID.
         * @summary Retrieve a Report Run
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveReportRun(tilledAccount: string, id: string, options?: any): AxiosPromise<ReportRun> {
            return localVarFp.retrieveReportRun(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportRunsApi - object-oriented interface
 * @export
 * @class ReportRunsApi
 * @extends {BaseAPI}
 */
export class ReportRunsApi extends BaseAPI {
    /**
     * Creates a Report Run
     * @summary Create a Report Run
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {ReportRunCreateParams} reportRunCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportRunsApi
     */
    public createReportRun(tilledAccount: string, reportRunCreateParams: ReportRunCreateParams, options?: AxiosRequestConfig) {
        return ReportRunsApiFp(this.configuration).createReportRun(tilledAccount, reportRunCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of report runs
     * @summary List all Report Runs
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {ReportRunRetrieveParams} reportRunRetrieveParams 
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportRunsApi
     */
    public listAllReportRuns(tilledAccount: string, reportRunRetrieveParams: ReportRunRetrieveParams, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return ReportRunsApiFp(this.configuration).listAllReportRuns(tilledAccount, reportRunRetrieveParams, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the report run with the given ID.
     * @summary Retrieve a Report Run
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportRunsApi
     */
    public retrieveReportRun(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return ReportRunsApiFp(this.configuration).retrieveReportRun(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels a customer\'s subscription immediately. The customer will not be charged again for the subscription.
         * @summary Cancel a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('cancelSubscription', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelSubscription', 'id', id)
            const localVarPath = `/v1/subscriptions/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new subscription on an existing customer.
         * @summary Create a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {SubscriptionCreateParams} subscriptionCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (tilledAccount: string, subscriptionCreateParams: SubscriptionCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createSubscription', 'tilledAccount', tilledAccount)
            // verify required parameter 'subscriptionCreateParams' is not null or undefined
            assertParamExists('createSubscription', 'subscriptionCreateParams', subscriptionCreateParams)
            const localVarPath = `/v1/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your subscriptions.
         * @summary List all Subscriptions
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {string} [customerId] The ID of the customer whose subscriptions will be retrieved.
         * @param {'active' | 'canceled' | 'past_due' | 'paused' | 'pending'} [status] The status of the subscriptions to retrieve.
         * @param {string} [nextPaymentAtLte] Maximum &#x60;next_payment_at&#x60; value to filter by (inclusive).
         * @param {string} [nextPaymentAtGte] Minimum &#x60;next_payment_at&#x60; value to filter by (inclusive).
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllSubscriptions: async (tilledAccount: string, metadata?: { [key: string]: string; }, customerId?: string, status?: 'active' | 'canceled' | 'past_due' | 'paused' | 'pending', nextPaymentAtLte?: string, nextPaymentAtGte?: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listAllSubscriptions', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (customerId !== undefined) {
                localVarQueryParameter['customer_id'] = customerId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (nextPaymentAtLte !== undefined) {
                localVarQueryParameter['next_payment_at_lte'] = (nextPaymentAtLte as any instanceof Date) ?
                    (nextPaymentAtLte as any).toISOString() :
                    nextPaymentAtLte;
            }

            if (nextPaymentAtGte !== undefined) {
                localVarQueryParameter['next_payment_at_gte'] = (nextPaymentAtGte as any instanceof Date) ?
                    (nextPaymentAtGte as any).toISOString() :
                    nextPaymentAtGte;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pauses a subscription from generating payments until the (optionally) specified `resumes_at` date.
         * @summary Pause a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {SubscriptionPauseParams} subscriptionPauseParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseSubscription: async (tilledAccount: string, id: string, subscriptionPauseParams: SubscriptionPauseParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('pauseSubscription', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pauseSubscription', 'id', id)
            // verify required parameter 'subscriptionPauseParams' is not null or undefined
            assertParamExists('pauseSubscription', 'subscriptionPauseParams', subscriptionPauseParams)
            const localVarPath = `/v1/subscriptions/{id}/pause`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionPauseParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resumes a paused subscription immediately. The next charge will occur on the normally scheduled billing cycle.
         * @summary Resume a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeSubscription: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('resumeSubscription', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resumeSubscription', 'id', id)
            const localVarPath = `/v1/subscriptions/{id}/resume`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the subscription with the given ID.
         * @summary Retrieve a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSubscription: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('retrieveSubscription', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSubscription', 'id', id)
            const localVarPath = `/v1/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retry a subscription payment at the (optionally) specified `next_payment_at` date.
         * @summary Retry a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {SubscriptionRetryParams} subscriptionRetryParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrySubscription: async (tilledAccount: string, id: string, subscriptionRetryParams: SubscriptionRetryParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('retrySubscription', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrySubscription', 'id', id)
            // verify required parameter 'subscriptionRetryParams' is not null or undefined
            assertParamExists('retrySubscription', 'subscriptionRetryParams', subscriptionRetryParams)
            const localVarPath = `/v1/subscriptions/{id}/retry`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionRetryParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing subscription to match the specified parameters.
         * @summary Update a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {SubscriptionUpdateParams} subscriptionUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription: async (tilledAccount: string, id: string, subscriptionUpdateParams: SubscriptionUpdateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('updateSubscription', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSubscription', 'id', id)
            // verify required parameter 'subscriptionUpdateParams' is not null or undefined
            assertParamExists('updateSubscription', 'subscriptionUpdateParams', subscriptionUpdateParams)
            const localVarPath = `/v1/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels a customer\'s subscription immediately. The customer will not be charged again for the subscription.
         * @summary Cancel a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscription(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscription(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new subscription on an existing customer.
         * @summary Create a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {SubscriptionCreateParams} subscriptionCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(tilledAccount: string, subscriptionCreateParams: SubscriptionCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(tilledAccount, subscriptionCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your subscriptions.
         * @summary List all Subscriptions
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {string} [customerId] The ID of the customer whose subscriptions will be retrieved.
         * @param {'active' | 'canceled' | 'past_due' | 'paused' | 'pending'} [status] The status of the subscriptions to retrieve.
         * @param {string} [nextPaymentAtLte] Maximum &#x60;next_payment_at&#x60; value to filter by (inclusive).
         * @param {string} [nextPaymentAtGte] Minimum &#x60;next_payment_at&#x60; value to filter by (inclusive).
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllSubscriptions(tilledAccount: string, metadata?: { [key: string]: string; }, customerId?: string, status?: 'active' | 'canceled' | 'past_due' | 'paused' | 'pending', nextPaymentAtLte?: string, nextPaymentAtGte?: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllSubscriptions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllSubscriptions(tilledAccount, metadata, customerId, status, nextPaymentAtLte, nextPaymentAtGte, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Pauses a subscription from generating payments until the (optionally) specified `resumes_at` date.
         * @summary Pause a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {SubscriptionPauseParams} subscriptionPauseParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pauseSubscription(tilledAccount: string, id: string, subscriptionPauseParams: SubscriptionPauseParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pauseSubscription(tilledAccount, id, subscriptionPauseParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resumes a paused subscription immediately. The next charge will occur on the normally scheduled billing cycle.
         * @summary Resume a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeSubscription(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeSubscription(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the subscription with the given ID.
         * @summary Retrieve a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSubscription(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSubscription(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retry a subscription payment at the (optionally) specified `next_payment_at` date.
         * @summary Retry a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {SubscriptionRetryParams} subscriptionRetryParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrySubscription(tilledAccount: string, id: string, subscriptionRetryParams: SubscriptionRetryParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrySubscription(tilledAccount, id, subscriptionRetryParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing subscription to match the specified parameters.
         * @summary Update a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {SubscriptionUpdateParams} subscriptionUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscription(tilledAccount: string, id: string, subscriptionUpdateParams: SubscriptionUpdateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscription(tilledAccount, id, subscriptionUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * Cancels a customer\'s subscription immediately. The customer will not be charged again for the subscription.
         * @summary Cancel a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription(tilledAccount: string, id: string, options?: any): AxiosPromise<Subscription> {
            return localVarFp.cancelSubscription(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new subscription on an existing customer.
         * @summary Create a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {SubscriptionCreateParams} subscriptionCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(tilledAccount: string, subscriptionCreateParams: SubscriptionCreateParams, options?: any): AxiosPromise<Subscription> {
            return localVarFp.createSubscription(tilledAccount, subscriptionCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your subscriptions.
         * @summary List all Subscriptions
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
         * @param {string} [customerId] The ID of the customer whose subscriptions will be retrieved.
         * @param {'active' | 'canceled' | 'past_due' | 'paused' | 'pending'} [status] The status of the subscriptions to retrieve.
         * @param {string} [nextPaymentAtLte] Maximum &#x60;next_payment_at&#x60; value to filter by (inclusive).
         * @param {string} [nextPaymentAtGte] Minimum &#x60;next_payment_at&#x60; value to filter by (inclusive).
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllSubscriptions(tilledAccount: string, metadata?: { [key: string]: string; }, customerId?: string, status?: 'active' | 'canceled' | 'past_due' | 'paused' | 'pending', nextPaymentAtLte?: string, nextPaymentAtGte?: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListAllSubscriptions200Response> {
            return localVarFp.listAllSubscriptions(tilledAccount, metadata, customerId, status, nextPaymentAtLte, nextPaymentAtGte, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Pauses a subscription from generating payments until the (optionally) specified `resumes_at` date.
         * @summary Pause a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {SubscriptionPauseParams} subscriptionPauseParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseSubscription(tilledAccount: string, id: string, subscriptionPauseParams: SubscriptionPauseParams, options?: any): AxiosPromise<Subscription> {
            return localVarFp.pauseSubscription(tilledAccount, id, subscriptionPauseParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes a paused subscription immediately. The next charge will occur on the normally scheduled billing cycle.
         * @summary Resume a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeSubscription(tilledAccount: string, id: string, options?: any): AxiosPromise<Subscription> {
            return localVarFp.resumeSubscription(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the subscription with the given ID.
         * @summary Retrieve a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSubscription(tilledAccount: string, id: string, options?: any): AxiosPromise<Subscription> {
            return localVarFp.retrieveSubscription(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retry a subscription payment at the (optionally) specified `next_payment_at` date.
         * @summary Retry a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {SubscriptionRetryParams} subscriptionRetryParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrySubscription(tilledAccount: string, id: string, subscriptionRetryParams: SubscriptionRetryParams, options?: any): AxiosPromise<Subscription> {
            return localVarFp.retrySubscription(tilledAccount, id, subscriptionRetryParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing subscription to match the specified parameters.
         * @summary Update a Subscription
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {SubscriptionUpdateParams} subscriptionUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription(tilledAccount: string, id: string, subscriptionUpdateParams: SubscriptionUpdateParams, options?: any): AxiosPromise<Subscription> {
            return localVarFp.updateSubscription(tilledAccount, id, subscriptionUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * Cancels a customer\'s subscription immediately. The customer will not be charged again for the subscription.
     * @summary Cancel a Subscription
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public cancelSubscription(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).cancelSubscription(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new subscription on an existing customer.
     * @summary Create a Subscription
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {SubscriptionCreateParams} subscriptionCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public createSubscription(tilledAccount: string, subscriptionCreateParams: SubscriptionCreateParams, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).createSubscription(tilledAccount, subscriptionCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your subscriptions.
     * @summary List all Subscriptions
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {{ [key: string]: string; }} [metadata] &#x60;metadata&#x60; key-value pairs to filter by. Only exact matches on the key-value pair(s) will be returned. Example: &#x60;?metadata[internal_customer_id]&#x3D;7cb1159d-875e-47ae-a309-319fa7ff395b&#x60;.
     * @param {string} [customerId] The ID of the customer whose subscriptions will be retrieved.
     * @param {'active' | 'canceled' | 'past_due' | 'paused' | 'pending'} [status] The status of the subscriptions to retrieve.
     * @param {string} [nextPaymentAtLte] Maximum &#x60;next_payment_at&#x60; value to filter by (inclusive).
     * @param {string} [nextPaymentAtGte] Minimum &#x60;next_payment_at&#x60; value to filter by (inclusive).
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public listAllSubscriptions(tilledAccount: string, metadata?: { [key: string]: string; }, customerId?: string, status?: 'active' | 'canceled' | 'past_due' | 'paused' | 'pending', nextPaymentAtLte?: string, nextPaymentAtGte?: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).listAllSubscriptions(tilledAccount, metadata, customerId, status, nextPaymentAtLte, nextPaymentAtGte, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pauses a subscription from generating payments until the (optionally) specified `resumes_at` date.
     * @summary Pause a Subscription
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {SubscriptionPauseParams} subscriptionPauseParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public pauseSubscription(tilledAccount: string, id: string, subscriptionPauseParams: SubscriptionPauseParams, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).pauseSubscription(tilledAccount, id, subscriptionPauseParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resumes a paused subscription immediately. The next charge will occur on the normally scheduled billing cycle.
     * @summary Resume a Subscription
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public resumeSubscription(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).resumeSubscription(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the subscription with the given ID.
     * @summary Retrieve a Subscription
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public retrieveSubscription(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).retrieveSubscription(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retry a subscription payment at the (optionally) specified `next_payment_at` date.
     * @summary Retry a Subscription
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {SubscriptionRetryParams} subscriptionRetryParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public retrySubscription(tilledAccount: string, id: string, subscriptionRetryParams: SubscriptionRetryParams, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).retrySubscription(tilledAccount, id, subscriptionRetryParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing subscription to match the specified parameters.
     * @summary Update a Subscription
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {SubscriptionUpdateParams} subscriptionUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public updateSubscription(tilledAccount: string, id: string, subscriptionUpdateParams: SubscriptionUpdateParams, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).updateSubscription(tilledAccount, id, subscriptionUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TerminalReadersApi - axios parameter creator
 * @export
 */
export const TerminalReadersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of a merchant\'s terminal readers.
         * @summary List all terminal readers
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTerminalReaders: async (tilledAccount: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listAllTerminalReaders', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/terminal-readers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the terminal reader with the given ID.
         * @summary Retrieve a terminal reader
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTerminal: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('retrieveTerminal', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveTerminal', 'id', id)
            const localVarPath = `/v1/terminal-readers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TerminalReadersApi - functional programming interface
 * @export
 */
export const TerminalReadersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TerminalReadersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of a merchant\'s terminal readers.
         * @summary List all terminal readers
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllTerminalReaders(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllTerminalReaders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllTerminalReaders(tilledAccount, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the terminal reader with the given ID.
         * @summary Retrieve a terminal reader
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveTerminal(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TerminalReader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveTerminal(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TerminalReadersApi - factory interface
 * @export
 */
export const TerminalReadersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TerminalReadersApiFp(configuration)
    return {
        /**
         * Returns a list of a merchant\'s terminal readers.
         * @summary List all terminal readers
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTerminalReaders(tilledAccount: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListAllTerminalReaders200Response> {
            return localVarFp.listAllTerminalReaders(tilledAccount, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the terminal reader with the given ID.
         * @summary Retrieve a terminal reader
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTerminal(tilledAccount: string, id: string, options?: any): AxiosPromise<TerminalReader> {
            return localVarFp.retrieveTerminal(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TerminalReadersApi - object-oriented interface
 * @export
 * @class TerminalReadersApi
 * @extends {BaseAPI}
 */
export class TerminalReadersApi extends BaseAPI {
    /**
     * Returns a list of a merchant\'s terminal readers.
     * @summary List all terminal readers
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalReadersApi
     */
    public listAllTerminalReaders(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return TerminalReadersApiFp(this.configuration).listAllTerminalReaders(tilledAccount, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the terminal reader with the given ID.
     * @summary Retrieve a terminal reader
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TerminalReadersApi
     */
    public retrieveTerminal(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return TerminalReadersApiFp(this.configuration).retrieveTerminal(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks the existance of the user invitation with the given ID.
         * @summary Check a user invitation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserInvitation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkUserInvitation', 'id', id)
            const localVarPath = `/v1/user-invitations/check/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a user.
         * @summary Create a user
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {UserCreateParams} userCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (tilledAccount: string, userCreateParams: UserCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createUser', 'tilledAccount', tilledAccount)
            // verify required parameter 'userCreateParams' is not null or undefined
            assertParamExists('createUser', 'userCreateParams', userCreateParams)
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a user invitation that is subsequently sent to the specified `email`. Once the user registers for an account, the invitation is deleted.
         * @summary Create a user invitation
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {UserInvitationCreateParams} userInvitationCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserInvitation: async (tilledAccount: string, userInvitationCreateParams: UserInvitationCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createUserInvitation', 'tilledAccount', tilledAccount)
            // verify required parameter 'userInvitationCreateParams' is not null or undefined
            assertParamExists('createUserInvitation', 'userInvitationCreateParams', userInvitationCreateParams)
            const localVarPath = `/v1/user-invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInvitationCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a user. It cannot be undone.
         * @summary Delete a user
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('deleteUser', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a user invitation.
         * @summary Delete a user invitation
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserInvitation: async (id: string, tilledAccount: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUserInvitation', 'id', id)
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('deleteUserInvitation', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/user-invitations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a temporary link be sent to the supplied email address that will allow the user to reset their password.
         * @summary Forgot Password
         * @param {ForgotPasswordParams} forgotPasswordParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (forgotPasswordParams: ForgotPasswordParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordParams' is not null or undefined
            assertParamExists('forgotPassword', 'forgotPasswordParams', forgotPasswordParams)
            const localVarPath = `/v1/auth/forgot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your account\'s user invitations.
         * @summary List all user invitations
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllUserInvitations: async (tilledAccount: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listAllUserInvitations', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/user-invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your account\'s users.
         * @summary List all users
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllUsers: async (tilledAccount: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listAllUsers', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a JSON Web Token with email and password.
         * @summary Login
         * @param {LoginParams} loginParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginParams: LoginParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginParams' is not null or undefined
            assertParamExists('login', 'loginParams', loginParams)
            const localVarPath = `/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidates the refresh token for a user.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a new access token with a user\'s refresh token.
         * @summary Refresh Access Token
         * @param {AccessTokenRefreshParams} accessTokenRefreshParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken: async (accessTokenRefreshParams: AccessTokenRefreshParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessTokenRefreshParams' is not null or undefined
            assertParamExists('refreshAccessToken', 'accessTokenRefreshParams', accessTokenRefreshParams)
            const localVarPath = `/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessTokenRefreshParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Tilled user and simultaneously creates a `partner` account. *Note: This resource should almost never be used by an existing Tilled customer.*
         * @summary Register
         * @param {RegisterParams} registerParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerParams: RegisterParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerParams' is not null or undefined
            assertParamExists('register', 'registerParams', registerParams)
            const localVarPath = `/v1/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends the user invitation with the given ID.
         * @summary Resend a user invitation
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUserInvitation: async (id: string, tilledAccount: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resendUserInvitation', 'id', id)
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('resendUserInvitation', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/user-invitations/{id}/resend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset a user\'s password with the supplied `password_reset_token`. This will also invalidate a user\'s refresh token.
         * @summary Reset Password
         * @param {UserResetPasswordParams} userResetPasswordParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (userResetPasswordParams: UserResetPasswordParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userResetPasswordParams' is not null or undefined
            assertParamExists('resetPassword', 'userResetPasswordParams', userResetPasswordParams)
            const localVarPath = `/v1/auth/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userResetPasswordParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the user with the given ID.
         * @summary Retrieve a user
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('retrieveUser', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUser', 'id', id)
            const localVarPath = `/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the user invitation with the given ID.
         * @summary Retrieve a user invitation
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserInvitation: async (id: string, tilledAccount: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUserInvitation', 'id', id)
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('retrieveUserInvitation', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/user-invitations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the user. Any parameters not provided will be left unchanged.
         * @summary Update a user
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {UserUpdateParams} userUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (tilledAccount: string, id: string, userUpdateParams: UserUpdateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('updateUser', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'userUpdateParams' is not null or undefined
            assertParamExists('updateUser', 'userUpdateParams', userUpdateParams)
            const localVarPath = `/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Checks the existance of the user invitation with the given ID.
         * @summary Check a user invitation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkUserInvitation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInvitationCheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkUserInvitation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a user.
         * @summary Create a user
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {UserCreateParams} userCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(tilledAccount: string, userCreateParams: UserCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(tilledAccount, userCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a user invitation that is subsequently sent to the specified `email`. Once the user registers for an account, the invitation is deleted.
         * @summary Create a user invitation
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {UserInvitationCreateParams} userInvitationCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserInvitation(tilledAccount: string, userInvitationCreateParams: UserInvitationCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserInvitation(tilledAccount, userInvitationCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes a user. It cannot be undone.
         * @summary Delete a user
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes a user invitation.
         * @summary Delete a user invitation
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserInvitation(id: string, tilledAccount: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserInvitation(id, tilledAccount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request a temporary link be sent to the supplied email address that will allow the user to reset their password.
         * @summary Forgot Password
         * @param {ForgotPasswordParams} forgotPasswordParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(forgotPasswordParams: ForgotPasswordParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(forgotPasswordParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your account\'s user invitations.
         * @summary List all user invitations
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllUserInvitations(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllUserInvitations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllUserInvitations(tilledAccount, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your account\'s users.
         * @summary List all users
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllUsers(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllUsers(tilledAccount, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a JSON Web Token with email and password.
         * @summary Login
         * @param {LoginParams} loginParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginParams: LoginParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invalidates the refresh token for a user.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a new access token with a user\'s refresh token.
         * @summary Refresh Access Token
         * @param {AccessTokenRefreshParams} accessTokenRefreshParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAccessToken(accessTokenRefreshParams: AccessTokenRefreshParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(accessTokenRefreshParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Tilled user and simultaneously creates a `partner` account. *Note: This resource should almost never be used by an existing Tilled customer.*
         * @summary Register
         * @param {RegisterParams} registerParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerParams: RegisterParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resends the user invitation with the given ID.
         * @summary Resend a user invitation
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendUserInvitation(id: string, tilledAccount: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendUserInvitation(id, tilledAccount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset a user\'s password with the supplied `password_reset_token`. This will also invalidate a user\'s refresh token.
         * @summary Reset Password
         * @param {UserResetPasswordParams} userResetPasswordParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(userResetPasswordParams: UserResetPasswordParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(userResetPasswordParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the user with the given ID.
         * @summary Retrieve a user
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUser(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUser(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the user invitation with the given ID.
         * @summary Retrieve a user invitation
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserInvitation(id: string, tilledAccount: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserInvitation(id, tilledAccount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the user. Any parameters not provided will be left unchanged.
         * @summary Update a user
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {UserUpdateParams} userUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(tilledAccount: string, id: string, userUpdateParams: UserUpdateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(tilledAccount, id, userUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Checks the existance of the user invitation with the given ID.
         * @summary Check a user invitation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkUserInvitation(id: string, options?: any): AxiosPromise<UserInvitationCheck> {
            return localVarFp.checkUserInvitation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a user.
         * @summary Create a user
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {UserCreateParams} userCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(tilledAccount: string, userCreateParams: UserCreateParams, options?: any): AxiosPromise<User> {
            return localVarFp.createUser(tilledAccount, userCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a user invitation that is subsequently sent to the specified `email`. Once the user registers for an account, the invitation is deleted.
         * @summary Create a user invitation
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {UserInvitationCreateParams} userInvitationCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserInvitation(tilledAccount: string, userInvitationCreateParams: UserInvitationCreateParams, options?: any): AxiosPromise<UserInvitation> {
            return localVarFp.createUserInvitation(tilledAccount, userInvitationCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a user. It cannot be undone.
         * @summary Delete a user
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(tilledAccount: string, id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteUser(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a user invitation.
         * @summary Delete a user invitation
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserInvitation(id: string, tilledAccount: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteUserInvitation(id, tilledAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * Request a temporary link be sent to the supplied email address that will allow the user to reset their password.
         * @summary Forgot Password
         * @param {ForgotPasswordParams} forgotPasswordParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(forgotPasswordParams: ForgotPasswordParams, options?: any): AxiosPromise<void> {
            return localVarFp.forgotPassword(forgotPasswordParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your account\'s user invitations.
         * @summary List all user invitations
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllUserInvitations(tilledAccount: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListAllUserInvitations200Response> {
            return localVarFp.listAllUserInvitations(tilledAccount, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your account\'s users.
         * @summary List all users
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllUsers(tilledAccount: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListAllUsers200Response> {
            return localVarFp.listAllUsers(tilledAccount, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a JSON Web Token with email and password.
         * @summary Login
         * @param {LoginParams} loginParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginParams: LoginParams, options?: any): AxiosPromise<LoginDto> {
            return localVarFp.login(loginParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidates the refresh token for a user.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a new access token with a user\'s refresh token.
         * @summary Refresh Access Token
         * @param {AccessTokenRefreshParams} accessTokenRefreshParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(accessTokenRefreshParams: AccessTokenRefreshParams, options?: any): AxiosPromise<void> {
            return localVarFp.refreshAccessToken(accessTokenRefreshParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Tilled user and simultaneously creates a `partner` account. *Note: This resource should almost never be used by an existing Tilled customer.*
         * @summary Register
         * @param {RegisterParams} registerParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerParams: RegisterParams, options?: any): AxiosPromise<RegisterDto> {
            return localVarFp.register(registerParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends the user invitation with the given ID.
         * @summary Resend a user invitation
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendUserInvitation(id: string, tilledAccount: string, options?: any): AxiosPromise<UserInvitation> {
            return localVarFp.resendUserInvitation(id, tilledAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset a user\'s password with the supplied `password_reset_token`. This will also invalidate a user\'s refresh token.
         * @summary Reset Password
         * @param {UserResetPasswordParams} userResetPasswordParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(userResetPasswordParams: UserResetPasswordParams, options?: any): AxiosPromise<void> {
            return localVarFp.resetPassword(userResetPasswordParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the user with the given ID.
         * @summary Retrieve a user
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser(tilledAccount: string, id: string, options?: any): AxiosPromise<User> {
            return localVarFp.retrieveUser(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the user invitation with the given ID.
         * @summary Retrieve a user invitation
         * @param {string} id 
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserInvitation(id: string, tilledAccount: string, options?: any): AxiosPromise<UserInvitation> {
            return localVarFp.retrieveUserInvitation(id, tilledAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the user. Any parameters not provided will be left unchanged.
         * @summary Update a user
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {UserUpdateParams} userUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(tilledAccount: string, id: string, userUpdateParams: UserUpdateParams, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(tilledAccount, id, userUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Checks the existance of the user invitation with the given ID.
     * @summary Check a user invitation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public checkUserInvitation(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).checkUserInvitation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a user.
     * @summary Create a user
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {UserCreateParams} userCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(tilledAccount: string, userCreateParams: UserCreateParams, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(tilledAccount, userCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a user invitation that is subsequently sent to the specified `email`. Once the user registers for an account, the invitation is deleted.
     * @summary Create a user invitation
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {UserInvitationCreateParams} userInvitationCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserInvitation(tilledAccount: string, userInvitationCreateParams: UserInvitationCreateParams, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUserInvitation(tilledAccount, userInvitationCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a user. It cannot be undone.
     * @summary Delete a user
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a user invitation.
     * @summary Delete a user invitation
     * @param {string} id 
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserInvitation(id: string, tilledAccount: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserInvitation(id, tilledAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request a temporary link be sent to the supplied email address that will allow the user to reset their password.
     * @summary Forgot Password
     * @param {ForgotPasswordParams} forgotPasswordParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public forgotPassword(forgotPasswordParams: ForgotPasswordParams, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).forgotPassword(forgotPasswordParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your account\'s user invitations.
     * @summary List all user invitations
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listAllUserInvitations(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listAllUserInvitations(tilledAccount, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your account\'s users.
     * @summary List all users
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listAllUsers(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listAllUsers(tilledAccount, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a JSON Web Token with email and password.
     * @summary Login
     * @param {LoginParams} loginParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public login(loginParams: LoginParams, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).login(loginParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidates the refresh token for a user.
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public logout(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a new access token with a user\'s refresh token.
     * @summary Refresh Access Token
     * @param {AccessTokenRefreshParams} accessTokenRefreshParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public refreshAccessToken(accessTokenRefreshParams: AccessTokenRefreshParams, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).refreshAccessToken(accessTokenRefreshParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Tilled user and simultaneously creates a `partner` account. *Note: This resource should almost never be used by an existing Tilled customer.*
     * @summary Register
     * @param {RegisterParams} registerParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public register(registerParams: RegisterParams, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).register(registerParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends the user invitation with the given ID.
     * @summary Resend a user invitation
     * @param {string} id 
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resendUserInvitation(id: string, tilledAccount: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).resendUserInvitation(id, tilledAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset a user\'s password with the supplied `password_reset_token`. This will also invalidate a user\'s refresh token.
     * @summary Reset Password
     * @param {UserResetPasswordParams} userResetPasswordParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public resetPassword(userResetPasswordParams: UserResetPasswordParams, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).resetPassword(userResetPasswordParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the user with the given ID.
     * @summary Retrieve a user
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public retrieveUser(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).retrieveUser(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the user invitation with the given ID.
     * @summary Retrieve a user invitation
     * @param {string} id 
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public retrieveUserInvitation(id: string, tilledAccount: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).retrieveUserInvitation(id, tilledAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the user. Any parameters not provided will be left unchanged.
     * @summary Update a user
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {UserUpdateParams} userUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(tilledAccount: string, id: string, userUpdateParams: UserUpdateParams, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(tilledAccount, id, userUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhookEndpointsApi - axios parameter creator
 * @export
 */
export const WebhookEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A webhook endpoint must have a url and a list of enabled_events. The specified url will be notified about events from all connected accounts along with your account.
         * @summary Create a webhook endpoint
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {WebhookEndpointCreateParams} webhookEndpointCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhookEndpoint: async (tilledAccount: string, webhookEndpointCreateParams: WebhookEndpointCreateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('createWebhookEndpoint', 'tilledAccount', tilledAccount)
            // verify required parameter 'webhookEndpointCreateParams' is not null or undefined
            assertParamExists('createWebhookEndpoint', 'webhookEndpointCreateParams', webhookEndpointCreateParams)
            const localVarPath = `/v1/webhook-endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookEndpointCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook endpoint.
         * @summary Delete a webhook endpoint
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookEndpoint: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('deleteWebhookEndpoint', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhookEndpoint', 'id', id)
            const localVarPath = `/v1/webhook-endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your webhook endpoints.
         * @summary List all webhook endpoints
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllWebhookEndpoints: async (tilledAccount: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('listAllWebhookEndpoints', 'tilledAccount', tilledAccount)
            const localVarPath = `/v1/webhook-endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the webhook endpoint with the given ID.
         * @summary Retrieve a webhook endpoint
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebhookEndpoint: async (tilledAccount: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('retrieveWebhookEndpoint', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveWebhookEndpoint', 'id', id)
            const localVarPath = `/v1/webhook-endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the webhook endpoint. Any parameters not provided will be left unchanged.
         * @summary Update a webhook endpoint
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {WebhookEndpointUpdateParams} webhookEndpointUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookEndpoint: async (tilledAccount: string, id: string, webhookEndpointUpdateParams: WebhookEndpointUpdateParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tilledAccount' is not null or undefined
            assertParamExists('updateWebhookEndpoint', 'tilledAccount', tilledAccount)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWebhookEndpoint', 'id', id)
            // verify required parameter 'webhookEndpointUpdateParams' is not null or undefined
            assertParamExists('updateWebhookEndpoint', 'webhookEndpointUpdateParams', webhookEndpointUpdateParams)
            const localVarPath = `/v1/webhook-endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication TilledApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "tilled-api-key", configuration)

            if (tilledAccount !== undefined && tilledAccount !== null) {
                localVarHeaderParameter['tilled-account'] = String(tilledAccount);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookEndpointUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookEndpointsApi - functional programming interface
 * @export
 */
export const WebhookEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * A webhook endpoint must have a url and a list of enabled_events. The specified url will be notified about events from all connected accounts along with your account.
         * @summary Create a webhook endpoint
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {WebhookEndpointCreateParams} webhookEndpointCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhookEndpoint(tilledAccount: string, webhookEndpointCreateParams: WebhookEndpointCreateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhookEndpoint(tilledAccount, webhookEndpointCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a webhook endpoint.
         * @summary Delete a webhook endpoint
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhookEndpoint(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhookEndpoint(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your webhook endpoints.
         * @summary List all webhook endpoints
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllWebhookEndpoints(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllWebhookEndpoints200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllWebhookEndpoints(tilledAccount, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the webhook endpoint with the given ID.
         * @summary Retrieve a webhook endpoint
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveWebhookEndpoint(tilledAccount: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveWebhookEndpoint(tilledAccount, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the webhook endpoint. Any parameters not provided will be left unchanged.
         * @summary Update a webhook endpoint
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {WebhookEndpointUpdateParams} webhookEndpointUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhookEndpoint(tilledAccount: string, id: string, webhookEndpointUpdateParams: WebhookEndpointUpdateParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhookEndpoint(tilledAccount, id, webhookEndpointUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhookEndpointsApi - factory interface
 * @export
 */
export const WebhookEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookEndpointsApiFp(configuration)
    return {
        /**
         * A webhook endpoint must have a url and a list of enabled_events. The specified url will be notified about events from all connected accounts along with your account.
         * @summary Create a webhook endpoint
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {WebhookEndpointCreateParams} webhookEndpointCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhookEndpoint(tilledAccount: string, webhookEndpointCreateParams: WebhookEndpointCreateParams, options?: any): AxiosPromise<WebhookEndpoint> {
            return localVarFp.createWebhookEndpoint(tilledAccount, webhookEndpointCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook endpoint.
         * @summary Delete a webhook endpoint
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhookEndpoint(tilledAccount: string, id: string, options?: any): AxiosPromise<object> {
            return localVarFp.deleteWebhookEndpoint(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your webhook endpoints.
         * @summary List all webhook endpoints
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
         * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllWebhookEndpoints(tilledAccount: string, offset?: number, limit?: number, options?: any): AxiosPromise<ListAllWebhookEndpoints200Response> {
            return localVarFp.listAllWebhookEndpoints(tilledAccount, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the webhook endpoint with the given ID.
         * @summary Retrieve a webhook endpoint
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveWebhookEndpoint(tilledAccount: string, id: string, options?: any): AxiosPromise<WebhookEndpoint> {
            return localVarFp.retrieveWebhookEndpoint(tilledAccount, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the webhook endpoint. Any parameters not provided will be left unchanged.
         * @summary Update a webhook endpoint
         * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
         * @param {string} id 
         * @param {WebhookEndpointUpdateParams} webhookEndpointUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookEndpoint(tilledAccount: string, id: string, webhookEndpointUpdateParams: WebhookEndpointUpdateParams, options?: any): AxiosPromise<WebhookEndpoint> {
            return localVarFp.updateWebhookEndpoint(tilledAccount, id, webhookEndpointUpdateParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookEndpointsApi - object-oriented interface
 * @export
 * @class WebhookEndpointsApi
 * @extends {BaseAPI}
 */
export class WebhookEndpointsApi extends BaseAPI {
    /**
     * A webhook endpoint must have a url and a list of enabled_events. The specified url will be notified about events from all connected accounts along with your account.
     * @summary Create a webhook endpoint
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {WebhookEndpointCreateParams} webhookEndpointCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookEndpointsApi
     */
    public createWebhookEndpoint(tilledAccount: string, webhookEndpointCreateParams: WebhookEndpointCreateParams, options?: AxiosRequestConfig) {
        return WebhookEndpointsApiFp(this.configuration).createWebhookEndpoint(tilledAccount, webhookEndpointCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a webhook endpoint.
     * @summary Delete a webhook endpoint
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookEndpointsApi
     */
    public deleteWebhookEndpoint(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return WebhookEndpointsApiFp(this.configuration).deleteWebhookEndpoint(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your webhook endpoints.
     * @summary List all webhook endpoints
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {number} [offset] The (zero-based) offset of the first item in the collection to return.
     * @param {number} [limit] The maximum number of entries to return. If the value exceeds the maximum, then the maximum value will be used.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookEndpointsApi
     */
    public listAllWebhookEndpoints(tilledAccount: string, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return WebhookEndpointsApiFp(this.configuration).listAllWebhookEndpoints(tilledAccount, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the webhook endpoint with the given ID.
     * @summary Retrieve a webhook endpoint
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookEndpointsApi
     */
    public retrieveWebhookEndpoint(tilledAccount: string, id: string, options?: AxiosRequestConfig) {
        return WebhookEndpointsApiFp(this.configuration).retrieveWebhookEndpoint(tilledAccount, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the webhook endpoint. Any parameters not provided will be left unchanged.
     * @summary Update a webhook endpoint
     * @param {string} tilledAccount The id of the Tilled Account (usually starting with the prefix &#x60;acct_&#x60;) that the request is performed on behalf of.
     * @param {string} id 
     * @param {WebhookEndpointUpdateParams} webhookEndpointUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookEndpointsApi
     */
    public updateWebhookEndpoint(tilledAccount: string, id: string, webhookEndpointUpdateParams: WebhookEndpointUpdateParams, options?: AxiosRequestConfig) {
        return WebhookEndpointsApiFp(this.configuration).updateWebhookEndpoint(tilledAccount, id, webhookEndpointUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }
}


